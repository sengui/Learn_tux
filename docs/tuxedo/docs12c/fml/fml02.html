<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>

<!-- LOCALIZATION RELATED INFORMATION -->
<meta name="LOC_PROJ_ID" content="WLPF8.1" />
<meta name="LOC_OWNER" content="BEAJ" />
<meta name="LOC_STATUS" content="READY!" />
<meta name="LOC_COMMENT" content="LOC_COMMENT" />
<meta name="LOC_US_REV" content="1" />
<meta name="LOC_US_CHANGE" content="41824" />
<meta name="LOC_US_SRCFILE" content="//depot/tuxedo/tux12c/fml/fm/fml02.fm" />
<!-- LOCALIZATION RELATED INFORMATION -->

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="GENERATOR" content="Quadralay WebWorks AutoMap 2003 Platinum Edition for FrameMaker 8.6.6577.0" />
    <meta name="TEMPLATEBASE" content="BEA_WFP_Template_V1.04" />
    <meta name="LASTUPDATED" content="06/26/12 11:06:07" />
    <link rel="StyleSheet" href="/global_resources/edocs.css" type="text/css" media="all" />

<title>FML and VIEWS Features</title>

<!-- BEA scripts begin -->

<script language="Javascript" src="/global_resources/js/banner.js" type="text/javascript"></script>
<!-- This script outputs the banner required for edocs documentation. -->

<script language="Javascript" src="floatwin.js" type="text/javascript"></script>
<!-- This script opens a new small floating window and puts TOC<i>&lt;name&gt;</i>.html and IX<i>&lt;name&gt;</i>.html files in it and sets a generic popup window code to enable the display of some viewlets in the WebLogic Platform Tour. -->

<script language="Javascript1.1" src="/global_resources/js/footer.js" type="text/javascript"></script>
<!-- This script outputs the footer with the correct copyright date and link to copyright page.-->

<script language="Javascript1.1" src="/global_resources/js/googlesearch4.js" type="text/javascript"></script>
<!-- This script outputs the google search form. -->

<script language="Javascript1.1" src="/global_resources/js/note.js" type="text/javascript"></script>
<!-- This script outputs a note such as a BETA note. -->

<script language="JavaScript1.1" src="/global_resources/js/search.js" type="text/javascript"></script>
<!-- This script is not for online documents. It is only used by the QuestAgent Java Applet for CD search indexes. -->

<!-- BEA scripts end -->

  </head>

  <body>


<script language="Javascript1.1" type="text/javascript">
GoogleURL();
</script><noscript>This script outputs the google search URL required for search on edocs documentation.</noscript>

<script language="Javascript1.1" type="text/javascript">
Banner();
</script><noscript>This script outputs the banner required for edocs documentation.</noscript>

<script language="Javascript1.1" type="text/javascript">
GoogleSearchCollection();
</script><noscript>This script outputs the google search parameters required for search on edocs documentation.</noscript>

<!-- page title -->
<h1 class="booktitle">Programming an Oracle Tuxedo ATMI Application Using FML
</h1>
<!-- page title end -->

    <table id="SummaryNotReq1" width="100%" border="0" align="left" cellpadding="2%" cellspacing="0">
      <tr> 
        <td>
&nbsp;&nbsp;&nbsp;&nbsp;
<a accesskey="4" href="fml01.html"><img id="LongDescNotReq5" src="/global_resources/images/doc_nav_prev.gif" border="0" alt="Previous" /></a>&nbsp;
<a accesskey="5" href="fml03.html"><img id="LongDescNotReq6" src="/global_resources/images/doc_nav_next.gif" border="0" alt="Next" /></a>&nbsp;
<img id="LongDescNotReq7" src="/global_resources/images/doc_nav_dots.gif" border="0" alt="" />&nbsp;
<a accesskey="1" href="javascript:OpenWindowToc();" onmouseover="window.status='Table of Contents'; return true" onfocus="window.status='Table of Contents'; return true" onmouseout="window.status=''; return true" onblur="window.status=''; return true" title="Open TOC in new window">      <img id="LongDescNotReq8" src="/global_resources/images/doc_nav_contents.gif" alt="Open TOC in new window" border="0" /></a>&nbsp;
<a accesskey="2" href="javascript:OpenWindowIndex();" onmouseover="window.status='Index'; return true" onfocus="window.status='Index'; return true" onmouseout="window.status=''; return true" onblur="window.status=''; return true" title="Open Index in new window">     <img id="LongDescNotReq9" src="/global_resources//images/doc_nav_index.gif" border="0" alt="Open Index in new window" /></a>&nbsp;
<a href="../pdf/fml.pdf" target="pdf"><img id="LongDescNotReq10" src="/global_resources/images/doc_nav_pdf.gif" width="59" height="44" alt="View as PDF - New Window" title="View as PDF - New Window" border="0" /></a>&nbsp;
<a href="http://www.adobe.com/products/acrobat/alternate.html" target="_blank"><img id="LongDescNotReq11" src="/global_resources/images/get_reader.gif" width="52" height="44" alt="Get Adobe Reader - New Window" title="Get Adobe Reader - New Window" border="0" /></a>
<a name="link_group_0"></a>
	</td>
      </tr>
    </table>

<a name="skipnav" title="Content starts here"><img src="/global_resources/images/_.gif" alt="Content starts here" border="0" height="1" width="1" /></a>



<h1 class="pChapHead"><a name="wp1011963"> </a>
FML and VIEWS Features
</h1>
<p class="pBody"><a name="wp1007808"> </a>
This topic includes the following sections:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1006214"> </a><a href="fml02.html#wp1006220">Dividing Records into Fields: Data Structures Versus Fielded Buffers</a></li>
<li><a name="wp1006215"> </a><a href="fml02.html#wp1006247">How Fielded Buffers Are Implemented with FML</a></li>
<li><a name="wp1006216"> </a><a href="fml02.html#wp1006278">FML Features</a></li>
<li><a name="wp1006217"> </a><a href="fml02.html#wp1006404">VIEWS Features</a></li>
<li><a name="wp1006218"> </a><a href="fml02.html#wp1006447">Error Handling for FML Functions</a></li>
</ul></div>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1006220"> </a>
Dividing Records into Fields: Data Structures Versus Fielded Buffers
</h2><p class="pBody"><a name="wp1006221"> </a>
Except under unusual conditions where a data record is a complete and indivisible entity, you need to be able to break records into fields to be able to use or change the information the record contains. In an ATMI environment, records can be divided into fields through either of the following:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1006222"> </a>C language data structures or COBOL records</li>
<li><a name="wp1006223"> </a>Fielded buffers</li>
</ul></div>
<h3 class="pHeading2"><a name="wp1006224"> </a>
Using Structures to Divide Records into Fields
</h3>
<p class="pBody"><a name="wp1006225"> </a>
One common way of subdividing records is with a structure that divides a contiguous area of storage into fields. The fields are given names for identification; the kind of data carried in each field is shown by a data type declaration.
</p>
<p class="pBody"><a name="wp1006226"> </a>
For example, if a data item in a C language program is to contain information about an employee&#8217;s identification number, name, address, and gender, it could be set up with a structure such as the following:
</p>
<a name="wp1006227"> </a><div class="pPreformatted"><pre>struct S {<br />       long empid;<br />       char name[20];<br />       char addr[40];<br />       char gender;<br />};</pre></div><p class="pBody"><a name="wp1006228"> </a>
Here the data type of the field named <code class="cCode">empid</code> is declared to be a long integer, <code class="cCode">name</code> and <code class="cCode">addr</code> are declared to be character arrays of 20 and 40 characters respectively, and <code class="cCode">gender</code> is declared to be a single character, presumably with a range of <code class="cCode">m</code> or <code class="cCode">f</code>.
</p>
<p class="pBody"><a name="wp1006229"> </a>
If, in your C program, the variable <code class="cCode">p</code> points to a structure of type struct <code class="cCode">S</code>, the references <code class="cCode">p</code><span class="arrow"><img id="LongDescNotReq1" src="/global_resources/images/arrwrite.gif" alt="Arrow symbol"/></span><code class="cCode">empid</code>, <code class="cCode">p</code><span class="arrow"><img id="LongDescNotReq2" src="/global_resources/images/arrwrite.gif" alt="Arrow symbol"/></span><code class="cCode">name</code>, <code class="cCode">p</code><span class="arrow"><img id="LongDescNotReq3" src="/global_resources/images/arrwrite.gif" alt="Arrow symbol"/></span><code class="cCode">addr</code> and <code class="cCode">p</code><span class="arrow"><img id="LongDescNotReq4" src="/global_resources/images/arrwrite.gif" alt="Arrow symbol"/></span><code class="cCode">gender</code> can be used to address the fields.
</p>
<p class="pBody"><a name="wp1006230"> </a>
The COBOL COPY file for the same data structure would be as follows (the application would supply the 01 line): 
</p>
<a name="wp1006231"> </a><div class="pPreformatted"><pre>05 EMPID                           PIC S9(9) USAGE IS COMP-5.<br />05 NAME                            PIC X(20).<br />05 ADDR                            PIC X(40).<br />05 GENDER                          PIC X(01).<br />05 FILLER                          PIC X(03).</pre></div><p class="pBody"><a name="wp1006232"> </a>
If, in your COBOL program, the 01 line is named <code class="cCode">MYREC</code>, the references <code class="cCode">EMPID IN MYREC</code>, <code class="cCode">NAME IN MYREC</code>, <code class="cCode">ADDR IN MYREC</code>, and <code class="cCode">GENDER IN MYREC</code> can be used to access the fields.
</p>
<p class="pBody"><a name="wp1006233"> </a>
Although this method of representing data is widely used and is often appropriate, it has two major potential disadvantages: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1006234"> </a>Any time the data structure is changed, all programs using the structure have to be recompiled.</li>
<li><a name="wp1006235"> </a>The size of the structure and the offsets of the component fields are all fixed, which often results in wasted space, since (a) not all fields always contain a value, and (b) fields tend to be sized to hold the largest likely entry.</li>
</ul></div>
<h3 class="pHeading2"><a name="wp1006236"> </a>
Using Fielded Buffers to Divide Records into Fields
</h3>
<p class="pBody"><a name="wp1006237"> </a>
Fielded buffers provide an alternative method for subdividing a record into fields.
</p>
<p class="pBody"><a name="wp1006238"> </a>
A fielded buffer is a data structure that provides associative access to the fields of a record; that is, the name of a field is associated with an identifier that includes the storage location as well as the data type of the field.
</p>
<p class="pBody"><a name="wp1006239"> </a>
The main advantage of the fielded buffer is data independence. Fields can be added to the buffer, deleted from it, or changed in length without forcing programs that reference the fields to be recompiled. To achieve this data independence, fields are:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1006240"> </a>Referenced by an identifier rather than the fixed offset prescribed by record structures.</li>
<li><a name="wp1006241"> </a>Accessed only through function calls.</li>
</ul></div>
<p class="pBody"><a name="wp1006245"> </a>
Fielded buffers can be used throughout the ATMI environment as the standard method of representing data sent between cooperating processes.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1006247"> </a>
How Fielded Buffers Are Implemented with FML
</h2><p class="pBody"><a name="wp1006248"> </a>
Fielded buffers are created, updated, accessed, input, and output via Field Manipulation Language (FML). FML provides: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1006252"> </a>A convenient and standard discipline for creating and manipulating fielded buffers.</li>
<li><a name="wp1006253"> </a>Data independence to programs that make use of fielded buffers.</li>
</ul></div>
<p class="pBody"><a name="wp1006257"> </a>
FML is implemented as a library of functions and macros that can be called from C programs. It provides a separate set of functions for:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1006258"> </a>Creating, updating, accessing, and manipulating fielded buffers.</li>
<li><a name="wp1006259"> </a>Converting data from one type to another upon input to (or output from) a fielded buffer structure.</li>
<li><a name="wp1006260"> </a>Transferring data between fielded buffers and C structures or COBOL records.</li>
</ul></div>
<p class="pBody"><a name="wp1006264"> </a>
The last set of functions listed above constitutes the FML VIEWS software. VIEWS is a set of functions that exchange data between FML fielded buffers and structures in C or COBOL language application programs. When a program receives a fielded buffer from another process, the program has the choice of: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1006271"> </a>Operating on the buffer data directly in the buffer using FML function calls (this is not available in COBOL).</li>
<li><a name="wp1006272"> </a>Transferring the data from the fielded buffer to a structure using VIEWS functions, and then operating on the data in the structure using normal C or COBOL statements.</li>
</ul></div>
<p class="pBody"><a name="wp1006273"> </a>
If you need to perform lengthy manipulations on buffer data, the performance of your program can be improved by transferring fielded buffer data to structures or records, and operating on the data using normal C or COBOL statements. Then you can put the data back into a fielded buffer (again using VIEWS functions), and send the buffer off to another process.
</p>
<p class="pBody"><a name="wp1006274"> </a>
Before you can use VIEWS, you must set up your program such that it can recognize the format of incoming fielded buffer data. You can do this setup task by using a set of view descriptions kept in a cache on your system.
</p>
<p class="pBody"><a name="wp1006275"> </a>
A view description is created and stored in a source viewfile. The view description maps fields in fielded buffers to members in C structures or COBOL records. The source view descriptions are compiled, and can then be used to map data transferred between fielded buffers and C structures or COBOL records in a program.
</p>
<p class="pBody"><a name="wp1006276"> </a>
By keeping view descriptions cached in a central file, you can increase the data independence of your programs; you only need to change the view description(s) and recompile them to effect changes in data format throughout an application that uses VIEWS.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1006278"> </a>
FML Features
</h2><p class="pBody"><a name="wp1007821"> </a>
This topic includes the following sections:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1006279"> </a><a href="fml02.html#wp1006286">What Is a Fielded Buffer?</a></li>
<li><a name="wp1006280"> </a><a href="fml02.html#wp1006304">Supported Field Types</a></li>
<li><a name="wp1006281"> </a><a href="fml02.html#wp1006335">Field Name-to-Identifier Mappings</a></li>
<li><a name="wp1006282"> </a><a href="fml02.html#wp1006386">Fielded Buffer Indexes</a></li>
<li><a name="wp1006283"> </a><a href="fml02.html#wp1006392">Multiple Occurrence Fields in a Fielded Buffer</a></li>
<li><a name="wp1006284"> </a><a href="fml02.html#wp1006396">Boolean Expressions and Fielded Buffers</a></li>
</ul></div>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1006286"> </a>
What Is a Fielded Buffer?
</h2><p class="pBody"><a name="wp1006287"> </a>
A fielded buffer is a data structure that provides associative access to the fields of a record.
</p>
<p class="pBody"><a name="wp1006291"> </a>
Each field in an FML fielded buffer is labeled with an integer that combines information about the data type of the accompanying field with a unique identifying number. The label is called the field identifier, or <code class="cCode">fldid</code>. For variable-length items, the <code class="cCode">fldid</code> is followed by a length indicator. 
</p>
<p class="pBody"><a name="wp1006292"> </a>
A buffer can be represented as a sequence of <code class="cCode">fldid</code>/data pairs, with <code class="cCode">fldid</code>/length/data triples for variable-length items, as shown in the following diagram.
</p>
<div class="pFigureTitle"><a name="wp1006296"> </a>
Figure&#160;2-1  Fielded Buffer
</div>

 
 <p class="pGraphic"><a name="wp1006707"> </a>
</p>
<div class="figure" align="left"><img src="wwimages/fml-2-1-1.gif" height="81" width="456" alt="Fielded Buffer" id="wp1006294"/></div><p class="pGraphic">

</p>
<p class="pBody"><a name="wp1006302"> </a>
In the header file that is included (with <code class="cCode">#include</code>) whenever FML functions are used (<code class="cCode">fml.h</code> or <code class="cCode">fml32.h</code>), field identifiers are defined (with <code class="cCode">typedef</code>) as <code class="cCode">FLDID</code> (or <code class="cCode">FLDID32</code> for FML32), field value lengths as <code class="cCode">FLDLEN</code> (<code class="cCode">FLDLEN32</code> for FML32), and field occurrence numbers as <code class="cCode">FLDOCC</code> (<code class="cCode">FLDOCC32</code> for FML32).
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1006304"> </a>
Supported Field Types
</h2><p class="pBody"><a name="wp1008998"> </a>
The supported field types are <code class="cCode">short</code>, <code class="cCode">long</code>, <code class="cCode">float</code>, <code class="cCode">double</code>, <code class="cCode">char</code>, <code class="cCode">string</code>, <code class="cCode">carray</code> (character array), <code class="cCode">mbstring </code>(multibyte character array&#8212;available in Tuxedo release 8.1 or later), <code class="cCode">ptr</code> (pointer to a buffer), <code class="cCode">fml32</code> (an embedded FML32 buffer), and <code class="cCode">view32</code> (an embedded VIEW32 buffer). The <code class="cCode">mbstring</code>, <code class="cCode">ptr</code>, <code class="cCode">fml32</code>, and <code class="cCode">view32</code> types are supported only for the FML32 interface. These types are included as <code class="cCode">#define</code> statements in <code class="cCode">fml.h</code> (or <code class="cCode">fml32.h</code>), as shown in the following listing.
</p>
<div class="pCodeTitle"><a name="wp1009000"> </a>
Listing&#160;2-1	   Definitions of FML Field Types in fml.h and fml32.h
</div> <a name="wp1009001"> </a><div class="pPreformatted"><pre>#define FLD_SHORT       0       /* short int */<br />#define FLD_LONG        1       /* long int */<br />#define FLD_CHAR        2       /* character */<br />#define FLD_FLOAT       3       /* single-precision float */<br />#define FLD_DOUBLE      4       /* double-precision float */<br />#define FLD_STRING      5       /* string - null terminated */<br />#define FLD_CARRAY      6       /* character array */ <br />#define FLD_PTR         9       /* pointer to a buffer */<br />#define FLD_FML32      10       /* embedded FML32 buffer */<br />#define FLD_VIEW32     11       /* embedded VIEW32 buffer */<br />#define FLD_MBSTRING   12       /* multibyte character array */</pre></div><p class="pBody"><a name="wp1006310"> </a>
<code class="cCode">FLD_STRING</code>, <code class="cCode">FLD_CARRAY</code>, and <code class="cCode">FLD_MBSTRING</code> are all arrays, but differ in the following way: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1006311"> </a>A <code class="cCode">FLD_STRING</code> is a variable-length array of non-NULL characters terminated by a NULL.</li>
<li><a name="wp1006312"> </a>A <code class="cCode">FLD_CARRAY</code> or <code class="cCode">FLD_MBSTRING</code> is a variable-length array of bytes, any of which may be NULL.</li>
</ul></div>
<p class="pBody"><a name="wp1006313"> </a>
Functions that add or change a field have a <code class="cCode">FLDLEN</code> argument that must be filled in when you are dealing with <code class="cCode">FLD_CARRAY</code> or <code class="cCode">FLD_MBSTRING</code> fields. The size of a string or carray is limited to 65,535 characters in FML, and 2 billion bytes for FML32. 
</p>
<p class="pBody"><a name="wp1006314"> </a>
It is not a good idea to store unsigned data types in fielded buffers. You should either convert all unsigned short data to long or cast the data into the proper unsigned data type whenever you retrieve data from fielded buffers (using the FML conversion functions).
</p>
<p class="pBody"><a name="wp1006321"> </a>
Most FML functions do not perform type checking; they expect that the value you update or retrieve from a fielded buffer matches its native type. For example, if a buffer field is defined to be a <code class="cCode">FLD_LONG</code>, you should always pass the address of a long value. The FML conversion functions convert data from a user specified type to the native field type (and from the field type to a user specified type) in addition to placing the data in (or retrieving the data from) the fielded buffer.
</p>
<p class="pBody"><a name="wp1006325"> </a>
The <code class="cCode">FLD_PTR</code> field type makes it possible to embed pointers to application data in an FML32 buffer. Applications can add, change, access, and delete pointers to data buffers. The buffer pointed to by a <code class="cCode">FLD_PTR</code> field must be allocated using the <a href="../rf3c/rf3c.html">tpalloc(3c)</a> call. The <code class="cCode">FLD_PTR</code> field type is supported only in FML32.
</p>
<p class="pBody"><a name="wp1009325"> </a>
The <code class="cCode">FLD_FML32</code> field type makes it possible to store an entire record as a single field in an FML32 buffer. Similarly, the <code class="cCode">FLD_VIEW32</code> field type allows an entire C structure to be stored as a single field in an FML32 buffer. The <code class="cCode">FLD_FML32</code> and <code class="cCode">FLD_VIEW32</code> field types are supported only in FML32.
</p>
<h3 class="pHeading2"><a name="wp1006327"> </a>
Type int in VIEWS
</h3>
<p class="pBody"><a name="wp1006331"> </a>
In addition to the data types supported by most FML functions, VIEWS indirectly supports type <code class="cCode">int</code> in source view descriptions. When the view description is compiled, the view compiler automatically converts any <code class="cCode">int</code> types to either short or long types, depending on your machine. For more information, see <a href="fml02.html#wp1006404">VIEWS Features</a>.
</p>
<h3 class="pHeading2"><a name="wp1006332"> </a>
Type dec_t in VIEWS
</h3>
<p class="pBody"><a name="wp1006333"> </a>
VIEWS also supports the <code class="cCode">dec_t</code> packed decimal type in source view descriptions. This data type is useful for transferring VIEW structures to COBOL programs. In a C program using the <code class="cCode">dec_t</code> type, the field must be initialized and accessed using the functions described in <a href="../rf3c/rf3c.html">decimal(3c)</a> in the <em class="cEmphasis">Oracle Tuxedo ATMI C Function Reference</em>. Within the COBOL program, the field can be accessed directly using a packed decimal (<code class="cCode">COMP-3</code>) definition. Because FML does not support a <code class="cCode">dec_t</code> field, this field is automatically converted to the data type of the corresponding FML field in the fielded buffer (for example, a string field) when converting from a VIEW to FML.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1006335"> </a>
Field Name-to-Identifier Mappings
</h2><p class="pBody"><a name="wp1006339"> </a>
In the Oracle Tuxedo system, fields are usually referred to by their field identifier (<code class="cCode">fldid</code>), an integer. (Refer to <a href="fml04.html#wp1010346">Defining Field Names and Identifiers</a> for a detailed description of field identifiers.) This allows you to reference fields in a program without using the field name, which may change.
</p>
<p class="pBody"><a name="wp1006340"> </a>
Identifiers are assigned (mapped) to field names through one of the following:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1006344"> </a>Field table files (which are ordinary UNIX files)</li>
<li><a name="wp1006345"> </a>C language header (<code class="cCode">#include</code>) files</li>
</ul></div>
<p class="pBody"><a name="wp1006346"> </a>
A typical application might use one, or both of the above methods to map field identifiers to field names.
</p>
<p class="pBody"><a name="wp1006353"> </a>
In order for FML to access the data in fielded records, there must be some way for FML to access the field name/identifier mappings. FML gets this information in one of two ways: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1006363"> </a>At run time, through UNIX field table files, and FML mapping functions</li>
<li><a name="wp1006364"> </a>At compile time, through C header files</li>
</ul></div>
<p class="pBody"><a name="wp1006365"> </a>
Field name/identifier mapping is not available in COBOL.
</p>
<h3 class="pHeading2"><a name="wp1006366"> </a>
Run Time: Field Table Files
</h3>
<p class="pBody"><a name="wp1006370"> </a>
Field name/identifier mappings can be made available to FML programs at run time through field table files. It is the responsibility of the programmer to set two environment variables that tell FML where the field name/identifier mapping table files are located.
</p>
<p class="pBody"><a name="wp1006374"> </a>
The environment variable <code class="cCode">FLDTBLDIR</code> contains a list of directories where field tables can be found. The environment variable <code class="cCode">FIELDTBLS</code> contains a list of the files in the table directories that are to be used. For FML32, the environment variable names are <code class="cCode">FLDTBLDIR32</code> and <code class="cCode">FIELDTBLS32</code>.
</p>
<p class="pBody"><a name="wp1006378"> </a>
Within application programs, the FML function <code class="cCode">Fldid()</code> provides for a run-time translation of a field name to its field identifier. <code class="cCode">Fname()</code> translates a field identifier to its field name (see <code class="cCode">Fldid(3fml)</code> and <code class="cCode">Fname(3fml)</code>). (The function names for FML32 are <code class="cCode">Fldid32</code> and <code class="cCode">Fname32</code>.) The first invocation of either function causes space in memory to be dynamically allocated for the field tables and the tables to be loaded into the address space of the process. The space can be recovered when the tables are no longer needed. (Refer to <a href="fml04.html#wp1010389">Loading Field Tables</a> for more information.)
</p>
<p class="pBody"><a name="wp1006379"> </a>
This method should be used when field name/identifier mappings are likely to change throughout the life of the application. This topic is covered in more detail in <a href="fml04.html">Defining and Using Fields</a>.
</p>
<h3 class="pHeading2"><a name="wp1006380"> </a>
Compile Time: Header Files
</h3>
<p class="pBody"><a name="wp1006381"> </a>
Use <code class="cCode">mkfldhdr()</code> (or <code class="cCode">mkfldhdr32()</code>) to make header files out of field table files. These header files are included (with <code class="cCode">#include</code>) in C programs, and provide another way to map field names to field identifiers: at compile time. For more information on <a href="../rfcm/rfcmd.html">mkfldhdr,&#160;mk</a><a href="../rfcm/rfcmd.html">fldhdr32(1)</a>, refer to <em class="cEmphasis">Oracle Tuxedo Command Reference</em>.
</p>
<p class="pBody"><a name="wp1006382"> </a>
Using field header files, the C preprocessor converts all field name references to field identifiers at compile time; thus, you do not need to use the <code class="cCode">Fldid()</code> or <code class="cCode">Fname()</code> functions as you would with the field table files described in the previous section.
</p>
<p class="pBody"><a name="wp1006383"> </a>
If you always know the field names needed by your program, you can save some data space by including your field table header files (with <code class="cCode">#include</code>). The space saving allows your program to get to the task at hand more quickly.
</p>
<p class="pBody"><a name="wp1006384"> </a>
Because this method resolves mappings at compile time, however, it should not be used if the field name/identifier mappings in the application are likely to change. For more information, see <a href="fml04.html">Defining and Using Fields</a>.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1006386"> </a>
Fielded Buffer Indexes
</h2><p class="pBody"><a name="wp1006387"> </a>
When a fielded buffer has many fields, access is expedited in FML by the use of an internal index. The user is normally unaware of the existence of this index.
</p>
<p class="pBody"><a name="wp1006388"> </a>
Fielded buffer indexes do, however, take up space in memory and on disk. When you store a fielded buffer on disk, or transmit a fielded buffer between processes or between computers, you can save disk space and/or transmittal time by first discarding the index.
</p>
<p class="pBody"><a name="wp1006389"> </a>
The <code class="cCode">Funindex()</code> function enables you to discard the index. When the fielded buffer is read from disk (or received from a sending process), the index can be explicitly reconstructed with the <code class="cCode">Findex()</code> function. 
</p>
<p class="pBody"><a name="wp1006390"> </a>
Note that these space savings do not apply to memory. The <code class="cCode">Funindex()</code> function does not recover in-core memory used by the index of a fielded buffer.
</p>
<p class="pBody"><a name="wp1007104"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Funindex,&#160;Funindex3</a><a href="../rf3fml/rf3fml.html">2(3fml)</a> or <a href="../rf3fml/rf3fml.html">Findex,&#160;Findex</a><a href="../rf3fml/rf3fml.html">32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1006392"> </a>
Multiple Occurrence Fields in a Fielded Buffer
</h2><p class="pBody"><a name="wp1006393"> </a>
Any field in a fielded buffer can occur more than once. Many FML functions take an argument that specifies which occurrence of a field is to be retrieved or modified. If a field occurs more than once, the first occurrence is numbered 0, and additional occurrences are numbered sequentially. The set of all occurrences makes up a logical sequence, but no overhead is associated with the occurrence number (that is, it is not stored in the fielded buffer). 
</p>
<p class="pBody"><a name="wp1006394"> </a>
If another occurrence of a field is added, it is added at the end of the set and is referred to as the next highest occurrence. When an occurrence other than the highest is deleted, all higher occurrences of the field are shifted down by one (for example, occurrence 6 becomes occurrence 5, 5 becomes 4, and so on).
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1006396"> </a>
Boolean Expressions and Fielded Buffers
</h2><p class="pBody"><a name="wp1006397"> </a>
The next action taken by an application program is frequently determined by the value of one or more fields in a fielded buffer received (by the application) from another source, such as a user&#8217;s terminal or a database record. FML provides several functions that create boolean expressions on fielded buffers or VIEWs and determine whether a given buffer or VIEW meets the criteria specified by the expression.
</p>
<p class="pBody"><a name="wp1006398"> </a>
Once you create a Boolean expression, it is compiled into an evaluation tree. The evaluation tree is then used to determine whether a fielded buffer or VIEW matches the specified Boolean conditions.
</p>
<p class="pBody"><a name="wp1006399"> </a>
For instance, a program may read a data record into a fielded buffer (Buffer A), and apply a Boolean expression to the buffer. If Buffer A meets the conditions specified by the Boolean expression, then an FML function is used to update another buffer, Buffer B, with data from Buffer A.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1006404"> </a>
VIEWS Features
</h2><p class="pBody"><a name="wp1006405"> </a>
The VIEWS facility is particularly useful when a program does a lot of processing on the data in a fielded buffer, either after the program has received the buffer or before the program sends the buffer to another program.
</p>
<p class="pBody"><a name="wp1006406"> </a>
Under such conditions, you may improve processing efficiency by using VIEWS functions to transfer fielded buffer data from the buffer to a C structure before you manipulate it. Processing efficiency is improved because C functions require less processing time than FML functions for manipulating fields in a buffer. When you finish processing the data in the C structure, you can transfer that data back to the fielded buffer before sending it to another program.
</p>
<p class="pBody"><a name="wp1006410"> </a>
The VIEWS facility has the following features: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1006411"> </a>You can create <code class="cCode">source view descriptions</code> that specify C structure-to-fielded buffer mappings or COBOL record-to-fielded buffer mappings, and make possible the transfer of data between structures and buffers.</li>
<li><a name="wp1006412"> </a>The <code class="cCode">viewc</code> or <code class="cCode">viewc32</code> view compiler is used to generate <code class="cCode">object view descriptions</code> (stored in binary files) that are interpreted by your application programs at run time. The compiler also generates header files that can be used in C programs to define the structures used in view descriptions, and optionally generates COPY files that can be used in COBOL programs to define the records used in the view descriptions. For more information about these view compilers, see <a href="../rfcm/rfcmd.html">viewc,&#160;vie</a><a href="../rfcm/rfcmd.html">wc32(1)</a> in <em class="cEmphasis">Oracle Tuxedo Command Reference</em>.</li>
<li><a name="wp1006416"> </a>A view disassembler is provided to translate object view descriptions into readable form (that is, back into source view descriptions). The output of the disassembler can be re-input to the view compiler.</li>
<li><a name="wp1006417"> </a>Data transfers from C structures or COBOL records to fielded buffers can be done in any one of four modes: <code class="cCode">FUPDATE</code>, <code class="cCode">FJOIN</code>, <code class="cCode">FOJOIN</code>, or <code class="cCode">FCONCAT</code>. These modes are similar to the ones supported by the following FML functions: <a href="../rf3fml/rf3fml.html">Fupdate,&#160;Fupda</a><a href="../rf3fml/rf3fml.html">te32(3fml)</a>, <a href="../rf3fml/rf3fml.html">Fjoin,&#160;Fjoin32</a><a href="../rf3fml/rf3fml.html">(3fml)</a>, <a href="../rf3fml/rf3fml.html">Fojoin,&#160;Fojoin32</a><a href="../rf3fml/rf3fml.html">(3fml)</a>, and <a href="../rf3fml/rf3fml.html">Fconcat,&#160;Fconcat32(3</a><a href="../rf3fml/rf3fml.html">fml)</a>.</li>
<li><a name="wp1006421"> </a>At run time object view descriptions are read into a viewfile cache on demand, and remain there until the cache is full. When the cache is full and an object view description that is not in the cache is needed, the least recently accessed object view description is removed from the cache to make room for the new one.</li>
<li><a name="wp1006425"> </a>All types supported by FML can be used in view descriptions with the exception of <code class="cCode">FLD_PTR</code> and <code class="cCode">FLD_FML32</code>. In addition, nested views are supported. For more information, see <span style="font-style: italic"><a href="../pgc/index.html">Using an VIEW Type Buffer</a></span><span style="font-style: normal"> in Programming an Oracle Tuxedo ATMI Application Using C</span>.</li>
<li><a name="wp1006426"> </a>When transferring data between fielded buffers and structures, the source data is automatically converted to the type of the destination data; for instance, if a string field is mapped to an integer member, the string is converted to an integer using <code class="cCode">Ftypcvt()</code> automatically. For more information, refer to <a href="../rf3fml/rf3fml.html">Ftypcvt,&#160;Ftypc</a><a href="../rf3fml/rf3fml.html">vt32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.</li>
<li><a name="wp1006427"> </a>Multiple field occurrences are supported.</li>
<li><a name="wp1006428"> </a>User-specified and default NULL values in view descriptions are supported.</li>
<li><a name="wp1006429"> </a>Functions are available for compiling and evaluating Boolean expressions against application data in a VIEW.</li>
</ul></div>
<p class="pBody"><a name="wp1006430"> </a>
A source viewfile is an ordinary text file that contains one or more source view descriptions. Source viewfiles are used as input to a view compiler&#8212;<code class="cCode">viewc</code> or <code class="cCode">viewc32</code>&#8212;which compiles the source view descriptions and stores them in object viewfiles. For more information on the view compiler, refer to <a href="../rfcm/rfcmd.html">viewc,&#160;viewc</a><a href="../rfcm/rfcmd.html">32(1)</a> in <em class="cEmphasis">Oracle Tuxedo Command Reference</em>.
</p>
<p class="pBody"><a name="wp1006431"> </a>
The view compiler also creates C header files for object viewfiles. These header files can be included in application programs to define the structures used in object view descriptions.
</p>
<p class="pBody"><a name="wp1006432"> </a>
The view compiler optionally creates COBOL COPY files for object viewfiles. These COPY files can be included in COPY programs to define the record formats used in object view descriptions.
</p>
<p class="pBody"><a name="wp1006433"> </a>
NULL values are used to indicate empty members in a structure, and can be specified by the user for each structure member in a viewfile. If the user does not specify a NULL value for a member, default NULL values are used.
</p>
<p class="pBody"><a name="wp1006434"> </a>
Note that a structure member containing the NULL value for that member is not transferred during a structure-to-fielded buffer transfer.
</p>
<p class="pBody"><a name="wp1010069"> </a>
It is also possible to inhibit the transfer of data between a C or COBOL structure member and a field in a fielded buffer, even though a mapping exists between them. This is specified in the source viewfile.
</p>
<p class="pBody"><a name="wp1010070"> </a>
The FML VIEWS functions are <code class="cCode">Fvstof()</code>, <code class="cCode">Fvftos()</code>, <code class="cCode">Fvnull()</code>, <code class="cCode">Fvopt()</code>, <code class="cCode">Fvselinit()</code>, and <code class="cCode">Fvsinit()</code>. For COBOL, the VIEWS facility provides two procedures: <code class="cCode">FVSTOF</code> and <code class="cCode">FVFTOS</code>. Upon calling any view function, the named object viewfile, if found, is loaded into the viewfile cache automatically. Each file specified in the environment variable <code class="cCode">VIEWFILES</code> is searched in order (see <a href="fml03.html">Setting Up Your Environment for FML and VIEWS</a>). The first object viewfile with the specified name is loaded. Subsequent object viewfiles with the same name, if any, are ignored. For more information on the FML VIEWS functions, refer to <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<p class="pBody"><a name="wp1006440"> </a>
Note that arrays of structures, pointers, unions, and typedefs are not supported in VIEWS.
</p>
<h3 class="pHeading2"><a name="wp1006441"> </a>
Multiple Occurrence Fields in VIEWS
</h3>
<p class="pBody"><a name="wp1006442"> </a>
Because VIEWS is concerned with moving fields between fielded buffers and C structures or COBOL records, it must deal with the possibility of multiple occurrence fields in the buffer.
</p>
<p class="pBody"><a name="wp1006443"> </a>
To store multiple occurrences of a field in a structure, a member is declared as an array in C or with the OCCURS clause in COBOL; each occurrence of a field occupies one element of the array. The size of the array reflects the maximum number of field occurrences in the buffer.
</p>
<p class="pBody"><a name="wp1006444"> </a>
When transferring data from fielded buffers to C structures or COBOL records, if the number of elements in the receiving array is greater than the number of occurrences in the fielded buffer, the extra elements are assigned the (default or user-specified) NULL value. If the number of occurrences in the buffer is greater than the number of elements in the array, the extra occurrences in the buffer are ignored.
</p>
<p class="pBody"><a name="wp1006445"> </a>
When data is transferred from C structures or COBOL records to fielded buffers, array members with the value equal to the (default or user-specified) NULL values are ignored.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1006447"> </a>
Error Handling for FML Functions
</h2><p class="pBody"><a name="wp1006451"> </a>
When an FML function detects an error, one of the following values is returned: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1006452"> </a>NULL is returned for functions that return a pointer.</li>
<li><a name="wp1006453"> </a><code class="cCode">BADFLDID</code> is returned for functions that return a <code class="cCode">FLDID</code>.</li>
<li><a name="wp1006454"> </a><code class="cCode">-1</code> is returned for all others.</li>
</ul></div>
<p class="pBody"><a name="wp1006458"> </a>
All FML function call returns should be checked against the appropriate value above to detect errors.
</p>
<p class="pBody"><a name="wp1006459"> </a>
In all error cases, the external integer <code class="cCode">Ferror</code> is set to the error number as defined in <code class="cCode">fml.h</code>. <code class="cCode">Ferror32</code> is set to the error number for FML32 as defined in <code class="cCode">fml32.h</code>.
</p>
<p class="pBody"><a name="wp1006460"> </a>
The <code class="cCode">F_error()</code> (or <code class="cCode">F_error32()</code>) function is provided to produce a message on the standard error output. It takes one parameter, a string. It prints the argument string, appended with a colon and a blank, and then prints an error message, followed by a newline character. The error message displayed is the one defined for the error number currently in <code class="cCode">Ferror</code>, which is set when errors occur.
</p>
<p class="pBody"><a name="wp1006461"> </a>
To be of most use, the argument string to the <code class="cCode">F_error()</code> (or <code class="cCode">F_error32()</code>) function should include the name of the program that incurred the error. Refer to <a href="../rf3fml/rf3fml.html">F_error,&#160;F_error</a><a href="../rf3fml/rf3fml.html">32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<p class="pBody"><a name="wp1007293"> </a>
<a href="../rf3fml/rf3fml.html">Fstrerror,&#160;Fstrer</a><a href="../rf3fml/rf3fml.html">ror32(3fml)</a> can be used to retrieve the text of an error message from a message catalog; it returns a pointer that can be used as an argument to <a href="../rf3c/rf3c.html">userlog(3c)</a>, or to <code class="cCode">F_error()</code> or <code class="cCode">F_error32()</code>.
</p>
<p class="pBody"><a name="wp1006466"> </a>
For a description of the error codes produced by an FML function, see the entry for that function in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
 
<br/>
    <table id="SummaryNotReq2" width="100%" border="0" cellpadding="0" cellspacing="0">
      <tr> 
        <td>
&nbsp;
<a href="fml02.html"><img id="LongDescNotReq12" src="/global_resources/images/backtop.gif" width="90" height="25" alt="Back to Top" title="Back to Top" border="0" /></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a accesskey="4" href="fml01.html"><img id="LongDescNotReq13" src="/global_resources/images/prevtop.gif" border="0" alt="Previous" /></a>&nbsp;
<a accesskey="5" href="fml03.html"><img id="LongDescNotReq14" src="/global_resources/images/nexttop.gif" border="0" alt="Next" /></a>
<script language="Javascript1.1" type="text/javascript">
Copyright();
</script>
<noscript><a href="http://edocs.bea.com/copyright.html">&copy; BEA Systems</a></noscript>
        </td>
      </tr>
    </table>

<!-- WebAnalytics BEGIN -->

<!--#include virtual="/global_resources/edocs_wt.html"-->
      
<!-- WebAnalytics END -->

  </body>
</html>
