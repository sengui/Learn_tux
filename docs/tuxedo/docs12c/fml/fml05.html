<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>

<!-- LOCALIZATION RELATED INFORMATION -->
<meta name="LOC_PROJ_ID" content="WLPF8.1" />
<meta name="LOC_OWNER" content="BEAJ" />
<meta name="LOC_STATUS" content="READY!" />
<meta name="LOC_COMMENT" content="LOC_COMMENT" />
<meta name="LOC_US_REV" content="1" />
<meta name="LOC_US_CHANGE" content="41824" />
<meta name="LOC_US_SRCFILE" content="//depot/tuxedo/tux12c/fml/fm/fml05.fm" />
<!-- LOCALIZATION RELATED INFORMATION -->

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="GENERATOR" content="Quadralay WebWorks AutoMap 2003 Platinum Edition for FrameMaker 8.6.6577.0" />
    <meta name="TEMPLATEBASE" content="BEA_WFP_Template_V1.04" />
    <meta name="LASTUPDATED" content="06/26/12 11:06:09" />
    <link rel="StyleSheet" href="/global_resources/edocs.css" type="text/css" media="all" />

<title>Field Manipulation Functions</title>

<!-- BEA scripts begin -->

<script language="Javascript" src="/global_resources/js/banner.js" type="text/javascript"></script>
<!-- This script outputs the banner required for edocs documentation. -->

<script language="Javascript" src="floatwin.js" type="text/javascript"></script>
<!-- This script opens a new small floating window and puts TOC<i>&lt;name&gt;</i>.html and IX<i>&lt;name&gt;</i>.html files in it and sets a generic popup window code to enable the display of some viewlets in the WebLogic Platform Tour. -->

<script language="Javascript1.1" src="/global_resources/js/footer.js" type="text/javascript"></script>
<!-- This script outputs the footer with the correct copyright date and link to copyright page.-->

<script language="Javascript1.1" src="/global_resources/js/googlesearch4.js" type="text/javascript"></script>
<!-- This script outputs the google search form. -->

<script language="Javascript1.1" src="/global_resources/js/note.js" type="text/javascript"></script>
<!-- This script outputs a note such as a BETA note. -->

<script language="JavaScript1.1" src="/global_resources/js/search.js" type="text/javascript"></script>
<!-- This script is not for online documents. It is only used by the QuestAgent Java Applet for CD search indexes. -->

<!-- BEA scripts end -->

  </head>

  <body>


<script language="Javascript1.1" type="text/javascript">
GoogleURL();
</script><noscript>This script outputs the google search URL required for search on edocs documentation.</noscript>

<script language="Javascript1.1" type="text/javascript">
Banner();
</script><noscript>This script outputs the banner required for edocs documentation.</noscript>

<script language="Javascript1.1" type="text/javascript">
GoogleSearchCollection();
</script><noscript>This script outputs the google search parameters required for search on edocs documentation.</noscript>

<!-- page title -->
<h1 class="booktitle">Programming an Oracle Tuxedo ATMI Application Using FML
</h1>
<!-- page title end -->

    <table id="SummaryNotReq1" width="100%" border="0" align="left" cellpadding="2%" cellspacing="0">
      <tr> 
        <td>
&nbsp;&nbsp;&nbsp;&nbsp;
<a accesskey="4" href="fml04.html"><img id="LongDescNotReq1" src="/global_resources/images/doc_nav_prev.gif" border="0" alt="Previous" /></a>&nbsp;
<a accesskey="5" href="fml06.html"><img id="LongDescNotReq2" src="/global_resources/images/doc_nav_next.gif" border="0" alt="Next" /></a>&nbsp;
<img id="LongDescNotReq3" src="/global_resources/images/doc_nav_dots.gif" border="0" alt="" />&nbsp;
<a accesskey="1" href="javascript:OpenWindowToc();" onmouseover="window.status='Table of Contents'; return true" onfocus="window.status='Table of Contents'; return true" onmouseout="window.status=''; return true" onblur="window.status=''; return true" title="Open TOC in new window">      <img id="LongDescNotReq4" src="/global_resources/images/doc_nav_contents.gif" alt="Open TOC in new window" border="0" /></a>&nbsp;
<a accesskey="2" href="javascript:OpenWindowIndex();" onmouseover="window.status='Index'; return true" onfocus="window.status='Index'; return true" onmouseout="window.status=''; return true" onblur="window.status=''; return true" title="Open Index in new window">     <img id="LongDescNotReq5" src="/global_resources//images/doc_nav_index.gif" border="0" alt="Open Index in new window" /></a>&nbsp;
<a href="../pdf/fml.pdf" target="pdf"><img id="LongDescNotReq6" src="/global_resources/images/doc_nav_pdf.gif" width="59" height="44" alt="View as PDF - New Window" title="View as PDF - New Window" border="0" /></a>&nbsp;
<a href="http://www.adobe.com/products/acrobat/alternate.html" target="_blank"><img id="LongDescNotReq7" src="/global_resources/images/get_reader.gif" width="52" height="44" alt="Get Adobe Reader - New Window" title="Get Adobe Reader - New Window" border="0" /></a>
<a name="link_group_0"></a>
	</td>
      </tr>
    </table>

<a name="skipnav" title="Content starts here"><img src="/global_resources/images/_.gif" alt="Content starts here" border="0" height="1" width="1" /></a>



<h1 class="pChapHead"><a name="wp1098474"> </a>
Field Manipulation Functions
</h1>
<p class="pBody"><a name="wp1067847"> </a>
This topic includes the following sections:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1056725"> </a><a href="fml05.html#wp1056742">About This Section</a></li>
<li><a name="wp1058569"> </a><a href="fml05.html#wp1056749">FML and VIEWS: 16-bit and 32-bit Interfaces</a></li>
<li><a name="wp1058570"> </a><a href="fml05.html#wp1056761">Definitions of the FML Function Parameters</a></li>
<li><a name="wp1058571"> </a><a href="fml05.html#wp1056779">Field Identifier Mapping Functions</a></li>
<li><a name="wp1056729"> </a><a href="fml05.html#wp1056863">Buffer Allocation and Initialization</a></li>
<li><a name="wp1056730"> </a><a href="fml05.html#wp1056955">Functions for Moving Fielded Buffers</a></li>
<li><a name="wp1056731"> </a><a href="fml05.html#wp1056985">Field Access and Modification Functions</a></li>
<li><a name="wp1056732"> </a><a href="fml05.html#wp1057216">Buffer Update Functions</a></li>
<li><a name="wp1056733"> </a><a href="fml05.html#wp1057268">VIEWS Functions</a></li>
<li><a name="wp1056734"> </a><a href="fml05.html#wp1060611">Conversion Functions</a></li>
<li><a name="wp1056735"> </a><a href="fml05.html#wp1057437">Converting Strings</a></li>
<li><a name="wp1092935"> </a><a href="fml05.html#wp1084302">Converting FLD_MBSTRING Fields</a></li>
<li><a name="wp1056736"> </a><a href="fml05.html#wp1099183">Indexing Functions</a></li>
<li><a name="wp1056737"> </a><a href="fml05.html#wp1057787">Input/Output Functions</a></li>
<li><a name="wp1056738"> </a><a href="fml05.html#wp1057852">Boolean Expressions of Fielded Buffers</a></li>
<li><a name="wp1056739"> </a><a href="fml05.html#wp1058111">Boolean Functions</a></li>
<li><a name="wp1056740"> </a><a href="fml05.html#wp1058155">VIEW Conversion to and from Target Format</a></li>
</ul></div>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1056742"> </a>
About This Section
</h2><p class="pBody"><a name="wp1056743"> </a>
This section describes all FML and VIEWS functions except the run-time mapping functions described in <a href="fml04.html">Defining and Using Fields</a>.
</p>
<p class="pBody"><a name="wp1056744"> </a>
FML functions are not directly available for COBOL programs. A procedure called <code class="cCode">FINIT</code> is available to initialize a record for receiving FML data, and the <code class="cCode">FVSTOF</code> and <code class="cCode">FVFTOS</code> procedures are available to convert a COBOL record into an FML buffer, and vice-versa. For detailed descriptions of these procedures, see <em class="cEmphasis">Programming an Oracle Tuxedo ATMI Application Using COBOL</em>. The COBOL interface is not described further here.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1056749"> </a>
FML and VIEWS: 16-bit and 32-bit Interfaces
</h2><p class="pBody"><a name="wp1056750"> </a>
There are two variants of FML. The original FML interface is based on 16-bit values for the length of fields and contains information identifying fields (hence FML16). FML16 is limited to 8191 unique fields, individual field lengths of up to 64K bytes, and a total fielded buffer size of 64K. The definitions, types, and function prototypes for this interface are in <code class="cCode">fml.h</code> which must be included in an application program using the FML16 interface; and functions live in <code class="cCode">-lfml</code>. 
</p>
<p class="pBody"><a name="wp1056751"> </a>
A second interface, FML32, uses 32-bit values for the field lengths and identifiers. It allows for about 30 million fields, and field and buffer lengths of about 2 billion bytes. The definitions, types, and function prototypes for FML32 are in <code class="cCode">fml32.h</code>; functions reside in <code class="cCode">-lfml32</code>. All definitions, types, and function names for FML32 have a &#8220;32&#8221; suffix (for example, <code class="cCode">MAXFBLEN32</code>, <code class="cCode">FBFR32</code>, <code class="cCode">FLDID32</code>, <code class="cCode">FLDLEN32</code>, <code class="cCode">F_OVHD32</code>, <code class="cCode">Fchg32</code>, and error code <code class="cCode">Ferror32</code>). Also the environment variables are suffixed with &#8220;32&#8221; (for example, <code class="cCode">FLDTBLDIR32</code>, <code class="cCode">FIELDTBLS32</code>, <code class="cCode">VIEWFILES32</code>, and <code class="cCode">VIEWDIR32</code>). For FML32, a fielded buffer pointer is of type &#8220;<code class="cCode">FBFR32 *</code>&#8221;, a field length has the type <code class="cCode">FLDLEN32</code>, and the number of occurrences of a field has the type <code class="cCode">FLDOCC32</code>. The default required alignment for FML32 buffers is 4-byte alignment.
</p>
<p class="pBody"><a name="wp1056752"> </a>
FML16 applications that are written correctly can easily be changed to use the FML32 interface. All variables used in the calls to the FML functions must use the proper typedefs (<code class="cCode">FLDID</code>, <code class="cCode">FLDLEN</code>, and <code class="cCode">FLDOCC</code>). Any call to <a href="../rf3c/rf3c.html">tpalloc(3c)</a> for an FML typed buffer should use the <code class="cCode">FMLTYPE</code> definition instead of &#8220;FML&#8221;. The application source code can be changed to use the 32-bit functions simply by changing the include of <code class="cCode">fml.h</code> to inclusion of <code class="cCode">fml32.h</code> followed by <code class="cCode">fml1632.h</code>. The <code class="cCode">fml1632.h</code> contains macros that convert all of the 16-bit type definitions to 32-bit type definitions, and 16-bit functions and macros to 32-bit functions and macros.
</p>
<p class="pBody"><a name="wp1056753"> </a>
Functions are also provided to convert an FML32 fielded buffer into an FML16 fielded buffer, and vice-versa:
</p>
<a name="wp1056754"> </a><div class="pPreformatted"><pre>#include &#8220;fml.h&#8221;<br />#include &#8220;fml32.h&#8221;<br />int<br />F32to16(FBFR *dest, FBFR32 *src)<br />int<br />F16to32(FBFR32 *dest, FBFR *src)</pre></div><p class="pBody"><a name="wp1056755"> </a>
<code class="cCode">F32to16</code> converts a 32-bit FML buffer to a 16-bit FML buffer. It does this by converting the buffer on a field-by-field basis and then creating the index for the fielded buffer. A field is converted by generating a FLDID from a FLDID32, and copying the field value (and field length for <code class="cCode">string</code> and <code class="cCode">carray</code> fields).
</p>
<p class="pBody"><a name="wp1056756"> </a>
<code class="cCodeEmphasis">dest</code> and <code class="cCodeEmphasis">src</code> are pointers to the destination and source fielded buffers, respectively. The source buffer is not changed. 
</p>
<p class="pBody"><a name="wp1077056"> </a>
These functions can fail for lack of space; they can be re-issued after enough additional space to complete the operation has been allocated. <code class="cCode">F16to32</code> converts a 16-bit FML buffer to a 32-bit FML buffer. It lives in the <code class="cCode">fml32</code> library or shared object and sets <code class="cCode">Ferror32</code> on error. <code class="cCode">F32to16</code> lives in the <code class="cCode">fml</code> library or shared object and sets <code class="cCode">Ferror</code> on error. Note that both <code class="cCode">fml.h</code> and <code class="cCode">fml32.h</code> must be included to use these functions; <code class="cCode">fml1632.h</code> may not be included in the same file.
</p>
<p class="pBody"><a name="wp1077057"> </a>
The field types for embedded buffers (<code class="cCode">FLD_PTR</code>, <code class="cCode">FLD_FML32</code>, and <code class="cCode">FLD_VIEW32</code>) are supported only for FML32. Buffers containing <code class="cCode">FLD_PTR</code>, <code class="cCode">FLD_FML32</code>, <code class="cCode">FLD_MBSTRING</code>, or <code class="cCode">FLD_VIEW32</code> fields cause <code class="cCode">F32to16</code> to fail with an <code class="cCode">FBADFLD</code> error. There is no impact when <code class="cCode">F16to32</code> is called for these functions.
</p>
<a name="wp1056759"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>For the remainder of this section, we describe only the 16-bit functions, without specifying the equivalent FML32 and VIEW32 functions.</td>
</tr>
</table>

<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1056761"> </a>
Definitions of the FML Function Parameters
</h2><p class="pBody"><a name="wp1056762"> </a>
To simplify the specification of parameters for FML functions, a convention has been adopted for the sequence of those parameters. FML parameters appear in the following sequence.
</p>
<div class="pSmartList1"><ol type="1" class="pSmartList1">
<li><a name="wp1056766"> </a>For functions that require a pointer to a fielded buffer (<code class="cCode">FBFR</code>), this parameter is first. If a function takes two-fielded buffer pointers (such as the transfer functions), the destination buffer comes first, followed by the source buffer. A fielded buffer pointer must point to an area that is aligned on a short boundary (or an error is returned with <code class="cCode">Ferror</code> set to <code class="cCode">FALIGNERR</code>) and the area must be a fielded buffer (or an error is returned with <code class="cCode">Ferror</code> set to <code class="cCode">FNOTFLD</code>).</li>
<li><a name="wp1056767"> </a>For I/O functions, a pointer to a stream follows the fielded buffer pointer.</li>
<li><a name="wp1056768"> </a>For functions that need one, a field identifier (type <code class="cCode">FLDID</code>) appears next (in the case of <code class="cCode">Fnext</code>, it is a pointer to a field identifier).</li>
<li><a name="wp1056769"> </a>For functions that need a field occurrence (type <code class="cCode">FLDOCC</code>), this parameter comes next. (For <code class="cCode">Fnext</code>, it is a pointer to an occurrence number.)</li>
<li><a name="wp1056770"> </a>In functions in which a field value is passed to or from the function, a pointer to the beginning of the field value is given next. (It is defined as a character pointer but may be cast from any other pointer type.)</li>
<li><a name="wp1056771"> </a>When a field value is passed to a function that contains a character array (<code class="cCode">carray</code>, <code class="cCode">mbstring</code>) field, you must specify its length as the next parameter (type <code class="cCode">FLDLEN</code>). For functions that retrieve a field value, a pointer to the length of the retrieval buffer must be passed to the function and this length parameter is set to the length of the value retrieved.</li>
<li><a name="wp1056772"> </a>A few functions require special parameters and differ from the preceding conventions. These special parameters appear after the above parameters. They are discussed in the descriptions of individual functions.</li>
<li><a name="wp1056773"> </a>The following NULL values are defined for the various field types: </li>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1056774"> </a><code class="cCode">0</code> for <code class="cCode">short</code> and <code class="cCode">long</code></li>
<li><a name="wp1056775"> </a><code class="cCode">0.0</code> for <code class="cCode">float</code> and <code class="cCode">double</code></li>
<li><a name="wp1056776"> </a><code class="cCode">\0</code> for <code class="cCode">string</code> (1 byte in length)</li>
<li><a name="wp1056777"> </a>A zero-length string for <code class="cCode">carray</code> or <code class="cCode">mbstring</code></li>
</ul></div>
</ol></div>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1056779"> </a>
Field Identifier Mapping Functions
</h2><p class="pBody"><a name="wp1056780"> </a>
Several functions allow a programmer to query field tables or field identifiers for information about fields during program execution.
</p>
<h3 class="pHeading2"><a name="wp1056781"> </a>
Fldid
</h3>
<p class="pBody"><a name="wp1056782"> </a>
<code class="cCode">Fldid</code> returns the field identifier for a given valid field name and loads the field name/field ID mapping tables from the field table files, if they do not already exist.
</p>
<a name="wp1056783"> </a><div class="pPreformatted"><pre>FLDID<br />Fldid(char *<code class="cCodeEmphasis">name</code>)</pre></div><p class="pBody"><a name="wp1056784"> </a>
Here <code class="cCodeEmphasis">name</code> is a valid field name.
</p>
<p class="pBody"><a name="wp1056785"> </a>
The space used by the mapping tables in memory can be freed using the <a href="../rf3fml/rf3fml.html">Fnmid_unload,&#160;Fnmid_unloa</a><a href="../rf3fml/rf3fml.html">d32(3fml)</a> function. Note that these tables are separate from the tables loaded and used by the <a href="fml05.html#wp1056786"><code class="cCode">Fname</code></a> function.
</p>
<p class="pBody"><a name="wp1060867"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fldid,&#160;Fldid</a><a href="../rf3fml/rf3fml.html">32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1056786"> </a>
Fname
</h3>
<p class="pBody"><a name="wp1056787"> </a>
<code class="cCode">Fname</code> returns the field name for a given valid field identifier and loads the field ID/name mapping tables from the field table files, if they do not already exist.
</p>
<a name="wp1056788"> </a><div class="pPreformatted"><pre>char *<br />Fname(FLDID <code class="cCodeEmphasis">fieldid</code>)</pre></div><p class="pBody"><a name="wp1056789"> </a>
Here <code class="cCodeEmphasis">fieldid</code> is a valid field identifier.
</p>
<p class="pBody"><a name="wp1056790"> </a>
The space used by the mapping tables in memory can be freed using the <a href="../rf3fml/rf3fml.html">Fnmid_unload,&#160;Fnmid_unl</a><a href="../rf3fml/rf3fml.html">oad32(3fml)</a> function. Note that these tables are separate from the tables loaded and used by the <code class="cCode">Fldid</code> function. (Refer to the <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em> for more information.)
</p>
<p class="pBody"><a name="wp1060985"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fname,&#160;Fname32</a><a href="../rf3fml/rf3fml.html">(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1056791"> </a>
Fldno
</h3>
<p class="pBody"><a name="wp1056792"> </a>
<code class="cCode">Fldno</code> extracts the field number from a given field identifier.
</p>
<a name="wp1056793"> </a><div class="pPreformatted"><pre>FLDOCC<br />Fldno(FLDID <code class="cCodeEmphasis">fieldid</code>)</pre></div><p class="pBody"><a name="wp1056794"> </a>
Here <code class="cCodeEmphasis">fieldid</code> is a valid field identifier.
</p>
<p class="pBody"><a name="wp1061032"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fldno,&#160;Fldn</a><a href="../rf3fml/rf3fml.html">o32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1056796"> </a>
Fldtype
</h3>
<p class="pBody"><a name="wp1056797"> </a>
<code class="cCode">Fldtype</code> extracts the field type (an integer, as defined in <code class="cCode">fml.h</code>) from a given field identifier.
</p>
<a name="wp1056798"> </a><div class="pPreformatted"><pre>int<br />Fldtype(FLDID <code class="cCodeEmphasis">fieldid</code>)</pre></div><p class="pBody"><a name="wp1056799"> </a>
Here <code class="cCodeEmphasis">fieldid</code> is a valid field identifier.
</p>
<p class="pBody"><a name="wp1056800"> </a>
The following table shows the possible values returned by <code class="cCode">Fldtype</code> and their meanings.
</p>
<p class="pGraphic"><a name="wp1056850"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1059282table1056801"><caption><a name="wp1059282"> </a>
Table 5-1  Field Types Returned by Fldtype &#160;

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1056807"> </a>
Return Value
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1056809"> </a>
Meaning
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1078161"> </a>
Field Type Name in fml.h/ fml32.h
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056811"> </a>
0
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056813"> </a>
Short integer
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1078163"> </a>
<code class="cCode">FLD_SHORT</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056815"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056817"> </a>
Long integer
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1078165"> </a>
<code class="cCode">FLD_LONG</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056819"> </a>
2
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056821"> </a>
Character
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1078167"> </a>
<code class="cCode">FLD_CHAR</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056823"> </a>
3
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056825"> </a>
Single-precision float
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1078169"> </a>
<code class="cCode">FLD_FLOAT</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056827"> </a>
4
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056829"> </a>
Double-precision float
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1078171"> </a>
<code class="cCode">FLD_DOUBLE</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056831"> </a>
5
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056833"> </a>
Null-terminated string
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1078173"> </a>
<code class="cCode">FLD_STRING</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056835"> </a>
6
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056837"> </a>
Character array
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1078175"> </a>
<code class="cCode">FLD_CARRAY</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056839"> </a>
9
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056841"> </a>
Pointer
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1078177"> </a>
<code class="cCode">FLD_PTR</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056843"> </a>
10
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056845"> </a>
Embedded FML32 buffer
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1078179"> </a>
<code class="cCode">FLD_FML32</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1075291"> </a>
11
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1075293"> </a>
Embedded VIEW32 buffer
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1078181"> </a>
<code class="cCode">FLD_VIEW32</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056847"> </a>
12
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1056849"> </a>
Multibyte character array
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1078183"> </a>
<code class="cCode">FLD_MBSTRING</code>
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<p class="pBody"><a name="wp1061054"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fldtype,&#160;Fldtype32(</a><a href="../rf3fml/rf3fml.html">3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1056851"> </a>
Ftype
</h3>
<p class="pBody"><a name="wp1056852"> </a>
<code class="cCode">Ftype</code> returns a pointer to a string containing the name of the type of a field given a field identifier.
</p>
<a name="wp1056853"> </a><div class="pPreformatted"><pre>char *<br />Ftype(FLDID <code class="cCodeEmphasis">fieldid</code>)</pre></div><p class="pBody"><a name="wp1056854"> </a>
Here <code class="cCodeEmphasis">fieldid</code> is a valid field identifier. For example, the following code returns a pointer to one of the following strings: <code class="cCode">short</code>, <code class="cCode">long</code>, <code class="cCode">char</code>, <code class="cCode">float</code>, <code class="cCode">double</code>, <code class="cCode">string</code>, <code class="cCode">carray</code>, <code class="cCode">mbstring</code>, <code class="cCode">FLD_PTR</code>, <code class="cCode">FLD_FML32</code>, or <code class="cCode">FLD_VIEW32</code>.
</p>
<a name="wp1056855"> </a><div class="pPreformatted"><pre>char *typename<br />. . .<br />typename = Ftype(fieldid);</pre></div><p class="pBody"><a name="wp1061240"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Ftype,&#160;Ftyp</a><a href="../rf3fml/rf3fml.html">e32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1056856"> </a>
Fmkfldid
</h3>
<p class="pBody"><a name="wp1056857"> </a>
As part of an application generator, or to reconstruct a field identifier, it might be useful to make a field identifier from a type specification and an available field number. <code class="cCode">Fmkfldid</code> provides this functionality.
</p>
<a name="wp1056858"> </a><div class="pPreformatted"><pre>FLDID<br />Fmkfldid(int <code class="cCodeEmphasis">type</code>, FLDID <code class="cCodeEmphasis">num</code>)</pre></div><p class="pBody"><a name="wp1056859"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1056860"> </a><code class="cCodeEmphasis">type</code> is a valid type. (Specifically, it is an integer; see <a href="fml05.html#wp1056796">Fldtype</a> for details.)</li>
<li><a name="wp1056861"> </a><code class="cCodeEmphasis">num</code> is a field number. (It should be an unused field number to avoid confusion with existing fields.)</li>
</ul></div>
<p class="pBody"><a name="wp1061258"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fmkfldid,&#160;Fmkfld</a><a href="../rf3fml/rf3fml.html">id32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1056863"> </a>
Buffer Allocation and Initialization
</h2><p class="pBody"><a name="wp1061296"> </a>
The functions described in this section are provided for writing stand-alone FML programs. If you are using the Oracle Tuxedo ATMI functions, keep in mind that for tasks such as allocating and freeing message buffers, you must call ATMI functions such as <a href="../rf3c/rf3c.html">tpalloc(3c)</a>, <a href="../rf3c/rf3c.html">tprealloc(3c)</a>, and <a href="../rf3c/rf3c.html">tpfree(3c)</a>, instead of FML functions such as <a href="../rf3fml/rf3fml.html">Falloc,&#160;Falloc</a><a href="../rf3fml/rf3fml.html">32(3fml)</a>, <a href="../rf3fml/rf3fml.html">Frealloc,&#160;Frealloc32(</a><a href="../rf3fml/rf3fml.html">3fml)</a>, and <a href="../rf3fml/rf3fml.html">Ffree,&#160;Ffre</a><a href="../rf3fml/rf3fml.html">e32(3fml)</a>.
</p>
<p class="pBody"><a name="wp1061315"> </a>
Most FML functions require a pointer to a fielded buffer as an argument. The <code class="cCode">typedef</code> <code class="cCode">FBFR</code> is available for declaring such pointers, as shown in the following example:
</p>
<a name="wp1056869"> </a><div class="pPreformatted"><pre>FBFR *<code class="cCodeEmphasis">fbfr</code>;</pre></div><p class="pBody"><a name="wp1056870"> </a>
In this section, the variable <code class="cCodeEmphasis">fbfr</code> refers to a pointer to a fielded buffer. Never attempt to declare fielded buffers themselves; declare only pointers to fielded buffers.
</p>
<p class="pBody"><a name="wp1056871"> </a>
When a server receives a request that contains an FML buffer, it allocates space for that FML buffer and for any embedded views or buffers referenced by <code class="cCode">FLD_PTR</code> fields. A pointer to the new FML buffer is passed to the user-written code. Once the server processing is complete, all buffers allocated when the message was received must be destroyed. The Oracle Tuxedo system checks the FML buffer and all subsidiary buffers, and deletes any buffers to which it finds references. As a programmer writing server code, you should be aware of the following situations:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1061385"> </a>If you add, change, or update a view or pointer field so that it references a buffer allocated by the server, the newly allocated buffer is deleted during the cleanup triggered when the <a href="../rf3c/rf3c.html">tpreturn(3c)</a> or <a href="../rf3c/rf3c.html">tpforward(3c)</a> function is called.</li>
<li><a name="wp1061389"> </a>If you change, update, or delete a field so that a buffer is no longer referenced by the FML buffer, the user-written code must free that buffer explicitly, using the <a href="../rf3c/rf3c.html">tpfree(3c)</a> function. If the buffer is not explicitly freed, the server process leaks memory.</li>
<li><a name="wp1056874"> </a>In some cases, the user-written code can allocate and return another buffer, rather than simply call <a href="../rf3c/rf3c.html">tpreturn(3c)</a>. If this is done, the FML buffer passed to <code class="cCode">tpreturn()</code> is freed, but any buffers referenced by <code class="cCode">FLD_PTR</code> or <code class="cCode">FLD_VIEW32</code> fields are not freed.</li>
</ul></div>
<p class="pBody"><a name="wp1056875"> </a>
The functions used to reserve space for fielded buffers are explained in the following text, but first we describe a function that can be used to determine whether a given buffer is, in fact, a fielded buffer.
</p>
<h3 class="pHeading2"><a name="wp1056876"> </a>
Fielded
</h3>
<p class="pBody"><a name="wp1056877"> </a>
<code class="cCode">Fielded</code> (or <code class="cCode">Fielded32</code>) is used to test whether the specified buffer is fielded. 
</p>
<a name="wp1056878"> </a><div class="pPreformatted"><pre>int<br />Fielded(FBFR *<code class="cCodeEmphasis">fbfr</code>)</pre></div><p class="pBody"><a name="wp1056879"> </a>
<code class="cCode">Fielded32</code> is used with 32-bit FML.
</p>
<p class="pBody"><a name="wp1056880"> </a>
<code class="cCode">Fielded</code> returns true (<code class="cCode">1</code>) if the buffer is fielded. It returns false (<code class="cCode">0</code>) if the buffer is not fielded but does not set <code class="cCode">Ferror</code>.
</p>
<p class="pBody"><a name="wp1061448"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fielded,&#160;Fiel</a><a href="../rf3fml/rf3fml.html">ded32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1056881"> </a>
Fneeded
</h3>
<p class="pBody"><a name="wp1056882"> </a>
The amount of memory to allocate for a fielded buffer depends on the maximum number of fields the buffer will contain and the total amount of space needed for all the field values. The function <code class="cCode">Fneeded</code> can be used to determine the amount of space (in bytes) needed for a fielded buffer; it takes the number of fields and the space needed for all field values (in bytes) as arguments. 
</p>
<a name="wp1056883"> </a><div class="pPreformatted"><pre>long<br />Fneeded(FLDOCC <code class="cCodeEmphasis">F</code>, FLDLEN <code class="cCodeEmphasis">V</code>)</pre></div><p class="pBody"><a name="wp1056884"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1056885"> </a><code class="cCodeEmphasis">F</code> is the number of fields.</li>
<li><a name="wp1056886"> </a><code class="cCodeEmphasis">V</code> is the space, in bytes, for field values.</li>
</ul></div>
<p class="pBody"><a name="wp1056887"> </a>
The space needed for field values is computed by estimating the amount of space that is required by each field value if stored in standard structures (for example, a <code class="cCode">long</code> is stored as a <code class="cCode">long</code> and needs four bytes). For variable length fields, estimate the average amount of space needed for the field. The space calculated by <code class="cCode">Fneeded</code> includes a fixed overhead for each field; it adds that to the space needed for the field values.
</p>
<p class="pBody"><a name="wp1056888"> </a>
Once you obtain the estimate of space from <code class="cCode">Fneeded</code>, you can allocate the desired number of bytes using <code class="cCode">malloc</code>(3) and set up a pointer to the allocated memory space. For example, the following code allocates space for a fielded buffer large enough to contain 25 fields and 300 bytes of values.
</p>
<a name="wp1056889"> </a><div class="pPreformatted"><pre>#define NF 25<br />#define NV 300<br />extern char *malloc;<br />. . .<br />  if((fbfr = (FBFR *)malloc(Fneeded(NF, NV))) == NULL)<br />      F_error(&quot;pgm_name&quot;);   /* no space to allocate buffer */</pre></div><p class="pBody"><a name="wp1056890"> </a>
However, this allocated memory space is not yet a fielded buffer. <code class="cCode">Finit</code> must be used to initialize it.
</p>
<p class="pBody"><a name="wp1061466"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fneeded,&#160;Fneed</a><a href="../rf3fml/rf3fml.html">ed32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1060570"> </a>
Fvneeded
</h3>
<p class="pBody"><a name="wp1060571"> </a>
The <code class="cCode">Fvneeded</code> function determines the amount of space (in bytes) needed for a <code class="cCode">VIEW</code> buffer. The function takes a pointer to the name of the <code class="cCode">VIEW</code> as an argument. 
</p>
<a name="wp1060572"> </a><div class="pPreformatted"><pre>long<br />Fvneeded(char *<code class="cCodeEmphasis">subtype</code>)</pre></div><p class="pBody"><a name="wp1060573"> </a>
The <code class="cCode">Fvneeded</code> function returns the size of the <code class="cCode">VIEW</code> in number of bytes.
</p>
<p class="pBody"><a name="wp1061497"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fvneeded,&#160;Fvneede</a><a href="../rf3fml/rf3fml.html">d32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1056891"> </a>
Finit
</h3>
<p class="pBody"><a name="wp1056892"> </a>
The <code class="cCode">Finit</code> function initializes an allocated memory space as a fielded buffer. 
</p>
<a name="wp1056893"> </a><div class="pPreformatted"><pre>int<br />Finit(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDLEN <code class="cCodeEmphasis">buflen</code>)</pre></div><p class="pBody"><a name="wp1056894"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1056895"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to an uninitialized fielded buffer.</li>
<li><a name="wp1056896"> </a><code class="cCodeEmphasis">buflen</code> is the length of the buffer, in bytes.</li>
</ul></div>
<p class="pBody"><a name="wp1056897"> </a>
A call to <code class="cCode">Finit</code> to initialize the memory space allocated in the previous example looks like the following code:
</p>
<a name="wp1056898"> </a><div class="pPreformatted"><pre>Finit(fbfr, Fneeded(NF, NV));</pre></div><p class="pBody"><a name="wp1056899"> </a>
Now <code class="cCode">fbfr</code> points to an initialized, empty fielded buffer. Up to <a href="fml05.html#wp1056881"><code class="cCode">Fneeded</code></a><code class="cCode">(NF, NV)</code> bytes minus a small amount (<code class="cCode">F_OVHD</code> as defined in <code class="cCode">fml.h</code>) are available in the buffer to hold fields.
</p>
<a name="wp1056900"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The numbers used in the <code class="cCode">malloc</code>(3) call (as described in the previous section) and <code class="cCode">Finit</code> call must be the same.</td>
</tr>
</table>

<p class="pBody"><a name="wp1061533"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Finit,&#160;Finit</a><a href="../rf3fml/rf3fml.html">32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1056901"> </a>
Falloc
</h3>
<p class="pBody"><a name="wp1056902"> </a>
Calls to <a href="fml05.html#wp1056881"><code class="cCode">Fneeded</code></a>, <code class="cCode">malloc</code>(3) and <a href="fml05.html#wp1056891"><code class="cCode">Finit</code></a> may be replaced by a single call to <code class="cCode">Falloc</code>, which allocates the desired amount of space and initializes the buffer. 
</p>
<a name="wp1056903"> </a><div class="pPreformatted"><pre><code class="cCode">FBFR *<br />Falloc(FLDOCC </code><code class="cCodeEmphasis">F</code><code class="cCode">, FLDLEN </code><code class="cCodeEmphasis">V</code><code class="cCode">)</code></pre></div><p class="pBody"><a name="wp1056904"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1056905"> </a><code class="cCodeEmphasis">F</code> is the number of fields.</li>
<li><a name="wp1056906"> </a><code class="cCodeEmphasis">V</code> is the space for field values, in bytes.</li>
</ul></div>
<p class="pBody"><a name="wp1056907"> </a>
A call to <code class="cCode">Falloc</code> that provides the same functionality created by the calls to <code class="cCode">Fneeded</code>, <code class="cCode">malloc()</code>, and <a href="fml05.html#wp1056891"><code class="cCode">Finit</code></a> described in the previous three sections, must be written as follows:
</p>
<a name="wp1056908"> </a><div class="pPreformatted"><pre>extern FBFR *Falloc;<br />. . .<br /> if((fbfr = Falloc(NF, NV)) == NULL)<br />      F_error(&#8220;pgm_name&#8221;);   /* couldn&#39;t allocate buffer */</pre></div><p class="pBody"><a name="wp1100051"> </a>
Storage allocated with <code class="cCode">Falloc</code> (or <a href="fml05.html#wp1056881"><code class="cCode">Fneeded</code></a>, <code class="cCode">malloc</code>(3), and <a href="fml05.html#wp1056891"><code class="cCode">Finit</code></a>) should be freed with <a href="fml05.html#wp1056910"><code class="cCode">Ffree</code></a>. (See <a href="../rf3fml/rf3fml.html">Ffree,&#160;Ffree32</a><a href="../rf3fml/rf3fml.html">(3fml)</a> in the <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.)
</p>
<p class="pBody"><a name="wp1100061"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Falloc,&#160;Falloc</a><a href="../rf3fml/rf3fml.html">32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1056910"> </a>
Ffree
</h3>
<p class="pBody"><a name="wp1056911"> </a>
<code class="cCode">Ffree</code> is used to free memory space allocated as a fielded buffer. <code class="cCode">Ffree32</code> does not free the memory area referenced by a pointer in a <code class="cCode">FLD_PTR</code> field.
</p>
<a name="wp1056912"> </a><div class="pPreformatted"><pre>int<br />Ffree(FBFR *<code class="cCodeEmphasis">fbfr</code>)</pre></div><p class="pBody"><a name="wp1056913"> </a>
Here <code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer. Consider the following example:
</p>
<a name="wp1056914"> </a><div class="pPreformatted"><pre>#include  &lt;fml.h&gt;<br />. . .<br />if(Ffree(fbfr) &lt; 0)<br />      F_error(&quot;pgm_name&quot;);     /* not fielded buffer */</pre></div><p class="pBody"><a name="wp1056915"> </a>
<code class="cCode">Ffree</code> is preferable to <code class="cCode">free</code>(3), because <code class="cCode">Ffree</code> invalidates a fielded buffer, whereas <code class="cCode">free</code>(3) does not. It is necessary to invalidate fielded buffers because <code class="cCode">malloc</code>(3) re-uses memory that has been freed without clearing it. Thus, if <code class="cCode">free</code>(3) is used, <code class="cCode">malloc</code> can return a piece of memory that looks like a valid fielded buffer, but is not.
</p>
<p class="pBody"><a name="wp1056916"> </a>
Space for a fielded buffer may also be reserved directly. The buffer must begin on a <code class="cCode">short</code> boundary. You must allocate at least <code class="cCode">F_OVHD</code> bytes (defined in <code class="cCode">fml.h</code>) for the buffer; if you do not, <a href="fml05.html#wp1056891"><code class="cCode">Finit</code></a> returns an error.
</p>
<p class="pBody"><a name="wp1056917"> </a>
The following code is analogous to the preceding example but <code class="cCode">Fneeded</code> cannot be used to size the static buffer because it is not a macro:
</p>
<a name="wp1056918"> </a><div class="pPreformatted"><pre>/* the first line aligns the buffer */<br />static short buffer[500/sizeof(short)];<br />FBFR *fbfr=(FBFR *)buffer;<br />. . .<br />Finit(fbfr, 500);</pre></div><p class="pBody"><a name="wp1056919"> </a>
Be careful <em class="cEmphasis">not</em> to enter code such as the following:
</p>
<a name="wp1056920"> </a><div class="pPreformatted"><pre>FBFR badfbfr;<br />. . .<br />Finit(&amp;badfbfr, Fneeded(NF, NV));</pre></div><p class="pBody"><a name="wp1056921"> </a>
This code is wrong: the structure for <code class="cCode">FBFR</code> is not defined in the user header files. As a result, a compilation error will be produced.
</p>
<p class="pBody"><a name="wp1061577"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Ffree,&#160;Ffree</a><a href="../rf3fml/rf3fml.html">32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1056922"> </a>
Fsizeof
</h3>
<p class="pBody"><a name="wp1056923"> </a>
<code class="cCode">Fsizeof</code> returns the size of a fielded buffer in bytes.
</p>
<a name="wp1056924"> </a><div class="pPreformatted"><pre>long<br />Fsizeof(FBFR *<code class="cCodeEmphasis">fbfr</code>)</pre></div><p class="pBody"><a name="wp1056925"> </a>
Here <code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer. In the following code, for example, <code class="cCode">Fsizeof</code> returns the same number that <a href="fml05.html#wp1056881"><code class="cCode">Fneeded</code></a> returned when the fielded buffer was originally allocated:
</p>
<a name="wp1056926"> </a><div class="pPreformatted"><pre>long bytes;<br />. . .<br />bytes = Fsizeof(fbfr);</pre></div><p class="pBody"><a name="wp1061668"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fsizeof,&#160;Fsiz</a><a href="../rf3fml/rf3fml.html">eof32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1056927"> </a>
Funused
</h3>
<p class="pBody"><a name="wp1056928"> </a>
<code class="cCode">Funused</code> may be used to determine how much space is available in a fielded buffer for additional data.
</p>
<a name="wp1056929"> </a><div class="pPreformatted"><pre>long<br />Funused(FBFR *<code class="cCodeEmphasis">fbfr</code>)</pre></div><p class="pBody"><a name="wp1056930"> </a>
Here <code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer. Consider the following example:
</p>
<a name="wp1056931"> </a><div class="pPreformatted"><pre>long unused;<br />. . .<br />unused = Funused(fbfr);</pre></div><p class="pBody"><a name="wp1056932"> </a>
Note that <code class="cCode">Funused</code> does not indicate the <em class="cEmphasis">location</em>, in the buffer, of the unused bytes;  only the <em class="cEmphasis">number</em> of unused bytes is specified.
</p>
<p class="pBody"><a name="wp1061686"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Funused,&#160;Fun</a><a href="../rf3fml/rf3fml.html">used32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1056933"> </a>
Fused
</h3>
<p class="pBody"><a name="wp1056934"> </a>
<code class="cCode">Fused</code> may be used to determine how much space is used in a fielded buffer for data and overhead.
</p>
<a name="wp1056935"> </a><div class="pPreformatted"><pre>long<br />Fused(FBFR *<code class="cCodeEmphasis">fbfr</code>)</pre></div><p class="pBody"><a name="wp1056936"> </a>
Here <code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer. Consider the following example:
</p>
<a name="wp1056937"> </a><div class="pPreformatted"><pre>long used;<br />. . .<br />used = Fused(fbfr);</pre></div><p class="pBody"><a name="wp1056938"> </a>
Note that <code class="cCode">Fused</code> does not indicate the <em class="cEmphasis">location</em>, in the buffer, of the used bytes; only the <em class="cEmphasis">number</em> of used bytes is specified.
</p>
<p class="pBody"><a name="wp1061703"> </a>
For more information, refer to Fused,&#160;Fused32(3fml) in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1056939"> </a>
Frealloc
</h3>
<p class="pBody"><a name="wp1056940"> </a>
This function enables you to change the size of a buffer for which you have allocated space by calling <a href="fml05.html#wp1056901"><code class="cCode">Falloc</code></a>. 
</p>
<p class="pBody"><a name="wp1061746"> </a>
If you have allocated space with <a href="../rf3c/rf3c.html">tpalloc(3c)</a>, you must call <a href="../rf3c/rf3c.html">tprealloc(3c)</a> to reallocate that space. Being able to resize the buffer can be useful if, for example, a buffer runs out of space while a new field value is being added. Simply by calling <code class="cCode">Frealloc</code> you can increase the size of the buffer. In other situations you may want to call <code class="cCode">Frealloc</code> to decrease the size of the buffer.
</p>
<a name="wp1056941"> </a><div class="pPreformatted"><pre>FBFR *<br />Frealloc(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDOCC <code class="cCodeEmphasis">nf</code>, FLDLEN <code class="cCodeEmphasis">nv</code>)</pre></div><p class="pBody"><a name="wp1056942"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1056943"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1056944"> </a><code class="cCodeEmphasis">nf</code> is the new number of fields or 0.</li>
<li><a name="wp1056945"> </a><code class="cCodeEmphasis">nv</code> is the new space for field values, in bytes.</li>
</ul></div>
<p class="pBody"><a name="wp1056946"> </a>
Consider the following example:
</p>
<a name="wp1056947"> </a><div class="pPreformatted"><pre>FBFR *newfbfr;<br />. . .<br />if((newfbfr = Frealloc(fbfr, NF+5, NV+300)) == NULL)<br />        F_error(&#8220;pgm_name&#8221;);      /* couldn&#39;t re-allocate space */<br />else<br />        fbfr = newfbfr;          /* assign new pointer to old */</pre></div><p class="pBody"><a name="wp1056948"> </a>
In this case, the application needed to remember the number of fields and the number of value space bytes previously allocated. Note that the arguments to <code class="cCode">Frealloc</code> (as with its counterpart <code class="cCode">realloc</code>(3)) are absolute values, not increments. This example does not work if it is necessary to re-allocate space several times.
</p>
<p class="pBody"><a name="wp1056949"> </a>
The following example shows a second way of incrementing the allocated space:
</p>
<a name="wp1056950"> </a><div class="pPreformatted"><pre>/* define the increment size when buffer out of space */<br />#define INCR    400<br />FBFR *newfbfr;<br />. . .<br />if((newfbfr = Frealloc(fbfr, 0, Fsizeof(fbfr)+INCR)) == NULL)<br />      F_error(&#8220;pgm_name&#8221;);       /* couldn&#39;t re-allocate space */<br />else<br />      fbfr = newfbfr;           /* assign new pointer to old */</pre></div><p class="pBody"><a name="wp1056951"> </a>
You do not need to know the number of fields or the value space size with which the buffer was last initialized. Thus, the easiest way to increase the size is to use the current size plus the increment as the value space. The previous example can be executed as many times as needed without remembering past executions or values. You do not need to call <a href="fml05.html#wp1056891"><code class="cCode">Finit</code></a> after calling <code class="cCode">Frealloc</code>. 
</p>
<p class="pBody"><a name="wp1056952"> </a>
If the amount of additional space requested in the call to <code class="cCode">Frealloc</code> is contiguous to the old buffer, <code class="cCode">newfbfr</code> and <code class="cCode">fbfr</code> in the previous examples are the same. However, defensive programming dictates that you should declare <code class="cCode">newfbfr</code> as a safeguard in case either a new value or NULL is returned. If <code class="cCode">Frealloc</code> fails, do not use <code class="cCode">fbfr</code> again.
</p>
<a name="wp1056953"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The buffer size can be decreased only to the number of bytes currently being used in the buffer.</td>
</tr>
</table>

<p class="pBody"><a name="wp1062074"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Frealloc,&#160;Freall</a><a href="../rf3fml/rf3fml.html">oc32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1056955"> </a>
Functions for Moving Fielded Buffers
</h2><p class="pBody"><a name="wp1056956"> </a>
The only restriction on the location of fielded buffers is that they must be aligned on a <code class="cCode">short</code> boundary. Otherwise, fielded buffers are position-independent and may be moved around freely in memory.
</p>
<h3 class="pHeading2"><a name="wp1056957"> </a>
Fmove
</h3>
<p class="pBody"><a name="wp1056958"> </a>
If <code class="cCodeEmphasis">src</code> points to a fielded buffer and <code class="cCodeEmphasis">dest</code> points to an area of storage big enough to hold it, then the following code might be used to move the fielded buffer:
</p>
<a name="wp1056959"> </a><div class="pPreformatted"><pre>FBFR *<code class="cCodeEmphasis">src</code>;<br />char *<code class="cCodeEmphasis">dest</code>;<br />. . .<br />memcpy(dest, src, Fsizeof(src));</pre></div><p class="pBody"><a name="wp1056960"> </a>
The function <code class="cCode">memcpy</code>, one of the C run-time memory management functions, moves the number of bytes indicated by its third argument from the area pointed to by its second argument to the area pointed to by its first argument.
</p>
<p class="pBody"><a name="wp1056961"> </a>
While <code class="cCode">memcpy</code> may be used to copy a fielded buffer, the destination copy of the buffer looks just like the source copy. In particular, for example, the destination copy has the same number of unused bytes as the source buffer.
</p>
<p class="pBody"><a name="wp1056962"> </a>
<code class="cCode">Fmove</code> acts like <code class="cCode">memcpy</code>, but does not need an explicit length (which is computed).
</p>
<a name="wp1056963"> </a><div class="pPreformatted"><pre>int<br />Fmove(char *<code class="cCodeEmphasis">dest</code>, FBFR *<code class="cCodeEmphasis">src</code>)</pre></div><p class="pBody"><a name="wp1056964"> </a>
Here:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1056965"> </a><code class="cCodeEmphasis">dest</code> is a pointer to the destination buffer.</li>
<li><a name="wp1056966"> </a><code class="cCodeEmphasis">src</code> is a pointer to the source fielded buffer.</li>
</ul></div>
<p class="pBody"><a name="wp1056967"> </a>
In the following code, for example, <code class="cCode">Fmove</code> checks that the source buffer is indeed a fielded buffer, but does not modify the source buffer in any way.
</p>
<a name="wp1056968"> </a><div class="pPreformatted"><pre>FBFR *src;<br />char *dest;<br />. . .<br />if(Fmove(dest,src) &lt; 0) <br />	  F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1056969"> </a>
The destination buffer need not be a fielded buffer (that is, it need not have been allocated using <a href="fml05.html#wp1056901"><code class="cCode">Falloc</code></a>), but it must be aligned on a <code class="cCode">short</code> boundary (4-byte alignment for FML32). Thus, <a href="fml05.html#wp1056957"><code class="cCode">Fmove</code></a> provides an alternative to <a href="fml05.html#wp1056972"><code class="cCode">Fcpy</code></a> when you want to copy a fielded buffer to a non-fielded buffer. <code class="cCode">Fmove</code> does not, however, check to make sure there is enough room in the destination buffer to receive the source buffer.
</p>
<p class="pBody"><a name="wp1056970"> </a>
For values of type <code class="cCode">FLD_PTR</code>, <code class="cCode">Fmove32</code> transfers the buffer pointer. The application programmer must manage the reallocation and freeing of buffers when the associated pointer is moved. The buffer pointed to by a <code class="cCode">FLD_PTR</code> field must be allocated using the <a href="../rf3c/rf3c.html">tpalloc(3c)</a> call.
</p>
<p class="pBody"><a name="wp1062236"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fmove,&#160;Fmove32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1056972"> </a>
Fcpy
</h3>
<p class="pBody"><a name="wp1056973"> </a>
<code class="cCode">Fcpy</code> is used to overwrite one fielded buffer with another.
</p>
<a name="wp1056974"> </a><div class="pPreformatted"><pre>int<br />Fcpy(FBFR *<code class="cCodeEmphasis">dest</code>, FBFR *<code class="cCodeEmphasis">src</code>)</pre></div><p class="pBody"><a name="wp1056975"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1056976"> </a><code class="cCodeEmphasis">dest</code> is a pointer to the destination fielded buffer.</li>
<li><a name="wp1056977"> </a><code class="cCodeEmphasis">src</code> is a pointer to the source fielded buffer.</li>
</ul></div>
<p class="pBody"><a name="wp1056978"> </a>
<code class="cCode">Fcpy</code> preserves the overall buffer length of the overwritten fielded buffer and therefore is useful for expanding or reducing the size of a fielded buffer. Consider the following example:
</p>
<a name="wp1064293"> </a><div class="pPreformatted"><pre>FBFR *src, *dest;<br />. . .<br />if(Fcpy(dest, src) &lt; 0)<br />        F_error(&#8220;pgm_name&#8221;);</pre></div><p class="pBody"><a name="wp1064294"> </a>
Unlike <a href="fml05.html#wp1056957"><code class="cCode">Fmove</code></a>, where <code class="cCodeEmphasis">dest</code> could point to an uninitialized area, <code class="cCode">Fcpy</code> expects <code class="cCodeEmphasis">dest</code> to point to an initialized fielded buffer (allocated using <a href="fml05.html#wp1056901"><code class="cCode">Falloc</code></a>). <code class="cCode">Fcpy</code> also verifies that <code class="cCodeEmphasis">dest</code> is big enough to accommodate the data from the source buffer.
</p>
<a name="wp1056981"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>You cannot reduce the size of a fielded buffer below the amount of space needed for currently held data.</td>
</tr>
</table>

<p class="pBody"><a name="wp1056982"> </a>
As with <a href="fml05.html#wp1056957"><code class="cCode">Fmove</code></a>, the source buffer is not modified by <code class="cCode">Fcpy</code>.
</p>
<p class="pBody"><a name="wp1056983"> </a>
For values of type <code class="cCode">FLD_PTR</code>, <code class="cCode">Fcpy32</code> copies the buffer pointer. The application programmer must manage the reallocation and freeing of buffers when the associated pointer is copied. The buffer pointed to by a <code class="cCode">FLD_PTR</code> field must be allocated using the <a href="../rf3c/rf3c.html">tpalloc(3c)</a> call.
</p>
<p class="pBody"><a name="wp1062279"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fcpy,&#160;Fcpy32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1056985"> </a>
Field Access and Modification Functions
</h2><p class="pBody"><a name="wp1056986"> </a>
This section discusses how to update and access fielded buffers using the field types of the fields without doing any conversions. For a list of the functions that allow you to convert data from one type to another upon transfer to or from a fielded buffer, see <a href="fml05.html#wp1060611">Conversion Functions</a>.
</p>
<h3 class="pHeading2"><a name="wp1056988"> </a>
Fadd
</h3>
<p class="pBody"><a name="wp1056989"> </a>
The <code class="cCode">Fadd</code> function adds a new field value to the fielded buffer.
</p>
<a name="wp1056990"> </a><div class="pPreformatted"><pre>int<br />Fadd(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, char *<code class="cCodeEmphasis">value</code>, FLDLEN <code class="cCodeEmphasis">len</code>)</pre></div><p class="pBody"><a name="wp1056991"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1056992"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1056993"> </a><code class="cCodeEmphasis">fieldid</code> is a field identifier.</li>
<li><a name="wp1056994"> </a><code class="cCodeEmphasis">value</code> is a pointer to a new value. Its type is shown as <code class="cCode">char*</code>, but when it is used, its type must be the same type as the value to be added (see below).</li>
<li><a name="wp1056995"> </a><code class="cCodeEmphasis">len</code> is the length of the value if its type is <code class="cCode">FLD_CARRAY</code> or <code class="cCode">FLD_MBSTRING</code>.</li>
</ul></div>
<p class="pBody"><a name="wp1056996"> </a>
If no occurrence of the field exists in the buffer, then the field is added. If one or more occurrences of the field already exist, then the value is added as a new occurrence of the field, and is assigned an occurrence number 1 greater than the current highest occurrence. (To add a specific occurrence, <a href="fml05.html#wp1057022"><code class="cCode">Fchg</code></a> must be used.)
</p>
<p class="pBody"><a name="wp1056997"> </a>
<code class="cCode">Fadd</code>, like all other functions that take or return a field value, expects a pointer to a field value, never the value itself.
</p>
<p class="pBody"><a name="wp1056998"> </a>
If the field type is such that the field length is fixed (<code class="cCode">short</code>, <code class="cCode">long</code>, <code class="cCode">char</code>, <code class="cCode">float</code>, or <code class="cCode">double</code>) or can be determined (<code class="cCode">string</code>), the field length need not be given (it is ignored). If the field type is a character array (<code class="cCode">FLD_CARRAY</code> or <code class="cCode">FLD_MBSTRING</code>), the length must be specified; the length is defined as type <code class="cCode">FLDLEN</code>. The following code, for example, gets the field identifier for the desired field and adds the field value to the buffer.
</p>
<a name="wp1056999"> </a><div class="pPreformatted"><pre>FLDID fieldid, Fldid;<br />FBFR *fbfr;<br />. . .<br />fieldid = Fldid(&quot;fieldname&quot;);<br />if(Fadd(fbfr, fieldid, &quot;new value&quot;, (FLDLEN)9) &lt; 0)<br />          F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057000"> </a>
It is assumed (by default) that the native type of the field is a character array so that the length of the value must be passed to the function. If the value being added is not a character array, the type of <code class="cCode">value</code> must reflect the type of the value to which it points. The following code, for example, adds a long field value.
</p>
<a name="wp1057001"> </a><div class="pPreformatted"><pre>long lval;<br />. . .<br />lval = 123456789;<br />if(Fadd(fbfr, fieldid, &amp;lval, (FLDLEN)0) &lt; 0)<br />          F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057002"> </a>
For character array fields, null fields may be indicated by a length of 0. For string fields, the null string may be stored since the NULL terminating byte is actually stored as part of the field value: a string consisting of only the NULL terminating byte is considered to have a length of 1. For all other types (fixed length types), you may choose some special value that is interpreted by the application as a NULL, but the size of the value is taken from its field type (for example, a length of 4 for a <code class="cCode">long</code>), regardless of what value is actually passed. Passing a NULL value address results in an error (<code class="cCode">FEINVAL</code>).
</p>
<p class="pBody"><a name="wp1057003"> </a>
For pointer fields, <code class="cCode">Fadd32</code> stores the pointer value. The buffer pointed to by a <code class="cCode">FLD_PTR</code> field must be allocated using the <a href="../rf3c/rf3c.html">tpalloc(3c)</a> call. For embedded FML32 buffers, <code class="cCode">Fadd32</code> stores the entire <code class="cCode">FLD_FML32</code> field value, except for the index.
</p>
<p class="pBody"><a name="wp1057004"> </a>
For embedded VIEW32 buffers, <code class="cCode">Fadd32</code> stores a pointer to a structure of type <code class="cCode">FVIEWFLD</code>, which contains vflags (a flags field, currently unused and set to <code class="cCode">0</code>), <code class="cCode">vname</code> (a character array containing the view name), and <code class="cCode">data</code> (a pointer to the view data stored as a C structure). The application provides the <code class="cCode">vname</code> and <code class="cCode">data</code> to <code class="cCode">Fadd32</code>. The <code class="cCode">FVIEWFLD</code> structure is as follows:
</p>
<a name="wp1057005"> </a><div class="pPreformatted"><pre><code class="cCode">typedef struct { <br />     TM32U vflags;                /* flags - currently unused */ <br />     char vname[FVIEWNAMESIZE+1]; /* name of view */ <br />     char *data;                  /* pointer to view structure */ <br />} FVIEWFLD;</code></pre></div><p class="pBody"><a name="wp1062315"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fadd,&#160;Fadd32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057006"> </a>
Fappend
</h3>
<p class="pBody"><a name="wp1057007"> </a>
The <code class="cCode">Fappend</code> function appends a new field value to the fielded buffer. 
</p>
<a name="wp1057008"> </a><div class="pPreformatted"><pre>int<br />Fappend(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, char *<code class="cCodeEmphasis">value</code>, FLDLEN <code class="cCodeEmphasis">len</code>)</pre></div><p class="pBody"><a name="wp1057009"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057010"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057011"> </a><code class="cCodeEmphasis">fieldid</code> is a field identifier.</li>
<li><a name="wp1057012"> </a><code class="cCodeEmphasis">value</code> is a pointer to a new value. Its type is shown as <code class="cCode">char *</code>, but when it is used, its type must be the same type as the value to be appended (see below).</li>
<li><a name="wp1057013"> </a><code class="cCodeEmphasis">len</code> is the length of the value if its type is <code class="cCode">FLD_CARRAY</code> or <code class="cCode">FLD_MBSTRING</code>.</li>
</ul></div>
<p class="pBody"><a name="wp1057014"> </a>
<code class="cCode">Fappend</code> appends a new occurrence of the field <code class="cCodeEmphasis">fieldid</code> with a value located at <code class="cCodeEmphasis">value</code> to the fielded buffer and puts the buffer into append mode. Append mode provides optimized buffer construction for large buffers constructed of many rows of a common set of fields. 
</p>
<p class="pBody"><a name="wp1057015"> </a>
A buffer that is in append mode is restricted as to what operations may be performed on the buffer. Only calls to the following FML routines are allowed in append mode: <code class="cCode">Fappend</code>, <a href="fml05.html#wp1057753"><code class="cCode">Findex</code></a>, <a href="fml05.html#wp1064043"><code class="cCode">Funindex</code></a>, <a href="fml05.html#wp1056910"><code class="cCode">Ffree</code></a>, <a href="fml05.html#wp1056933"><code class="cCode">Fused</code></a>, <a href="fml05.html#wp1056927"><code class="cCode">Funused</code></a> and <a href="fml05.html#wp1056922"><code class="cCode">Fsizeof</code></a>. Calls to <a href="fml05.html#wp1057753"><code class="cCode">Findex</code></a> or <a href="fml05.html#wp1064043"><code class="cCode">Funindex</code></a> end append mode. 
</p>
<p class="pBody"><a name="wp1057016"> </a>
The following example shows the construction, using <code class="cCode">Fappend</code>, of a 500-row buffer with 5 fields per row:
</p>
<a name="wp1057017"> </a><div class="pPreformatted"><pre>for (i=0; i 500 ;i++) {<br />   if ((Fappend(fbfr, LONGFLD1, &amp;lval1[i], (FLDLEN)0) &lt; 0) ||<br />      (Fappend(fbfr, LONGFLD2, &amp;lval2[i], (FLDLEN)0) &lt; 0) ||<br />      (Fappend(fbfr, STRFLD1, &amp;str1[i], (FLDLEN)0) &lt; 0) ||<br />      (Fappend(fbfr, STRFLD2, &amp;str2[i], (FLDLEN)0) &lt; 0) ||<br />      (Fappend(fbfr, LONGFLD3, &amp;lval3[i], (FLDLEN)0) &lt; 0)) {<br />      F_error(&quot;pgm_name&quot;);<br />     break;<br />   }<br />}<br />Findex(fbfr, 0);</pre></div><p class="pBody"><a name="wp1057018"> </a>
<code class="cCode">Fappend</code>, like all other functions that take or return a field value, expects a pointer to a field value, never the value itself.
</p>
<p class="pBody"><a name="wp1057019"> </a>
If the field type is such that the field length is fixed (<code class="cCode">short</code>, <code class="cCode">long</code>, <code class="cCode">char</code>, <code class="cCode">float</code>, or <code class="cCode">double</code>) or can be determined (<code class="cCode">string</code>), the field length need not be given (it is ignored). If the field type is a character array (<code class="cCode">FLD_CARRAY</code> or <code class="cCode">FLD_MBSTRING</code>), the length must be specified; the length is defined as type <code class="cCode">FLDLEN</code>.
</p>
<p class="pBody"><a name="wp1057020"> </a>
It is assumed (by default) that the native type of the field is a character array so that the length of the value must be passed to the function. If the value being appended is not a character array, the type of <code class="cCode">value</code> must reflect the type of the value it points to.
</p>
<p class="pBody"><a name="wp1057021"> </a>
For character array fields, null fields may be indicated by a length of 0. For string fields, the null string may be stored since the NULL terminating byte is actually stored as part of the field value: a string consisting of only the NULL terminating byte is considered to have a length of 1. For all other types (fixed-length types), you may choose some special value that is interpreted by the application as a NULL, but the size of the value is taken from its field type (for example, the length of 4 for a <code class="cCode">long</code>), regardless of what value is actually passed. Passing a NULL value address results in an error (<code class="cCode">FEINVAL</code>).
</p>
<p class="pBody"><a name="wp1062333"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fappend,&#160;Fappend32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057022"> </a>
Fchg
</h3>
<p class="pBody"><a name="wp1057023"> </a>
<code class="cCode">Fchg</code> changes the value of a field in the buffer. 
</p>
<a name="wp1057024"> </a><div class="pPreformatted"><pre>int<br />Fchg(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, FLDOCC <code class="cCodeEmphasis">oc</code>, char *<code class="cCodeEmphasis">value</code>, FLDLEN <code class="cCodeEmphasis">len</code>)</pre></div><p class="pBody"><a name="wp1057025"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057026"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057027"> </a><code class="cCodeEmphasis">fieldid</code> is a field identifier.</li>
<li><a name="wp1057028"> </a><code class="cCodeEmphasis">oc</code> is the occurrence number of the field.</li>
<li><a name="wp1057029"> </a><code class="cCodeEmphasis">value</code> is a pointer to a new value. Its type is shown as <code class="cCode">char *</code>, but when it is used, its type must be the same type as the value to be added (see <a href="fml05.html#wp1056988">Fadd</a>).</li>
<li><a name="wp1057030"> </a><code class="cCodeEmphasis">len</code> is the length of the value if its type is <code class="cCode">FLD_CARRAY</code> or <code class="cCode">FLD_MBSTRING</code>.</li>
</ul></div>
<p class="pBody"><a name="wp1057031"> </a>
For example, the following code changes a field of type <code class="cCode">carray</code> to a new value stored in <code class="cCode">value</code>:
</p>
<a name="wp1057032"> </a><div class="pPreformatted"><pre>FBFR *fbfr;<br />FLDID fieldid;<br />FLDOCC oc;<br />FLDLEN len;<br />char value[50];<br />. . .<br />strcpy(value, &quot;new value&quot;);<br />flen = strlen(value);<br />if(Fchg(fbfr, fieldid, oc, value, len) &lt; 0)<br />       F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057033"> </a>
If <code class="cCode">oc</code> is -1, then the field value is added as a new occurrence to the buffer. If <code class="cCode">oc</code> is 0 or greater and the field is found, then the field value is modified to the new value specified. If <code class="cCode">oc</code> is 0 or greater and the field is not found, then NULL occurrences are added to the buffer until the value can be added as the specified occurrence. For example, changing field occurrence 3 for a field that does not exist on a buffer causes three NULL occurrences to be added (occurrences 0, 1 and 2), followed by occurrence 3 with the specified field value. Null values consist of the NULL string &#8220;<code class="cCode">\0</code>&#8221; (1 byte in length) for string and character values, <code class="cCode">0</code> for long and short fields, <code class="cCode">0.0</code> for float and double values, and a zero-length string for a character array.
</p>
<p class="pBody"><a name="wp1057034"> </a>
The new or modified value is contained in <code class="cCode">value</code>. If it is a character array (<code class="cCode">FLD_CARRAY</code> or <code class="cCode">FLD_MBSTRING</code>), its length is given in <code class="cCode">len</code> (<code class="cCode">len</code> is ignored for other field types). If the value pointer is NULL and the field is found, then the field is deleted. If the field occurrence to be deleted is not found, it is considered an error (<code class="cCode">FNOTPRES</code>).
</p>
<p class="pBody"><a name="wp1057035"> </a>
For pointer fields, <code class="cCode">Fchg32</code> stores the pointer value. The buffer pointed to by a <code class="cCode">FLD_PTR</code> field must be allocated using the <a href="../rf3c/rf3c.html">tpalloc(3c)</a> call. For embedded FML32 buffers, <code class="cCode">Fchg32</code> stores the entire <code class="cCode">FLD_FML32</code> field value, except the index.
</p>
<p class="pBody"><a name="wp1075698"> </a>
For embedded VIEW32 buffers, <code class="cCode">Fchg32</code> stores a pointer to a structure of type <code class="cCode">FVIEWFLD</code>, which contains <code class="cCode">vflags</code> (a flags field, currently unused and set to <code class="cCode">0</code>), <code class="cCode">vname</code> (a character array containing the view name), and <code class="cCode">data</code> (a pointer to the view data stored as a C structure). The application provides the <code class="cCode">vname</code> and <code class="cCode">data</code> to <code class="cCode">Fchg32</code>. The <code class="cCode">FVIEWFLD</code> structure is as follows:
</p>
<a name="wp1057036"> </a><div class="pPreformatted"><pre><code class="cCode">typedef struct { <br />     TM32U vflags;                /* flags - currently unused */ <br />     char vname[FVIEWNAMESIZE+1]; /* name of view */ <br />     char *data;                  /* pointer to view structure */ <br />} FVIEWFLD;</code></pre></div><p class="pBody"><a name="wp1057037"> </a>
The buffer must have enough room to contain the modified or added field value, or an error is returned (<code class="cCode">FNOSPACE</code>).
</p>
<p class="pBody"><a name="wp1062354"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fchg,&#160;Fchg32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057038"> </a>
Fcmp
</h3>
<p class="pBody"><a name="wp1057039"> </a>
<code class="cCode">Fcmp</code> compares the field identifiers and field values of two fielded buffers.
</p>
<a name="wp1057040"> </a><div class="pPreformatted"><pre>int<br />Fcmp(FBFR *<code class="cCodeEmphasis">fbfr1</code>, FBFR *<code class="cCodeEmphasis">fbfr2</code>)</pre></div><p class="pBody"><a name="wp1057041"> </a>
Here <code class="cCodeEmphasis">fbfr1</code> and <code class="cCodeEmphasis">fbfr2</code> are pointers to fielded buffers.
</p>
<p class="pBody"><a name="wp1057042"> </a>
The function returns a <code class="cCode">0</code> if the buffers are identical; it returns a <code class="cCode">-1</code> on any of the following conditions: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057043"> </a>The <code class="cCode">fieldid</code> of a <code class="cCodeEmphasis">fbfr1</code> field is less than the field ID of the corresponding field of <code class="cCodeEmphasis">fbfr2.</code></li>
<li><a name="wp1057044"> </a>The value of a <code class="cCodeEmphasis">fbfr1</code> field is less than the value of the corresponding field of <code class="cCodeEmphasis">fbfr2.</code></li>
<li><a name="wp1057045"> </a><code class="cCodeEmphasis">fbfr1</code> is shorter than <code class="cCodeEmphasis">fbfr2</code>.</li>
</ul></div>
<p class="pBody"><a name="wp1057046"> </a>
The following criteria are used to determine whether pointers and embedded buffers are equal:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057047"> </a>For pointer fields, two pointer fields are considered equal if the pointer values (addresses) are equal.</li>
<li><a name="wp1057048"> </a>For embedded FML32 buffers, two fields are considered equal if all field occurrences and values are equal.</li>
<li><a name="wp1057049"> </a>For embedded VIEW32 buffers, two fields are considered equal if the view names are the same, and if all structure member occurrences and values are equal.</li>
</ul></div>
<p class="pBody"><a name="wp1057050"> </a>
<code class="cCode">Fcmp</code> returns a <code class="cCode">1</code> if the opposite of any of these conditions is true. For example, <code class="cCode">Fcmp</code> returns <code class="cCode">1</code> if the field ID of a <code class="cCodeEmphasis">fbfr2</code> field is less than the field ID of the corresponding field of <code class="cCodeEmphasis">fbfr1</code>.
</p>
<p class="pBody"><a name="wp1062372"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fcmp,&#160;Fcmp32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057051"> </a>
Fdel
</h3>
<p class="pBody"><a name="wp1057052"> </a>
The <code class="cCode">Fdel</code> function deletes the specified field occurrence.
</p>
<a name="wp1057053"> </a><div class="pPreformatted"><pre>int<br />Fdel(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, FLDOCC <code class="cCodeEmphasis">oc</code>)</pre></div><p class="pBody"><a name="wp1057054"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057055"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057056"> </a><code class="cCodeEmphasis">fieldid</code> is a field identifier.</li>
<li><a name="wp1057057"> </a><code class="cCodeEmphasis">oc</code> is the occurrence number.</li>
</ul></div>
<p class="pBody"><a name="wp1057058"> </a>
For example, the following code deletes the first occurrence of the field indicated by the specified field identifier:
</p>
<a name="wp1057059"> </a><div class="pPreformatted"><pre>FLDOCC occurrence;<br />. . .<br />occurrence=0;<br />if(Fdel(fbfr, fieldid, occurrence) &lt; 0)<br />            F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057060"> </a>
If the specified field does not exist, the function returns <code class="cCode">-1</code> and <code class="cCode">Ferror</code> is set to <code class="cCode">FNOTPRES</code>.
</p>
<p class="pBody"><a name="wp1057061"> </a>
For pointer fields, <code class="cCode">Fdel32</code> deletes the <code class="cCode">FLD_PTR</code> field occurrence without changing the referenced buffer or freeing the pointer. The data buffer is treated as an opaque pointer.
</p>
<p class="pBody"><a name="wp1062385"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fdel,&#160;Fdel32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057062"> </a>
Fdelall
</h3>
<p class="pBody"><a name="wp1057063"> </a>
<code class="cCode">Fdelall</code> deletes all occurrences of the specified field from the buffer. 
</p>
<a name="wp1057064"> </a><div class="pPreformatted"><pre>int<br />Fdelall(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>)</pre></div><p class="pBody"><a name="wp1057065"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057066"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057067"> </a><code class="cCodeEmphasis">fieldid</code> is a field identifier.</li>
</ul></div>
<p class="pBody"><a name="wp1057068"> </a>
Consider the following example:
</p>
<a name="wp1057069"> </a><div class="pPreformatted"><pre>if(Fdelall(fbfr, fieldid) &lt; 0)<br />     F_error(&quot;pgm_name&quot;);        /* field not present */</pre></div><p class="pBody"><a name="wp1057070"> </a>
If the field is not found, the function returns <code class="cCode">-1</code> and <code class="cCode">Ferror</code> is set to <code class="cCode">FNOTPRES</code>.
</p>
<p class="pBody"><a name="wp1057071"> </a>
For pointer fields, <code class="cCode">Fdelall32</code> deletes the <code class="cCode">FLD_PTR</code> field occurrence without changing the referenced buffer or freeing the pointer. The data buffer is treated as an opaque pointer.
</p>
<p class="pBody"><a name="wp1062395"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fdelall,&#160;Fdelall32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057072"> </a>
Fdelete
</h3>
<p class="pBody"><a name="wp1057073"> </a>
<code class="cCode">Fdelete</code> deletes all occurrences of all fields listed in the array of field identifiers, <code class="cCode">fieldid[]</code>.
</p>
<a name="wp1057074"> </a><div class="pPreformatted"><pre>int<br />Fdelete(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID *<code class="cCodeEmphasis">fieldid</code>)</pre></div><p class="pBody"><a name="wp1057075"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057076"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057077"> </a><code class="cCodeEmphasis">fieldid</code> is a pointer to the list of field identifiers to be deleted.</li>
</ul></div>
<p class="pBody"><a name="wp1057078"> </a>
The update is done directly to the fielded buffer. The array of field identifiers does not need to be in any specific order, but the last entry in the array must be field identifier 0 (<code class="cCode">BADFLDID</code>). Consider the following example:
</p>
<a name="wp1057079"> </a><div class="pPreformatted"><pre>#include &quot;fldtbl.h&quot;<br />FBFR *dest;<br />FLDID fieldid[20];<br />. . .<br />fieldid[0] = A;   /* field id for field A */<br />fieldid[1] = D;   /* field id for field D */<br />fieldid[2] = BADFLDID;   /* sentinel value */<br />if(Fdelete(dest, fieldid) &lt; 0)<br />         F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057080"> </a>
If the destination buffer has fields A, B, C, and D, this example results in a buffer that contains only occurrences of fields B and C.
</p>
<p class="pBody"><a name="wp1057081"> </a>
<code class="cCode">Fdelete</code> provides a more efficient way of deleting several fields from a buffer than using several <code class="cCode">Fdelall</code> calls.
</p>
<p class="pBody"><a name="wp1057082"> </a>
For pointer fields, <code class="cCode">Fdelete</code> deletes the <code class="cCode">FLD_PTR</code> field occurrence without changing the referenced buffer or freeing the pointer. The data buffer is treated as an opaque pointer.
</p>
<p class="pBody"><a name="wp1062405"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fdelete,&#160;Fdelete32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057083"> </a>
Ffind
</h3>
<p class="pBody"><a name="wp1057084"> </a>
<code class="cCode">Ffind</code> finds the value of the specified field occurrence in the buffer.
</p>
<a name="wp1057085"> </a><div class="pPreformatted"><pre>char *<br />Ffind(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, FLDOCC <code class="cCodeEmphasis">oc</code>, FLDLEN *<code class="cCodeEmphasis">len</code>)</pre></div><p class="pBody"><a name="wp1057086"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057087"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057088"> </a><code class="cCodeEmphasis">fieldid</code> is a field identifier.</li>
<li><a name="wp1057089"> </a><code class="cCodeEmphasis">oc</code> is the occurrence number.</li>
<li><a name="wp1057090"> </a><code class="cCodeEmphasis">len</code> is the length of the value found.</li>
</ul></div>
<p class="pBody"><a name="wp1057091"> </a>
In the previous declaration the return value to <code class="cCode">Ffind</code> is shown as a character pointer data type (<code class="cCode">char*</code> in C). The actual type of the pointer returned is the same as the type of the value to which it points.
</p>
<p class="pBody"><a name="wp1057092"> </a>
The following code provides an example of how this function is used:
</p>
<a name="wp1057093"> </a><div class="pPreformatted"><pre>#include &quot;fldtbl.h&quot;<br />FBFR *fbfr;<br />FLDLEN len;<br />char* Ffind, *value;<br />. . .<br />if((value=Ffind(fbfr,ZIP,0, &amp;len)) == NULL)<br />      F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057094"> </a>
If the field is found, its length is returned in <code class="cCode">len</code> (if <code class="cCode">len</code> is NULL, the length is not returned), and its location is returned as the value of the function. If the field is not found, NULL is returned, and <code class="cCode">Ferror</code> is set to <code class="cCode">FNOTPRES</code>.
</p>
<p class="pBody"><a name="wp1057095"> </a>
<code class="cCode">Ffind</code> is useful for gaining &#8220;read-only&#8221; access to a field. The value returned by <code class="cCode">Ffind</code> should not be used to modify the buffer. Field values should be modified only by the <code class="cCode">Fadd</code> or <code class="cCode">Fchg </code>function. This function does not check for occurrences of the specified field in embedded buffers.
</p>
<p class="pBody"><a name="wp1057096"> </a>
The value returned by <code class="cCode">Ffind</code> is valid only so long as the buffer remains unmodified. The value is guaranteed to be aligned on a short boundary but may not be aligned on a long or double boundary, even if the field is of that type. (See the conversion functions described later in this document for aligned values.) On processors that require proper alignment of variables, referencing the value when not aligned properly causes a system error, as shown in the following example:
</p>
<a name="wp1057097"> </a><div class="pPreformatted"><pre>long *l1,l2;<br />FLDLEN length;<br />char *Ffind;<br />. . .<br />if((l1=(long *)Ffind(fbfr, ZIP, 0, &amp;length)) == NULL)<br />        F_error(&quot;pgm_name&quot;);<br />else<br />        l2 = *l1;</pre></div><p class="pBody"><a name="wp1057098"> </a>
This code should be re-written as follows: 
</p>
<a name="wp1057099"> </a><div class="pPreformatted"><pre>if((l1==(long *)Ffind(fbfr, ZIP, 0, &amp;length)) == NULL)<br />         F_error(&quot;pgm_name&quot;);<br />else<br />         memcpy(&amp;l2,l1,sizeof(long));</pre></div><p class="pBody"><a name="wp1062415"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Ffind,&#160;Ffind32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057100"> </a>
Ffindlast
</h3>
<p class="pBody"><a name="wp1057101"> </a>
This function finds the last occurrence of a field in a fielded buffer and returns a pointer to the field, as well as the occurrence number and length of the field occurrence.
</p>
<a name="wp1057102"> </a><div class="pPreformatted"><pre>char *<br />Ffindlast(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, FLDOCC *<code class="cCodeEmphasis">oc</code>, FLDLEN *<code class="cCodeEmphasis">len</code>)</pre></div><p class="pBody"><a name="wp1057103"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057104"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057105"> </a><code class="cCodeEmphasis">fieldid</code> is a field identifier.</li>
<li><a name="wp1057106"> </a><code class="cCodeEmphasis">oc</code> is a pointer to the occurrence number of the last field occurrence found.</li>
<li><a name="wp1057107"> </a><code class="cCodeEmphasis">len</code> is a pointer to the length of the value found.</li>
</ul></div>
<p class="pBody"><a name="wp1057108"> </a>
In the previous declaration the return value to <code class="cCode">Ffindlast</code> is shown as a character pointer data type (<code class="cCode">char*</code> in C). The actual type of the pointer returned is the same as the type of the value to which it points.
</p>
<p class="pBody"><a name="wp1057109"> </a>
<code class="cCode">Ffindlast</code> acts like <a href="fml05.html#wp1057083"><code class="cCode">Ffind</code></a>, except that you do not specify a field occurrence. Instead, both the occurrence number and the value of the last field occurrence are returned. However, if you specify NULL as the value of the occurrence when calling the function, the occurrence number is not returned. This function does not check for occurrences of the specified field in embedded buffers.
</p>
<p class="pBody"><a name="wp1057110"> </a>
The value returned by <code class="cCode">Ffindlast</code> is valid only as long as the buffer remains unchanged.
</p>
<p class="pBody"><a name="wp1062429"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Ffindlast,&#160;Ffindlast32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057111"> </a>
Ffindocc
</h3>
<p class="pBody"><a name="wp1057112"> </a>
<code class="cCode">Ffindocc</code> looks at occurrences of the specified field on the buffer and returns the occurrence number of the first field occurrence that matches the user-specified field value.
</p>
<a name="wp1057113"> </a><div class="pPreformatted"><pre>FLDOCC<br />Ffindocc(FBFR *<code class="cCodeEmphasis">fbfr, </code>FLDID <code class="cCodeEmphasis">fieldid</code>, char *<code class="cCodeEmphasis">value</code>, FLDLEN <code class="cCodeEmphasis">len</code>;)</pre></div><p class="pBody"><a name="wp1057114"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057115"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057116"> </a><code class="cCodeEmphasis">fieldid</code> is a field identifier.</li>
<li><a name="wp1057117"> </a><code class="cCodeEmphasis">value</code> is a pointer to a new value. Its type is shown as <code class="cCode">char*</code>, but when it is used, its type must be the same type as the value to be added (see <a href="fml05.html#wp1056988">Fadd</a>).</li>
<li><a name="wp1057118"> </a><code class="cCodeEmphasis">len</code> is the length of the value if its type is <code class="cCode">FLD_CARRAY</code> or <code class="cCode">FLD_MBSTRING</code>.</li>
</ul></div>
<p class="pBody"><a name="wp1057119"> </a>
For example, the following code sets <code class="cCode">oc</code> to the occurrence for the specified zip code:
</p>
<a name="wp1057120"> </a><div class="pPreformatted"><pre>#include &quot;fldtbl.h&quot;<br />FBFR *fbfr;<br />FLDOCC oc;<br />long zipvalue;<br />. . .<br />zipvalue = 123456;<br />if((oc=Ffindocc(fbfr,ZIP,&amp;zipvalue, 0)) &lt; 0)<br />       F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057121"> </a>
Regular expressions are supported for string fields. For example, the following code sets <code class="cCode">oc</code> to the occurrence of <code class="cCode">NAME</code> that starts with &#8220;J&#8221;:
</p>
<a name="wp1057122"> </a><div class="pPreformatted"><pre>#include &quot;fldtbl.h&quot;<br />FBFR *fbfr;<br />FLDOCC oc;<br />char *name;<br />. . .<br />name = &quot;J.*&quot;<br />if ((oc = Ffindocc(fbfr, NAME, name, 1)) &lt; 0)<br />        F_error(&quot;pgm_name&quot;);</pre></div><a name="wp1057123"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>To enable pattern matching on strings, the fourth argument to <code class="cCode">Ffindocc</code> must be non-zero. If it is zero, a simple string compare is performed. If the field value is not found, <code class="cCode">-1</code> is returned.</td>
</tr>
</table>

<p class="pBody"><a name="wp1057124"> </a>
For upward compatibility, a circumflex (<code class="cCode">^</code>) prefix and dollar sign (<code class="cCode">$</code>) suffix are implicitly added to the regular expression. Thus the previous example is actually interpreted as &#8220;<code class="cCode">^(J.*)$</code>&#8221;. The regular expression must match the entire string value in the field.
</p>
<p class="pBody"><a name="wp1062480"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Ffindocc,&#160;Ffindocc32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057125"> </a>
Fget
</h3>
<p class="pBody"><a name="wp1057126"> </a>
Use <code class="cCode">Fget</code> to retrieve a field from a fielded buffer when the value is to be modified.
</p>
<a name="wp1057127"> </a><div class="pPreformatted"><pre>int<br />Fget(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, FLDOCC <code class="cCodeEmphasis">oc</code>, char *<code class="cCodeEmphasis">loc</code>, FLDLEN *maxlen)</pre></div><p class="pBody"><a name="wp1057128"> </a>
Here:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057129"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057130"> </a><code class="cCodeEmphasis">fieldid</code> is a field identifier.</li>
<li><a name="wp1057131"> </a><code class="cCodeEmphasis">oc</code> is the occurrence number.</li>
<li><a name="wp1057132"> </a><code class="cCodeEmphasis">loc</code> is a pointer to a buffer to copy the field value into.</li>
<li><a name="wp1057133"> </a><code class="cCodeEmphasis">maxlen</code> is a pointer to the length of the source buffer on calling the function, and a pointer to the length of the field on return.</li>
</ul></div>
<p class="pBody"><a name="wp1057134"> </a>
The caller provides <code class="cCode">Fget</code> with a pointer to a private buffer, as well as the length of the buffer. If <code class="cCode">maxlen</code> is specified as NULL, then it is assumed that the destination buffer is large enough to accommodate the field value, and its length is not returned.
</p>
<p class="pBody"><a name="wp1057135"> </a>
<code class="cCode">Fget</code> returns an error if the desired field is not in the buffer (<code class="cCode">FNOTPRES</code>), or if the destination buffer is too small (<code class="cCode">FNOSPACE</code>). For example, the following code gets the zip code, assuming it is stored as a character array or string:
</p>
<a name="wp1057136"> </a><div class="pPreformatted"><pre>FLDLEN len;<br />char value[100];<br />. . .<br />len=sizeof(value);<br />if(Fget(fbfr, ZIP, 0, value, &amp;len) &lt; 0)<br />          F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057137"> </a>
If the zip code is stored as a <code class="cCode">long</code>, it can be retrieved by the following code:
</p>
<a name="wp1057138"> </a><div class="pPreformatted"><pre>FLDLEN len;<br />long value;<br />. . .<br />len = sizeof(value);<br />if(Fget(fbfr, ZIP, 0, value, &amp;len) &lt; 0)<br />          F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1062511"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fget,&#160;Fget32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057139"> </a>
Fgetalloc
</h3>
<p class="pBody"><a name="wp1057140"> </a>
Like <a href="fml05.html#wp1057125"><code class="cCode">Fget</code></a>, <code class="cCode">Fgetalloc</code> finds and makes a copy of a buffer field, but it acquires space for the field via a call to <code class="cCode">malloc</code>(3). 
</p>
<a name="wp1057141"> </a><div class="pPreformatted"><pre>char *<br />Fgetalloc(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, FLDOCC <code class="cCodeEmphasis">oc</code>, FLDLEN *<code class="cCodeEmphasis">extralen</code>)</pre></div><p class="pBody"><a name="wp1057142"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057143"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057144"> </a><code class="cCodeEmphasis">fieldid</code> is a field identifier.</li>
<li><a name="wp1057145"> </a><code class="cCodeEmphasis">oc </code>is the occurrence number.</li>
<li><a name="wp1057146"> </a><code class="cCodeEmphasis">extralen</code> is a pointer to the additional length to be acquired on calling the function, and a pointer to the actual length acquired on return.</li>
</ul></div>
<p class="pBody"><a name="wp1057147"> </a>
In the declaration above the return value to <code class="cCode">Fgetalloc</code> is shown as a character pointer data type (<code class="cCode">char*</code> in C). The actual type of the pointer returned is the same as the type of the value to which it points.
</p>
<p class="pBody"><a name="wp1057148"> </a>
On success, <code class="cCode">Fgetalloc</code> returns a valid pointer to the copy of the properly aligned buffer field; on error it returns NULL. If <code class="cCode">malloc</code>(3) fails, <code class="cCode">Fgetalloc</code> returns an error and <code class="cCode">Ferror</code> is set to <code class="cCode">FMALLOC</code>.
</p>
<p class="pBody"><a name="wp1057149"> </a>
The last parameter to <code class="cCode">Fgetalloc</code> specifies an extra amount of space to be acquired if, for instance, the value obtained is to be expanded before re-insertion into the fielded buffer. On success, the length of the allocated buffer is returned in <code class="cCode">extralen</code>. Consider the following example:
</p>
<a name="wp1057150"> </a><div class="pPreformatted"><pre>FLDLEN extralen;<br />FBFR *fieldbfr<br />char *Fgetalloc;<br />. . .<br />extralen = 0;<br />if (fieldbfr = (FBFR *)Fgetalloc(fbfr, ZIP, 0, &amp;extralen) == NULL)<br />         F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057151"> </a>
It is the responsibility of the caller to <code class="cCode">free</code> space acquired by <code class="cCode">Fgetalloc</code>.
</p>
<p class="pBody"><a name="wp1062525"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fgetalloc,&#160;Fgetalloc32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057152"> </a>
Fgetlast
</h3>
<p class="pBody"><a name="wp1057153"> </a>
<code class="cCode">Fgetlast</code> is used to retrieve the last occurrence of a field from a fielded buffer when the value is to be modified.
</p>
<a name="wp1057154"> </a><div class="pPreformatted"><pre>int<br />Fgetlast(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, FLDOCC *<code class="cCodeEmphasis">oc</code>, char *<code class="cCodeEmphasis">loc</code>, FLDLEN *<code class="cCodeEmphasis">maxlen</code>)</pre></div><p class="pBody"><a name="wp1057155"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057156"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057157"> </a><code class="cCodeEmphasis">fieldid</code> is a field identifier.</li>
<li><a name="wp1057158"> </a><code class="cCodeEmphasis">oc</code> is a pointer to the occurrence number of the last field occurrence.</li>
<li><a name="wp1057159"> </a><code class="cCodeEmphasis">loc</code> is a pointer to a buffer to copy the field value into.</li>
<li><a name="wp1057160"> </a><code class="cCodeEmphasis">maxlen</code> is a pointer to the length of the source buffer on calling the function, and a pointer to the length of the field on return.</li>
</ul></div>
<p class="pBody"><a name="wp1057161"> </a>
The caller provides <code class="cCode">Fgetlast</code> with a pointer to a private buffer, as well as the length of the buffer. <code class="cCode">Fgetlast</code> acts like <code class="cCode">Fget</code>, except that you do not specify a field occurrence. Instead, both the occurrence number and the value of the last field occurrence are returned. However, if you specify NULL for <code class="cCode">occ</code> on calling the function, the occurrence number is not returned.
</p>
<p class="pBody"><a name="wp1062561"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fgetlast,&#160;Fgetlast32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057162"> </a>
Fnext
</h3>
<p class="pBody"><a name="wp1057163"> </a>
<code class="cCode">Fnext</code> finds the next field in the buffer after the specified field occurrence.
</p>
<a name="wp1057164"> </a><div class="pPreformatted"><pre>int<br />Fnext(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID *<code class="cCodeEmphasis">fieldid</code>, FLDOCC *<code class="cCodeEmphasis">oc</code>, char *<code class="cCodeEmphasis">value</code>, FLDLEN *<code class="cCodeEmphasis">len</code>)</pre></div><p class="pBody"><a name="wp1057165"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057166"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057167"> </a><code class="cCodeEmphasis">fieldid</code> is a pointer to a field identifier.</li>
<li><a name="wp1057168"> </a><code class="cCodeEmphasis">oc</code> is a pointer to the occurrence number.</li>
<li><a name="wp1057169"> </a><code class="cCodeEmphasis">value</code> is a pointer of the same type as the value contained in the next field.</li>
<li><a name="wp1057170"> </a><code class="cCodeEmphasis">len</code> is a pointer to the length of <code class="cCode">*</code><code class="cCodeEmphasis">value</code>.</li>
</ul></div>
<p class="pBody"><a name="wp1057171"> </a>
A <code class="cCode">fieldid</code> of <code class="cCode">FIRSTFLDID</code> should be specified to get the first field in a buffer; the field identifier and occurrence number of the first field occurrence are returned in the corresponding parameters. If the field is not NULL, its value is copied into the memory location addressed by the <code class="cCode">value</code> pointer. 
</p>
<p class="pBody"><a name="wp1057172"> </a>
The <code class="cCode">len</code> parameter is used to determine whether <code class="cCode">value</code> has enough space allocated to contain the field value. If the amount of space is insufficient, <code class="cCode">Ferror</code> is set to <code class="cCode">FNOSPACE</code>. The length of the value is returned in the <code class="cCode">len</code> parameter. If the value of the field is non-null, then the <code class="cCode">len</code> parameter is also assumed to contain the length of the currently allocated space for <code class="cCode">value</code>.
</p>
<p class="pBody"><a name="wp1057173"> </a>
When the field to be retrieved is an embedded VIEW32 buffer, the <code class="cCodeEmphasis">value</code> parameter points to an <code class="cCode">FVIEWFLD</code> structure. The <code class="cCode">Fnext</code> function populates the <code class="cCodeEmphasis">vname</code> and <code class="cCodeEmphasis">data</code> fields in the structure. The <code class="cCode">FVIEWFLD</code> structure is as follows:
</p>
<a name="wp1057174"> </a><div class="pPreformatted"><pre><code class="cCode">typedef struct { <br />     TM32U vflags;                /* flags - currently unused */ <br />     char vname[FVIEWNAMESIZE+1]; /* name of view */ <br />     char *data;                  /* pointer to view structure */ <br />} FVIEWFLD;</code></pre></div><p class="pBody"><a name="wp1057175"> </a>
If the field value is NULL, then the <code class="cCode">value</code> and <code class="cCode">length</code> parameters are not changed.
</p>
<p class="pBody"><a name="wp1057176"> </a>
If no more fields are found, <code class="cCode">Fnext</code> returns <code class="cCode">0</code> (end of buffer) and <code class="cCode">fieldid</code>, <code class="cCode">occurrence</code>, and <code class="cCode">value</code> are left unchanged.
</p>
<p class="pBody"><a name="wp1057177"> </a>
If the <code class="cCode">value</code> parameter is not NULL, the <code class="cCode">length</code> parameter is also assumed to be non-NULL.
</p>
<p class="pBody"><a name="wp1057178"> </a>
The following example reads all field occurrences in the buffer:
</p>
<a name="wp1057179"> </a><div class="pPreformatted"><pre>FLDID fieldid;<br />FLDOCC occurrence;<br />char *value[100];<br />FLDLEN len;<br />. . .<br />for(fieldid=FIRSTFLDID,len=sizeof(value);<br />     Fnext(fbfr,&amp;fieldid,&amp;occurrence,value,&amp;len) &gt; 0;<br />     len=sizeof(value)) {<br />   /* code for each field occurrence */<br />}</pre></div><p class="pBody"><a name="wp1062753"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fnext,&#160;Fnext32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057180"> </a>
Fnum
</h3>
<p class="pBody"><a name="wp1057181"> </a>
<code class="cCode">Fnum</code> returns the number of fields contained in the specified buffer, or <code class="cCode">-1</code> on error. 
</p>
<a name="wp1057182"> </a><div class="pPreformatted"><pre>FLDOCC<br />Fnum(FBFR *<code class="cCodeEmphasis">fbfr</code>)</pre></div><p class="pBody"><a name="wp1057183"> </a>
Here <code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer. The following code, for example, prints the number of fields in the specified buffer:
</p>
<a name="wp1057184"> </a><div class="pPreformatted"><pre>if((cnt=Fnum(fbfr)) &lt; 0)<br />  F_error(&quot;pgm_name&quot;);<br />else<br />  fprintf(stdout,&quot;%d fields in buffer\n&quot;,cnt);</pre></div><p class="pBody"><a name="wp1057185"> </a>
Each <code class="cCode">FLD_FML32</code> and <code class="cCode">FLD_VIEW32</code> field is counted as a single field, regardless of the number of fields it contains.
</p>
<p class="pBody"><a name="wp1062571"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fnum,&#160;Fnum32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057186"> </a>
Foccur
</h3>
<p class="pBody"><a name="wp1057187"> </a>
<code class="cCode">Foccur</code> returns the number of occurrences for the specified field in the buffer: 
</p>
<a name="wp1057188"> </a><div class="pPreformatted"><pre>FLDOCC<br />Foccur(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>)</pre></div><p class="pBody"><a name="wp1057189"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057190"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057191"> </a><code class="cCodeEmphasis">fieldid</code> is a field identifier.</li>
</ul></div>
<p class="pBody"><a name="wp1057192"> </a>
Occurrences of a field within an embedded FML32 buffer are not counted.
</p>
<p class="pBody"><a name="wp1057193"> </a>
Zero is returned if the field does not occur in the buffer and <code class="cCode">-1</code> is returned on error. For example, the following code prints the number of occurrences of the field <code class="cCode">ZIP</code> in the specified buffer:
</p>
<a name="wp1057194"> </a><div class="pPreformatted"><pre>FLDOCC cnt;<br />. . .<br />if((cnt=Foccur(fbfr,ZIP)) &lt; 0)<br /> F_error(&quot;pgm_name&quot;);<br />else<br /> fprintf(stdout,&quot;Field ZIP occurs %d times in buffer\n&quot;,cnt);</pre></div><p class="pBody"><a name="wp1062588"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Foccur,&#160;Foccur32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057195"> </a>
Fpres
</h3>
<p class="pBody"><a name="wp1057196"> </a>
<code class="cCode">Fpres</code> returns true (1) if the specified field occurrence exists. Otherwise, it returns false (0).
</p>
<a name="wp1057197"> </a><div class="pPreformatted"><pre>int<br />Fpres(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, FLDOCC <code class="cCodeEmphasis">oc</code>)</pre></div><p class="pBody"><a name="wp1057198"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057199"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer. </li>
<li><a name="wp1057200"> </a><code class="cCodeEmphasis">fieldid</code> is a field identifier.</li>
<li><a name="wp1057201"> </a><code class="cCodeEmphasis">oc</code> is the occurrence number.</li>
</ul></div>
<p class="pBody"><a name="wp1057202"> </a>
For example, the following code returns true if the field <code class="cCode">ZIP</code> exists in the fielded buffer referenced by <code class="cCode">fbfr</code>:
</p>
<a name="wp1057203"> </a><div class="pPreformatted"><pre>Fpres(fbfr,ZIP,0)</pre></div><p class="pBody"><a name="wp1057204"> </a>
<code class="cCode">Fpres</code> does not check for occurrences of the specified field within an embedded buffer.
</p>
<p class="pBody"><a name="wp1062709"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fpres,&#160;Fpres32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057205"> </a>
Fvals and Fvall
</h3>
<p class="pBody"><a name="wp1057206"> </a>
<code class="cCode">Fvals</code> works like <a href="fml05.html#wp1057083"><code class="cCode">Ffind</code></a> for <code class="cCode">string</code> values but guarantees that a pointer to a value is returned. <code class="cCode">Fvall</code> works like <code class="cCode">Ffind</code> for <code class="cCode">long</code> and <code class="cCode">short</code> values, but returns the actual value of the field as a <code class="cCode">long</code>, instead of as a pointer to the value. 
</p>
<a name="wp1057207"> </a><div class="pPreformatted"><pre><code class="cCode">char</code>* <br /><code class="cCode">Fvals(FBFR *</code><code class="cCodeEmphasis">fbfr</code><code class="cCode">,FLDID </code><code class="cCodeEmphasis">fieldid</code><code class="cCode">,FLDOCC </code><code class="cCodeEmphasis">oc)</code></pre></div><a name="wp1057208"> </a><div class="pPreformatted"><pre>char*<br /><code class="cCode">Fvall(FBFR *</code><code class="cCodeEmphasis">fbfr</code><code class="cCode">,FLDID </code><code class="cCodeEmphasis">fieldid</code><code class="cCode">,FLDOCC </code><code class="cCodeEmphasis">oc)</code></pre></div><p class="pBody"><a name="wp1057209"> </a>
In both functions:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057210"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057211"> </a><code class="cCodeEmphasis">fieldid</code> is a field identifier.</li>
<li><a name="wp1057212"> </a><code class="cCodeEmphasis">oc</code> is the occurrence number.</li>
</ul></div>
<p class="pBody"><a name="wp1057213"> </a>
For <code class="cCode">Fvals</code>, if the specified field occurrence is not found, the NULL string, <code class="cCode">\0</code>, is returned. This function is useful for passing the value of a field to another function without checking the return value. This function is valid only for fields of type <code class="cCode">string</code>; the NULL string is automatically returned for other field types (that is, no conversion is done).
</p>
<p class="pBody"><a name="wp1057214"> </a>
For <code class="cCode">Fvall</code>, if the specified field occurrence is not found, then 0 is returned. This function is useful for passing the value of a field to another function without checking the return value. This function is valid only for fields of type <code class="cCode">long</code> and <code class="cCode">short</code>; 0 is automatically returned for other field types (that is, no conversion is done).
</p>
<p class="pBody"><a name="wp1062773"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fvals,&#160;Fvals32(3fml)</a> and <a href="../rf3fml/rf3fml.html">Fvall,&#160;Fvall32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1057216"> </a>
Buffer Update Functions
</h2><p class="pBody"><a name="wp1057217"> </a>
The functions listed in this section access and update entire fielded buffers, rather than individual fields in the buffers. These functions use, at most, three parameters:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057218"> </a><code class="cCodeEmphasis">dest</code> is a pointer to a destination fielded buffer.</li>
<li><a name="wp1057219"> </a><code class="cCodeEmphasis">src</code> is a pointer to a source fielded buffer.</li>
<li><a name="wp1057220"> </a><code class="cCodeEmphasis">fieldid</code> is a field identifier or an array of field identifiers.</li>
</ul></div>
<h3 class="pHeading2"><a name="wp1057222"> </a>
Fconcat
</h3>
<p class="pBody"><a name="wp1057223"> </a>
<code class="cCode">Fconcat</code> adds fields from the source buffer to the fields that already exist in the destination buffer. 
</p>
<a name="wp1057224"> </a><div class="pPreformatted"><pre>int<br />Fconcat(FBFR *<code class="cCodeEmphasis">dest</code>, FBFR *<code class="cCodeEmphasis">src</code>)</pre></div><p class="pBody"><a name="wp1057225"> </a>
Occurrences in the destination buffer are maintained (that is, they are retained and not modified) and new occurrences from the source buffer are added with greater occurrence numbers than any existing occurrences for each field. The fields are maintained in field identifier order.
</p>
<p class="pBody"><a name="wp1057226"> </a>
Consider the following example:
</p>
<a name="wp1057227"> </a><div class="pPreformatted"><pre>FBFR *src, *dest;<br />. . .<br />if(Fconcat(dest,src) &lt; 0)<br />       F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057228"> </a>
If <code class="cCode">dest</code> has fields A, B, and two occurrences of C, and <code class="cCode">src</code> has fields A, C, and D, the resulting <code class="cCode">dest</code> has two occurrences of field A (destination field A and source field A), field B, three occurrences of field C (two from <code class="cCode">dest</code> and the third from <code class="cCode">src</code>), and field D.
</p>
<p class="pBody"><a name="wp1057229"> </a>
This operation fails if there is not enough space for the new fields (<code class="cCode">FNOSPACE</code>); in this case, the destination buffer remains unchanged.
</p>
<p class="pBody"><a name="wp1062866"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fconcat,&#160;Fconcat32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057231"> </a>
Fjoin
</h3>
<p class="pBody"><a name="wp1057232"> </a>
<code class="cCode">Fjoin</code> is used to join two fielded buffers based on matching field ID/occurrence. 
</p>
<a name="wp1057233"> </a><div class="pPreformatted"><pre>int<br />Fjoin(FBFR *<code class="cCodeEmphasis">dest</code>, FBFR *<code class="cCodeEmphasis">src</code>)</pre></div><p class="pBody"><a name="wp1057234"> </a>
For fields that match on field ID/occurrence, the field value is updated in the destination buffer with the value from the source buffer. Fields in the destination buffer that have no corresponding field ID/occurrence in the source buffer are deleted. Fields in the source buffer that have no corresponding field ID/occurrence in the destination buffer are not added to the destination buffer. Thus
</p>
<a name="wp1057235"> </a><div class="pPreformatted"><pre>if(Fjoin(dest,src) &lt; 0)<br />     F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057236"> </a>
Using the input buffers in the previous example results in a destination buffer that has source field value A and source field value C. This function may fail due to lack of space if the new values are larger than the old (<code class="cCode">FNOSPACE</code>); in this case, the destination buffer will have been modified. However, if this happens, the destination buffer may be reallocated using <code class="cCode">Frealloc</code> and the <code class="cCode">Fjoin</code> function repeated (even if the destination buffer has been partially updated, repeating the function gives the correct results).
</p>
<p class="pBody"><a name="wp1057237"> </a>
If joining buffers results in the removal of a pointer field (<code class="cCode">FLD_PTR</code>), the memory area referenced by the pointer is not modified or freed.
</p>
<p class="pBody"><a name="wp1062944"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fjoin,&#160;Fjoin32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057239"> </a>
Fojoin
</h3>
<p class="pBody"><a name="wp1057240"> </a>
<code class="cCode">Fojoin</code> is similar to <code class="cCode">Fjoin</code>, but it does not delete fields from the destination buffer that have no corresponding field ID/occurrence in the source buffer. 
</p>
<a name="wp1057241"> </a><div class="pPreformatted"><pre>int<br />Fojoin(FBFR *<code class="cCodeEmphasis">dest</code>, FBFR *<code class="cCodeEmphasis">src</code>)</pre></div><p class="pBody"><a name="wp1057242"> </a>
Note that fields in the source buffer for which there are no corresponding field ID/occurrence pairs in the destination buffer are not added to the destination buffer. Consider the following example:
</p>
<a name="wp1057243"> </a><div class="pPreformatted"><pre>if(Fojoin(dest,src) &lt; 0)<br />      F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057244"> </a>
Using the input buffers from the previous example, <code class="cCode">dest</code> contains the source field value A, the destination field value B, the source field value C, and the second destination field value C. As with <code class="cCode">Fjoin</code>, this function can fail for lack of space (<code class="cCode">FNOSPACE</code>) and can be reissued again after more space has been allocated to complete the operation.
</p>
<p class="pBody"><a name="wp1057245"> </a>
If joining buffers results in the removal of a pointer field (<code class="cCode">FLD_PTR</code>), the memory area referenced by the pointer is not modified or freed.
</p>
<p class="pBody"><a name="wp1062984"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fojoin,&#160;Fojoin32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057246"> </a>
Fproj
</h3>
<p class="pBody"><a name="wp1057247"> </a>
<code class="cCode">Fproj</code> is used to update a buffer in place so that only the desired fields are kept. (The result, in other words, is a projection on specified fields.) If updating buffers results in the removal of a pointer field (<code class="cCode">FLD_PTR</code>), the memory area referenced by the pointer is not modified or freed.
</p>
<a name="wp1057248"> </a><div class="pPreformatted"><pre>int<br />Fproj(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID *<code class="cCodeEmphasis">fieldid</code>)</pre></div><p class="pBody"><a name="wp1057249"> </a>
These fields are specified in an array of field identifiers passed to the function. The update is performed directly in the fielded buffer. Consider the following example:
</p>
<a name="wp1057250"> </a><div class="pPreformatted"><pre>#include &quot;fldtbl.h&quot;<br />FBFR *fbfr;<br />FLDID fieldid[20];<br />. . .<br />fieldid[0] = A;   /* field id for field A */<br />fieldid[1] = D;   /* field id for field D */<br />fieldid[2] = BADFLDID;   /* sentinel value */<br />if(Fproj(fbfr, fieldid) &lt; 0)<br />      F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057251"> </a>
If the buffer has fields A, B, C, and D, the example results in a buffer that contains only occurrences of fields A and D. Note that the entries in the array of field identifiers do not need to be in any specific order, but the last value in the array of field identifiers must be field identifier 0 (<code class="cCode">BADFLDID</code>).
</p>
<p class="pBody"><a name="wp1063010"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fproj,&#160;Fproj32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057252"> </a>
Fprojcpy
</h3>
<p class="pBody"><a name="wp1057253"> </a>
<code class="cCode">Fprojcpy</code> is similar to <code class="cCode">Fproj</code> but the desired fields are placed in a destination buffer. If updating buffers results in the removal of a pointer field (<code class="cCode">FLD_PTR</code>), the memory area referenced by the pointer is not modified or freed.
</p>
<a name="wp1057254"> </a><div class="pPreformatted"><pre>int<br />Fprojcpy(FBFR *<code class="cCodeEmphasis">dest</code>, FBFR *<code class="cCodeEmphasis">src</code>, FLDID *<code class="cCodeEmphasis">fieldid</code>)</pre></div><p class="pBody"><a name="wp1057255"> </a>
Any fields in the destination buffer are first deleted and the results of the projection on the source buffer are copied into the destination buffer. Using the above example, the following code places the results of the projection in the destination buffer:
</p>
<a name="wp1057256"> </a><div class="pPreformatted"><pre>if(Fprojcpy(dest, src, fieldid) &lt; 0)<br />       F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057257"> </a>
The entries in the array of field identifiers may be rearranged; if the entries are not in numeric order, the field identifier array is sorted.
</p>
<p class="pBody"><a name="wp1063028"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fprojcpy,&#160;Fprojcpy32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057259"> </a>
Fupdate
</h3>
<p class="pBody"><a name="wp1057260"> </a>
<code class="cCode">Fupdate</code> updates the destination buffer with the field values in the source buffer. 
</p>
<a name="wp1057261"> </a><div class="pPreformatted"><pre>int<br />Fupdate(FBFR *<code class="cCodeEmphasis">dest</code>, FBFR *<code class="cCodeEmphasis">src</code>)</pre></div><p class="pBody"><a name="wp1057262"> </a>
For fields that match on field ID/occurrence, the field value is updated in the destination buffer with the value in the source buffer (like <code class="cCode">Fjoin</code>). Fields on the destination buffer that have no corresponding field on the source buffer are left untouched (like <code class="cCode">Fojoin</code>). Fields on the source buffer that have no corresponding field on the destination buffer are added to the destination buffer (like <code class="cCode">Fconcat</code>). Consider the following example:
</p>
<a name="wp1057263"> </a><div class="pPreformatted"><pre>if(Fupdate(dest,src) &lt; 0)<br />     F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057264"> </a>
If the <code class="cCode">src</code> buffer has fields A, C, and D, and the <code class="cCode">dest</code> buffer has fields A, B, and two occurrences of C, the updated destination buffer contains: the source field value A, the destination field value B, the source field value C, the second destination field value C, and the source field value D.
</p>
<p class="pBody"><a name="wp1057265"> </a>
For pointers, <code class="cCode">Fupdate32</code> stores the pointer value. The buffer pointed to by a <code class="cCode">FLD_PTR</code> field must be allocated using the <a href="../rf3c/rf3c.html">tpalloc(3c)</a> call. For embedded FML32 buffers, <code class="cCode">Fupdate32</code> stores the entire <code class="cCode">FLD_FML32</code> field value, except the index.
</p>
<p class="pBody"><a name="wp1075712"> </a>
For embedded VIEW32 buffers, <code class="cCode">Fupdate32</code> stores a pointer to a structure of type <code class="cCode">FVIEWFLD</code>, which contains <code class="cCode">vflags</code> (a flags field, currently unused and set to <code class="cCode">0</code>), <code class="cCode">vname</code> (a character array containing the view name), and <code class="cCode">data</code> (a pointer to the view data stored as a C structure). The application provides the <code class="cCode">vname</code> and <code class="cCode">data</code> to <code class="cCode">Fupdate32</code>. The <code class="cCode">FVIEWFLD</code> structure is as follows:
</p>
<a name="wp1057266"> </a><div class="pPreformatted"><pre><code class="cCode">typedef struct { <br />     TM32U vflags;                /* flags - currently unused */ <br />     char vname[FVIEWNAMESIZE+1]; /* name of view */ <br />     char *data;                  /* pointer to view structure */ <br />} FVIEWFLD;</code></pre></div><p class="pBody"><a name="wp1063038"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fupdate,&#160;Fupdate32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1057268"> </a>
VIEWS Functions
</h2><h3 class="pHeading2"><a name="wp1057269"> </a>
Fvftos
</h3>
<p class="pBody"><a name="wp1057270"> </a>
This function transfers data from a fielded buffer to a C structure using a specified view description. 
</p>
<a name="wp1057271"> </a><div class="pPreformatted"><pre>int<br />Fvftos(FBFR *<code class="cCodeEmphasis">fbfr</code>, char *<code class="cCodeEmphasis">cstruct</code>, char *<code class="cCodeEmphasis">view</code>)</pre></div><p class="pBody"><a name="wp1057272"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057273"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057274"> </a><code class="cCodeEmphasis">cstruct</code> is a pointer to a structure.</li>
<li><a name="wp1057275"> </a><code class="cCode">view</code> is a pointer to a view name string.</li>
</ul></div>
<p class="pBody"><a name="wp1057276"> </a>
If the named view is not found, <code class="cCode">Fvftos</code> returns <code class="cCode">-1</code>, and <code class="cCode">Ferror</code> is set to <code class="cCode">FBADVIEW</code>.
</p>
<p class="pBody"><a name="wp1057277"> </a>
When data is being transferred from a fielded buffer to a C structure, the following rules apply: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057278"> </a>If a field in the fielded buffer is not mapped to a C structure member, the field is ignored.</li>
<li><a name="wp1057279"> </a>If a field is not in the fielded buffer, but appears in the view description and is mapped to a structure member, the corresponding null value is copied into the member.</li>
<li><a name="wp1057280"> </a>If a field in the fielded buffer contains data of type <code class="cCode">string</code> or <code class="cCode">carray</code>, characters are copied into the structure up to the size of the mapped structure member (that is, source values that are too long are truncated). If the source value is shorter than the mapped structure member, the remainder of the member value is padded with null (0) characters. String values are always terminated with a null character (even if this means truncating the value).</li>
<li><a name="wp1057281"> </a>If the number of occurrences of a field in the buffer is equal to the number of mapped structure members, then the fielded data is copied into the C structure.</li>
<li><a name="wp1057282"> </a>If the number of occurrences of a field in the buffer is greater than the number of mapped structure members, then the fielded data is ignored.</li>
<li><a name="wp1057283"> </a>If the number of occurrences of a field in the buffer is less than the number of mapped structure members, then the extra members are assigned the corresponding null value.</li>
</ul></div>
<p class="pBody"><a name="wp1057284"> </a>
For example, the following code puts <code class="cCode">string1</code> into <code class="cCode">cust.action[0]</code> and <code class="cCode">abc</code> into <code class="cCode">cust.bug[0]</code>. All other members in the <code class="cCode">cust</code> structure should contain null values.
</p>
<a name="wp1060821"> </a><div class="pPreformatted"><pre>#include &lt;stdio.h&gt;<br />#include &quot;fml.h&quot;<br />#include &quot;custdb.flds.h&quot;<br />#include &quot;custdb.h&quot;<br />struct custdb cust;<br />FBFR *fbfr;<br />. . .<br />fbfr = Falloc(800,1000);<br />Fvinit((char *)&amp;cust,&quot;custdb&quot;);    /* initialize cust */<br />str = &quot;string1&quot;;<br />Fadd(fbfr,ACTION,str,(FLDLEN)8);<br />str = &quot;abc&quot;;<br />Fadd(fbfr,BUG_CURS,str,(FLDLEN)4);<br />Fvftos(fbfr,(char *)&amp;cust,&quot;custdb&quot;);<br />. . .</pre></div><p class="pBody"><a name="wp1060827"> </a>
View <code class="cCode">custdb</code> is defined in <a href="fml06.html#wp1003954">VIEWS Examples</a>.
</p>
<p class="pBody"><a name="wp1063052"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fvftos,&#160;Fvftos32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057287"> </a>
Fvstof
</h3>
<p class="pBody"><a name="wp1057288"> </a>
This function transfers data from a C structure to a fielded buffer using a specified view description.
</p>
<a name="wp1057289"> </a><div class="pPreformatted"><pre>int<br />Fvstof(FBFR *<code class="cCodeEmphasis">fbfr</code>, char *<code class="cCodeEmphasis">cstruct</code>, int <code class="cCodeEmphasis">mode</code>, char *<code class="cCodeEmphasis">view</code>)</pre></div><p class="pBody"><a name="wp1057290"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057291"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057292"> </a><code class="cCodeEmphasis">cstruct</code> is a pointer to a structure.</li>
<li><a name="wp1057293"> </a><code class="cCodeEmphasis">mode</code> is one of the following: <code class="cCode">FUPDATE</code>, <code class="cCode">FJOIN</code>, <code class="cCode">FOJOIN</code>, or <code class="cCode">FCONCAT</code>.</li>
<li><a name="wp1057294"> </a><code class="cCodeEmphasis">view</code> is a pointer to a view name string.</li>
</ul></div>
<p class="pBody"><a name="wp1057298"> </a>
The transfer process obeys the rules listed under the FML function corresponding to the <code class="cCode">mode</code> parameter: <a href="fml05.html#wp1057259"><code class="cCode">Fupdate</code></a>, <a href="fml05.html#wp1057231"><code class="cCode">Fjoin</code></a>, <a href="fml05.html#wp1057239"><code class="cCode">Fojoin</code></a>, or <a href="fml05.html#wp1057222"><code class="cCode">Fconcat</code></a>.
</p>
<p class="pBody"><a name="wp1057300"> </a>
If the named view is not found, <code class="cCode">Fvstof</code> returns <code class="cCode">-1</code>, and <code class="cCode">Ferror</code> is set to <code class="cCode">FBADVIEW</code>.
</p>
<a name="wp1057301"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Null values are not transferred from a structure member to a fielded buffer. That is, during a structure-to-field transfer, if a structure member contains the (default or user-specified) null value defined for that member, the member is ignored.</td>
</tr>
</table>

<p class="pBody"><a name="wp1063069"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fvftos,&#160;Fvftos32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057302"> </a>
Fvnull
</h3>
<p class="pBody"><a name="wp1057303"> </a>
<code class="cCode">Fvnull</code> is used to determine whether an occurrence in a C structure contains the null value for that field. 
</p>
<a name="wp1057304"> </a><div class="pPreformatted"><pre>int<br />Fvnull(char *<code class="cCodeEmphasis">cstruct</code>, char *<code class="cCodeEmphasis">cname</code>, FLDOCC <code class="cCodeEmphasis">oc</code>, char *<code class="cCodeEmphasis">view</code>)</pre></div><p class="pBody"><a name="wp1057305"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057306"> </a><code class="cCodeEmphasis">cstruct</code> is a pointer to a structure.</li>
<li><a name="wp1057307"> </a><code class="cCodeEmphasis">cname</code> is a pointer to the name of a structure member.</li>
<li><a name="wp1057308"> </a><code class="cCodeEmphasis">oc</code> is the index to a particular element.</li>
<li><a name="wp1057309"> </a><code class="cCodeEmphasis">view</code> is a pointer to a view name string.</li>
</ul></div>
<p class="pBody"><a name="wp1057310"> </a>
<code class="cCode">Fvnull</code> returns: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057311"> </a><code class="cCode">1</code> if an occurrence is null</li>
<li><a name="wp1057312"> </a><code class="cCode">0</code> if an occurrence is not null</li>
<li><a name="wp1100343"> </a><code class="cCode">-1</code> if an error occurred</li>
</ul></div>
<p class="pBody"><a name="wp1100347"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fvnull,&#160;Fvnull32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1059467"> </a>
Fvsinit
</h3>
<p class="pBody"><a name="wp1057315"> </a>
This function initializes all elements in a C structure to their appropriate null value. 
</p>
<a name="wp1057316"> </a><div class="pPreformatted"><pre>int<br />Fvsinit(char *<code class="cCodeEmphasis">cstruct</code>, char *<code class="cCodeEmphasis">view</code>)</pre></div><p class="pBody"><a name="wp1057317"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057318"> </a><code class="cCodeEmphasis">cstruct</code> is a pointer to a structure.</li>
<li><a name="wp1057319"> </a><code class="cCodeEmphasis">view</code> is a pointer to a view name string.</li>
</ul></div>
<p class="pBody"><a name="wp1063098"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fvsinit,&#160;Fvsinit32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057320"> </a>
Fvopt
</h3>
<p class="pBody"><a name="wp1057321"> </a>
This function allows users to change flag options at run time.
</p>
<a name="wp1057322"> </a><div class="pPreformatted"><pre>int<br />Fvopt(char *<code class="cCodeEmphasis">cname,</code> int <code class="cCodeEmphasis">option,</code> char *<code class="cCodeEmphasis">view</code>)</pre></div><p class="pBody"><a name="wp1057323"> </a>
Here:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057324"> </a><code class="cCodeEmphasis">cname</code> is the name of a structure member.</li>
<li><a name="wp1057325"> </a><code class="cCodeEmphasis">option</code> is one of the options listed below.</li>
<li><a name="wp1057326"> </a><code class="cCodeEmphasis">view</code> is a pointer to a view name string.</li>
</ul></div>
<p class="pBody"><a name="wp1057327"> </a>
The following list describes possible values for the <code class="cCodeEmphasis">option</code> parameter.
</p>
<h4 class="pDefTerm"><a name="wp1057328"> </a>
<code class="cCode">F_FTOS</code> 
</h4><div class="pDefPara"><a name="wp1057329"> </a>
Allows one-way mapping from fielded buffers to C structures. Similar to the <code class="cCode">S</code> option in view descriptions.
</div>
<h4 class="pDefTerm"><a name="wp1057330"> </a>
<code class="cCode">F_STOF</code> 
</h4><div class="pDefPara"><a name="wp1057331"> </a>
Allows one-way mapping from C structures to fielded buffers. Similar to the <code class="cCode">F</code> option in view descriptions.
</div>
<h4 class="pDefTerm"><a name="wp1057332"> </a>
<code class="cCode">F_BOTH</code> 
</h4><div class="pDefPara"><a name="wp1057333"> </a>
Allows two-way mapping between C structures and fielded buffers.
</div>
<h4 class="pDefTerm"><a name="wp1057334"> </a>
<code class="cCode">F_OFF</code> 
</h4><div class="pDefPara"><a name="wp1057335"> </a>
Turns off mapping of the specified member. Similar to the <code class="cCode">N</code> option in view descriptions.
</div>
<p class="pBody"><a name="wp1057336"> </a>
Note that changes to view descriptions are not permanent. They are guaranteed only until another view description is accessed.
</p>
<p class="pBody"><a name="wp1063116"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fvopt,&#160;Fvopt32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057337"> </a>
Fvselinit
</h3>
<p class="pBody"><a name="wp1057338"> </a>
This function initializes an individual member of a C structure to its appropriate null value. It sets the ACM of the element to 0, if the <code class="cCode">C</code> flag is used in the view file; it sets the ALMs to the length of the associated null value, if the <code class="cCode">L</code> flag is used in the view file. 
</p>
<a name="wp1057339"> </a><div class="pPreformatted"><pre>int<br />Fvselinit(char *<code class="cCodeEmphasis">cstruct</code>, char *<code class="cCodeEmphasis">cname</code>, char *<code class="cCodeEmphasis">view</code>)</pre></div><p class="pBody"><a name="wp1057340"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057341"> </a><code class="cCodeEmphasis">cstruct</code> is a pointer to a structure.</li>
<li><a name="wp1057342"> </a><code class="cCodeEmphasis">cname</code> is a pointer to the name of a structure member.</li>
<li><a name="wp1057343"> </a><code class="cCodeEmphasis">view</code> is a pointer to a view name string.</li>
</ul></div>
<p class="pBody"><a name="wp1063205"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fvselinit,&#160;Fvselinit32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1060611"> </a>
Conversion Functions
</h2><p class="pBody"><a name="wp1057349"> </a>
FML provides a set of routines that perform data conversion upon reading or writing a fielded buffer.
</p>
<p class="pBody"><a name="wp1057350"> </a>
Generally, the functions behave like their non-conversion counterparts, except that they provide conversion from a user type to the native field type when writing to a buffer, and from the native type to a user type when reading from a buffer.
</p>
<p class="pBody"><a name="wp1057351"> </a>
The native type of a field is the type specified for it in its field table entry and encoded in its field identifier. (The only exception to this rule is <code class="cCode">CFfindocc</code>, which, although it is a read operation, converts from the user-specified type to the native type before calling <code class="cCode">Ffindocc</code>.) The function names are the same as their non-conversion FML counterparts except that they include a &#8220;C&#8221; prefix.
</p>
<p class="pBody"><a name="wp1057355"> </a>
The following field types are not supported for conversion functions: pointers (<code class="cCode">FLD_PTR</code>), embedded FML32 buffers (<code class="cCode">FLD_FML32</code>), and embedded VIEW32 buffers (<code class="cCode">FLD_VIEW32</code>). If one of these field types is encountered during the execution of an FML32 conversion function, <code class="cCode">Ferror</code> is set to <code class="cCode">FEBADOP</code>.
</p>
<h3 class="pHeading2"><a name="wp1057356"> </a>
CFadd
</h3>
<p class="pBody"><a name="wp1057357"> </a>
The <code class="cCode">CFadd</code> function adds a user-supplied item to a buffer creating a new field occurrence within the buffer.
</p>
<a name="wp1057358"> </a><div class="pPreformatted"><pre>int<br />CFadd(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, char *<code class="cCodeEmphasis">value</code>, FLDLEN <code class="cCodeEmphasis">len</code>, int <code class="cCodeEmphasis">type</code>)</pre></div><p class="pBody"><a name="wp1057359"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057360"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057361"> </a><code class="cCodeEmphasis">fieldid</code> is the field identifier of the field to be added.</li>
<li><a name="wp1057362"> </a><code class="cCodeEmphasis">value</code> is a pointer to the value to be added.</li>
<li><a name="wp1057363"> </a><code class="cCodeEmphasis">len</code> is the length of the value if its type is <code class="cCode">FLD_CARRAY</code>.</li>
<li><a name="wp1057364"> </a><code class="cCodeEmphasis">type</code> is the type of the value.</li>
</ul></div>
<p class="pBody"><a name="wp1057365"> </a>
Before the field addition, the data item is converted from a user-supplied type to the type specified in the field table as the fielded buffer storage type of the field. If the source type is <code class="cCode">FLD_CARRAY</code> (character array), the length argument should be set to the length of the array. Consider the following example:
</p>
<a name="wp1057366"> </a><div class="pPreformatted"><pre>if(CFadd(fbfr,ZIP,&quot;12345&quot;,(FLDLEN)0,FLD_STRING) &lt; 0)<br />      F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057367"> </a>
If the <code class="cCode">ZIP</code> (zip code) field were stored in a fielded buffer as a long integer, the function would convert &#8220;12345&#8221; to a long integer representation, before adding it to the fielded buffer pointed to by <code class="cCode">fbfr</code> (note that the field value length is given as 0 since the function can determine it; the length is needed only for type <code class="cCode">FLD_CARRAY</code>). The following code puts the same value into the fielded buffer, but does so by presenting it as a long, instead of as a string: 
</p>
<a name="wp1057368"> </a><div class="pPreformatted"><pre>long zipval;<br />. . .<br />zipval = 12345;<br />if(CFadd(fbfr,ZIP,&amp;zipval,(FLDLEN)0,FLD_LONG) &lt; 0)<br />      F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057369"> </a>
Note that the value must first be put into a variable, since C does not permit the construct &amp;12345L. <code class="cCode">CFadd</code> returns <code class="cCode">1</code> on success, and <code class="cCode">-1</code> on error, in which case <code class="cCode">Ferror</code> is set appropriately.
</p>
<p class="pBody"><a name="wp1063540"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">CFadd,&#160;CFadd32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057370"> </a>
CFchg
</h3>
<p class="pBody"><a name="wp1057371"> </a>
The function <code class="cCode">CFchg</code> acts like <a href="fml05.html#wp1057356"><code class="cCode">CFadd</code></a>, except that it changes the value of a field (after conversion of the supplied value).
</p>
<a name="wp1057372"> </a><div class="pPreformatted"><pre>int<br />CFchg(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, FLDOCC <code class="cCodeEmphasis">oc</code>, char *<code class="cCodeEmphasis">value</code>, FLDLEN <code class="cCodeEmphasis">len</code>, int <code class="cCodeEmphasis">type</code>)</pre></div><p class="pBody"><a name="wp1057373"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057374"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057375"> </a><code class="cCodeEmphasis">fieldid</code> is the field identifier of the field to be changed.</li>
<li><a name="wp1057376"> </a><code class="cCodeEmphasis">oc</code> is the occurrence number of the field to be changed.</li>
<li><a name="wp1057377"> </a><code class="cCodeEmphasis">value</code> is a pointer to the value to be added.</li>
<li><a name="wp1057378"> </a><code class="cCodeEmphasis">len</code> is the length of the value if its type is <code class="cCode">FLD_CARRAY</code>.</li>
<li><a name="wp1057379"> </a><code class="cCodeEmphasis">type</code> is the type of the value.</li>
</ul></div>
<p class="pBody"><a name="wp1057380"> </a>
For example, the following code changes the first occurrence (occurrence 0) of field <code class="cCode">ZIP</code> to the specified value, doing any needed conversion:
</p>
<a name="wp1057381"> </a><div class="pPreformatted"><pre>FLDOCC occurrence;<br />long zipval;<br />. . .<br />zipval = 12345;<br />occurrence = 0;<br />if(CFchg(fbfr,ZIP,occurrence,&amp;zipval,(FLDLEN)0,FLD_LONG) &lt; 0)<br />       F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057382"> </a>
If the specified occurrence is not found, then null occurrences are added to pad the buffer with multiple occurrences until the value can be added as the specified occurrence.
</p>
<p class="pBody"><a name="wp1063640"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">CFchg,&#160;CFchg32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057383"> </a>
CFget
</h3>
<p class="pBody"><a name="wp1057384"> </a>
<code class="cCode">CFget</code> is the conversion analog of <a href="fml05.html#wp1057125"><code class="cCode">Fget</code></a>. The difference is that it copies a converted value to the user-supplied buffer. 
</p>
<a name="wp1057385"> </a><div class="pPreformatted"><pre>int<br />CFget(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, FLDOCC <code class="cCodeEmphasis">oc</code>, char *<code class="cCodeEmphasis">buf</code>, FLDLEN *<code class="cCodeEmphasis">len</code>, int <code class="cCodeEmphasis">type</code>)</pre></div><p class="pBody"><a name="wp1057386"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057387"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057388"> </a><code class="cCodeEmphasis">fieldid</code> is the field identifier of the field to be retrieved.</li>
<li><a name="wp1057389"> </a><code class="cCodeEmphasis">oc</code> is the occurrence number of the field.</li>
<li><a name="wp1057390"> </a><code class="cCodeEmphasis">buf</code> is a pointer to the post-conversion buffer.</li>
<li><a name="wp1057391"> </a><code class="cCodeEmphasis">len</code> is the length of the value if its type is <code class="cCode">FLD_CARRAY</code>.</li>
<li><a name="wp1057392"> </a><code class="cCodeEmphasis">type</code> is the type of the value.</li>
</ul></div>
<p class="pBody"><a name="wp1057393"> </a>
Using the previous example, the following code gets the value that was just stored in the buffer (regardless of which format is being used) and converts it back to a long integer:
</p>
<a name="wp1057394"> </a><div class="pPreformatted"><pre>FLDLEN len;<br />. . .<br />len=sizeof(zipval);<br />if(CFget(fbfr,ZIP,occurrence,&amp;zipval,&amp;len,FLD_LONG) &lt; 0)<br />        F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057395"> </a>
If the length pointer is NULL, then the length of the value retrieved and converted is not returned.
</p>
<p class="pBody"><a name="wp1063650"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">CFget,&#160;CFget32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057396"> </a>
CFgetalloc
</h3>
<p class="pBody"><a name="wp1057397"> </a>
<code class="cCode">CFgetalloc</code> is like <a href="fml05.html#wp1057139"><code class="cCode">Fgetalloc</code></a>; you are responsible for freeing the space allocated with <code class="cCode">malloc</code> for the returned (converted) value with <code class="cCode">free</code>.
</p>
<a name="wp1057398"> </a><div class="pPreformatted"><pre>char *<br />CFgetalloc(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, FLDOCC <code class="cCodeEmphasis">oc</code>, int <code class="cCodeEmphasis">type</code>, FLDLEN *<code class="cCodeEmphasis">extralen</code>)</pre></div><p class="pBody"><a name="wp1057399"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057400"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057401"> </a><code class="cCodeEmphasis">fieldid</code> is the field identifier of the field to be converted.</li>
<li><a name="wp1057402"> </a><code class="cCodeEmphasis">oc</code> is the occurrence number of the field.</li>
<li><a name="wp1057403"> </a><code class="cCodeEmphasis">type</code> is the type to which the value is converted.</li>
<li><a name="wp1057404"> </a><code class="cCodeEmphasis">extralen</code> on calling the function is a pointer to the extra allocation amount; on return, it is a pointer to the size of the total allocated area.</li>
</ul></div>
<p class="pBody"><a name="wp1057405"> </a>
In the declaration above, the return value to <code class="cCode">CFgetalloc</code> is shown as a character pointer data type (<code class="cCode">char*</code> in C). The actual type of the pointer returned is the same as the type of the value to which it points.
</p>
<p class="pBody"><a name="wp1057406"> </a>
The previously stored value can be retrieved into space allocated automatically for you by the following code:
</p>
<a name="wp1057407"> </a><div class="pPreformatted"><pre>char *value;<br />FLDLEN extra;<br />. . .<br />extra = 25;<br />if((value=CFgetalloc(fbfr,ZIP,0,FLD_LONG,&amp;extra)) == NULL)<br /> F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057408"> </a>
The value <code class="cCode">extra</code> in the function call indicates that the function should allocate an extra 25 bytes over the amount of space sufficient for the retrieved value. The total amount of space allocated is returned in this variable.
</p>
<p class="pBody"><a name="wp1063764"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">CFgetalloc,&#160;CFgetalloc32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057409"> </a>
CFfind
</h3>
<p class="pBody"><a name="wp1057410"> </a>
<code class="cCode">CFfind</code> returns a pointer to a converted value of the desired field.
</p>
<a name="wp1057411"> </a><div class="pPreformatted"><pre>char *<br />CFfind(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, FLDOCC <code class="cCodeEmphasis">oc</code>, FLDLEN <code class="cCodeEmphasis">len</code>, int <code class="cCodeEmphasis">type</code>)</pre></div><p class="pBody"><a name="wp1057412"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057413"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057414"> </a><code class="cCodeEmphasis">fieldid</code> is the field identifier of the field to be retrieved.</li>
<li><a name="wp1057415"> </a><code class="cCodeEmphasis">oc</code> is the occurrence number of the field.</li>
<li><a name="wp1057416"> </a><code class="cCodeEmphasis">len</code> is the length of the post-conversion value.</li>
<li><a name="wp1057417"> </a><code class="cCodeEmphasis">type</code> is the type to which the value is converted.</li>
</ul></div>
<p class="pBody"><a name="wp1057418"> </a>
In the previous declaration the return value to <code class="cCode">CFfind</code> is shown as a character pointer data type (<code class="cCode">char*</code> in C). The actual type of the pointer returned is the same as the type of the value to which it points.
</p>
<p class="pBody"><a name="wp1057419"> </a>
Like <a href="fml05.html#wp1057083"><code class="cCode">Ffind</code></a>, this pointer should be considered &#8220;readonly.&#8221; For example, the following code returns a pointer to a <code class="cCode">long</code> containing the value of the first occurrence of the <code class="cCode">ZIP</code> field: 
</p>
<a name="wp1057420"> </a><div class="pPreformatted"><pre>char *CFfind;<br />FLDLEN len;<br />long *value;<br />. . .<br />if((value=(long *)CFfind(fbfr,ZIP,occurrence,&amp;len,FLD_LONG))== NULL)<br />   F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057421"> </a>
If the length pointer is NULL, then the length of the value found is not returned. Unlike <code class="cCode">Ffind</code>, the value returned is guaranteed to be properly aligned for the corresponding user-specified type.
</p>
<a name="wp1057422"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The duration of the validity of the pointer returned by <code class="cCode">CFfind</code> is guaranteed only until the next buffer operation, even if it is non-destructive, since the converted value is retained in a single private buffer. This differs from the value returned by <code class="cCode">Ffind</code>, which is guaranteed until the next modification of the buffer.</td>
</tr>
</table>

<p class="pBody"><a name="wp1063788"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">CFfind,&#160;CFfind32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057423"> </a>
CFfindocc
</h3>
<p class="pBody"><a name="wp1057424"> </a>
<code class="cCode">CFfindocc</code> looks at occurrences of the specified field on the buffer and returns the occurrence number of the first field occurrence that matches the user-specified field value after it has been converted to the type of the field identifier.
</p>
<a name="wp1057425"> </a><div class="pPreformatted"><pre>FLDOCC<br />CFfindocc(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDID <code class="cCodeEmphasis">fieldid</code>, char *<code class="cCodeEmphasis">value</code>, FLDLEN <code class="cCodeEmphasis">len</code>, int <code class="cCodeEmphasis">type</code>)</pre></div><p class="pBody"><a name="wp1057426"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057427"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057428"> </a><code class="cCodeEmphasis">fieldid</code> is the field identifier of the field to be retrieved.</li>
<li><a name="wp1057429"> </a><code class="cCodeEmphasis">value</code> is a pointer to the unconverted matching value.</li>
<li><a name="wp1057430"> </a><code class="cCodeEmphasis">len</code> is the length of the unconverted matching value.</li>
<li><a name="wp1057431"> </a><code class="cCodeEmphasis">type</code> is the type of the unconverted matching value.</li>
</ul></div>
<p class="pBody"><a name="wp1057432"> </a>
For example, the following code converts the string to the type of <code class="cCode">fieldid</code> <code class="cCode">ZIP</code> (possibly a <code class="cCode">long</code>) and sets <code class="cCode">oc</code> to the occurrence for the specified zip code:
</p>
<a name="wp1057433"> </a><div class="pPreformatted"><pre>#include &quot;fldtbl.h&quot;<br />FBFR *fbfr;<br />FLDOCC oc;<br />char zipvalue[20];<br />. . .<br />strcpy(zipvalue,&quot;123456&quot;);<br />if((oc=CFfindocc(fbfr,ZIP,zipvalue,0,FLD_STRING)) &lt;  0)<br />        F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057434"> </a>
If the field value is not found, <code class="cCode">-1</code> is returned.
</p>
<a name="wp1057435"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Because <code class="cCode">CFfindocc</code> converts the user-specified value to the native field type before examining the field values, regular expressions work only when the user-specified type and the native field type are both <code class="cCode">FLD_STRING</code>. Thus, <code class="cCode">CFfindocc</code> has no utility with regular expressions.</td>
</tr>
</table>

<p class="pBody"><a name="wp1063827"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">CFf&#160;indocc,&#160;CFfindocc32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1057437"> </a>
Converting Strings
</h2><p class="pBody"><a name="wp1057438"> </a>
The following set of functions is provided to handle the case of conversion to and from a user type of <code class="cCode">FLD_STRING</code>:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1100415"> </a><a href="../rf3fml/rf3fml.html">Fadds,&#160;Fadds32(3fml)</a></li>
<li><a name="wp1100416"> </a><a href="../rf3fml/rf3fml.html">Fchgs,&#160;Fchgs32(3fml)</a></li>
<li><a name="wp1100420"> </a><a href="../rf3fml/rf3fml.html">Ffinds,&#160;Ffinds32(3fml)</a></li>
<li><a name="wp1063943"> </a><a href="../rf3fml/rf3fml.html">Fgets,&#160;Fgets32(3fml)</a></li>
<li><a name="wp1063969"> </a><a href="../rf3fml/rf3fml.html">Fgetsa,&#160;Fgetsa32(3fml)</a></li>
</ul></div>
<p class="pBody"><a name="wp1063892"> </a>
These functions call their non-string-function counterparts, providing a <code class="cCode">type</code> of <code class="cCode">FLD_STRING</code>, and a <code class="cCode">len</code> of 0. Note that the duration of the validity of the pointer returned by <code class="cCode">Ffinds</code> is the same as that described for <code class="cCode">CFfind</code>.
</p>
<p class="pBody"><a name="wp1057442"> </a>
For descriptions of these functions, see <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057443"> </a>
Ftypcvt
</h3>
<p class="pBody"><a name="wp1057444"> </a>
The functions <a href="fml05.html#wp1057356"><code class="cCode">CFadd</code></a>, <a href="fml05.html#wp1057370"><code class="cCode">CFchg</code></a>, <a href="fml05.html#wp1057383"><code class="cCode">CFget</code></a>, <a href="fml05.html#wp1057396"><code class="cCode">CFgetalloc</code></a>, and <a href="fml05.html#wp1057409"><code class="cCode">CFfind</code></a> use the function <code class="cCode">Ftypcvt</code> to perform the appropriate data conversion. The <code class="cCode">Ftypcvt32</code> function fails for the <code class="cCode">FLD_PTR</code>, <code class="cCode">FLD_FML32</code>, and <code class="cCode">FLD_VIEW32</code> field types. The synopsis of <code class="cCode">Ftypcvt</code> usage is as follows (it does not follow the parameter order conventions).
</p>
<a name="wp1057445"> </a><div class="pPreformatted"><pre>char *<br />Ftypcvt(FLDLEN *<code class="cCodeEmphasis">tolen</code>, int <code class="cCodeEmphasis">totype</code>, char *<code class="cCodeEmphasis">fromval</code>, int <code class="cCodeEmphasis">fromtype</code>, FLDLEN <code class="cCodeEmphasis">fromlen</code>)</pre></div><p class="pBody"><a name="wp1057446"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057447"> </a><code class="cCodeEmphasis">tolen</code> is a pointer to the length of the converted value.</li>
<li><a name="wp1057448"> </a><code class="cCodeEmphasis">totype</code> is the type to which to convert.</li>
<li><a name="wp1057449"> </a><code class="cCodeEmphasis">fromval</code> is a pointer to the value from which to convert.</li>
<li><a name="wp1057450"> </a><code class="cCodeEmphasis">fromtype</code> is the type from which to convert.</li>
<li><a name="wp1057451"> </a><code class="cCodeEmphasis">fromlen</code> is the length of the from value if the from type is <code class="cCode">FLD_CARRAY</code>.</li>
</ul></div>
<p class="pBody"><a name="wp1057452"> </a>
<code class="cCode">Ftypcvt</code> converts from the value <code class="cCode">*fromval</code>, which has type <code class="cCode">fromtype</code>, and length <code class="cCode">fromlen</code> if <code class="cCode">fromtype</code> is type <code class="cCode">FLD_CARRAY</code> (otherwise <code class="cCode">fromlen</code> is inferred from <code class="cCode">fromtype</code>), to a value of type <code class="cCode">totype</code>. <code class="cCode">Ftypcvt</code> returns a pointer to the converted value, and sets <code class="cCode">*tolen</code> to the converted length, upon success. Upon failure, <code class="cCode">Ftypcvt</code> returns NULL. Consider the following example, in which the <code class="cCode">CFchg</code> function is used:
</p>
<a name="wp1057453"> </a><div class="pPreformatted"><pre>CFchg(fbfr,fieldid,oc,value,len,type)<br />FBFR *fbfr;             /* fielded buffer */<br />FLDID fieldid;          /* field to be changed */<br />FLDOCC oc;              /* occurrence of field to be changed */<br />char *value;            /* location of new value */<br />FLDLEN len;             /* length of new value */<br />int type;               /* type of new value */<br />{<br /> char *convloc;         /* location of post-conversion value */<br /> FLDLEN convlen;        /* length of post-conversion value */<br /> extern char *Ftypcvt;<br /> <br />         /* convert value to fielded buffer type */<br />  if((convloc = Ftypcvt(&amp;convlen,FLDTYPE(fieldid),value,type,len)) == NULL)<br />                return(-1);<br /> <br />  if(Fchg(fbfr,fieldid,oc,convloc,convlen) &lt; 0)<br />                return(-1);<br />  return(1);<br />} </pre></div><p class="pBody"><a name="wp1057454"> </a>
The user may call <code class="cCode">Ftypcvt</code> directly to do field value conversion without adding or modifying a fielded buffer.
</p>
<p class="pBody"><a name="wp1063993"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Ftypcvt,&#160;Ftypcvt32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057456"> </a>
Conversion Rules
</h3>
<p class="pBody"><a name="wp1057457"> </a>
In the following list of conversion rules, <code class="cCode">oldval</code> represents a pointer to the data item being converted, and <code class="cCode">newval</code>, a pointer to the post-conversion value.
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057458"> </a>When both types are identical, <code class="cCode">*newval</code> is identical to <code class="cCode">*oldval</code>.</li>
<li><a name="wp1057459"> </a>When both types are numeric, that is, if they are <code class="cCode">long</code>, <code class="cCode">short</code>, <code class="cCode">float</code>, or <code class="cCode">double</code>, the conversion is done by the C assignment operator, with proper type casting. For example, a <code class="cCode">short</code> is converted to a <code class="cCode">float</code> through the following code: </li>
<a name="wp1057460"> </a><div class="pPreformattedRelative"><pre>*((float *)newval) = *((short *) oldval)</pre></div><li><a name="wp1057461"> </a>When a numeric is being converted to a string, an appropriate <code class="cCode">sprintf</code> is used. For example, a <code class="cCode">short</code> is converted to a <code class="cCode">string</code> through the following code:</li>
<a name="wp1057462"> </a><div class="pPreformattedRelative"><pre>sprintf(newval,&quot;%d&quot;,*((short *)oldval))</pre></div><li><a name="wp1057463"> </a>When a string is being converted to a numeric, the appropriate function (for example, <code class="cCode">atof</code>, <code class="cCode">atol</code>) is used, with the result assigned to a typecasted receiving location, as shown in the following example:</li>
<a name="wp1057464"> </a><div class="pPreformattedRelative"><pre>*((float *)newval) = atof(oldval)</pre></div><li><a name="wp1057465"> </a>When a type <code class="cCode">char</code> is being converted to any numeric type, or when a numeric type is being converted to a <code class="cCode">char</code>, the <code class="cCode">char</code> is considered to be a &#8220;shorter <code class="cCode">short</code>.&#8221; For example, to convert a <code class="cCode">char</code> to a <code class="cCode">float</code>, use the method shown in the following code:</li>
<a name="wp1057466"> </a><div class="pPreformattedRelative"><pre>*((float *)newval) = *((char *)oldval)</pre></div><p class="pBodyRelative"><a name="wp1057467"> </a>
To convert a <code class="cCode">short</code> to a <code class="cCode">char</code>, use the method shown in the next example:
</p>
<a name="wp1057468"> </a><div class="pPreformattedRelative"><pre>*((char *)newval) = *((short *)oldval)</pre></div><li><a name="wp1057469"> </a>A <code class="cCode">char</code> is converted to a <code class="cCode">string</code> by appending a NULL character. In this regard, a <code class="cCode">char</code> is not a &#8220;shorter <code class="cCode">short</code>.&#8221; If it were, assignment would be done by converting it to a <code class="cCode">short</code>, and then converting the <code class="cCode">short</code> to a <code class="cCode">string</code> via <code class="cCode">sprintf</code>. In the same sense, a <code class="cCode">string</code> is converted to a <code class="cCode">char</code> by assigning the first character of the <code class="cCode">string</code> to the character.</li>
<li><a name="wp1057470"> </a>The <code class="cCode">carray</code> type is used to store an arbitrary sequence of bytes. In this sense, it can encode any user data type. Nevertheless, the following conversions are specified for <code class="cCode">carray</code> types:</li>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1057471"> </a>A <code class="cCode">carray</code> is converted to a <code class="cCode">string</code> by appending the NULL byte to the <code class="cCode">carray</code>. In this sense, a <code class="cCode">carray</code> can be used to store a <code class="cCode">string</code>, less the overhead of the trailing NULL. (This approach does not always save space, since fields are aligned on short boundaries within a fielded buffer.) A <code class="cCode">string</code> is converted to a <code class="cCode">carray</code> by removing its terminating NULL byte.</li>
<li><a name="wp1057472"> </a>When a <code class="cCode">carray</code> is converted to any numeric, it is first converted to a <code class="cCode">string</code>, and the <code class="cCode">string</code> is then converted to a numeric. Likewise, a numeric is converted to a <code class="cCode">carray</code>, by first being converted to a <code class="cCode">string</code>, and then the <code class="cCode">string</code> is converted to a <code class="cCode">carray</code>.</li>
<li><a name="wp1057473"> </a>A <code class="cCode">carray</code> is converted to a <code class="cCode">char</code> by assigning the first character of the array to the <code class="cCode">char</code>. Likewise, a <code class="cCode">char</code> is converted to a <code class="cCode">carray</code> by assigning it as the first byte of the array, and setting the length of the array to 1.</li>
<p class="pBodyRelative"><a name="wp1057474"> </a>
Note that a <code class="cCode">carray</code> of length 1 and a <code class="cCode">char</code> have the following differences:
</p>
<li><a name="wp1057475"> </a>A <code class="cCode">char</code> has only the overhead of its associated <code class="cCode">fieldid</code>, while a <code class="cCode">carray</code> contains a length code, in addition to the associated <code class="cCode">fieldid</code>.</li>
<li><a name="wp1077719"> </a>A <code class="cCode">carray</code> is converted to a numeric by first becoming a <code class="cCode">string</code>, and then undergoing an <code class="cCode">atoi</code> call; a <code class="cCode">char</code> becomes a numeric by typecasting. For example, a <code class="cCode">char</code> with value ASCII 1&#8217; (decimal 49) converts to a <code class="cCode">short</code> of value 49; a <code class="cCode">carray</code> of length 1, with the single byte an ASCII 1&#8217; converts to a <code class="cCode">short</code> of value 1. Likewise a <code class="cCode">char</code> a&#8217; (decimal 97) converts to a <code class="cCode">short</code> of value 97; the <code class="cCode">carray</code> a&#8217; converts to a <code class="cCode">short</code> of value 0 (since <code class="cCode">atoi</code> (&#8220;<code class="cCode">a</code>&#8221;) produces a 0 result).</li>
</ul></div>
<li><a name="wp1057477"> </a>When converting to or from a <code class="cCode">dec_t</code> type, the associated conversion function as described in <code class="cCode">decimal</code>(3) is used (<code class="cCode">_gp_deccvasc</code>, <code class="cCode">_gp_deccvdbl</code>, <code class="cCode">_gp_deccvflt</code>, <code class="cCode">_gp_deccvint</code>, <code class="cCode">_gp_deccvlong</code>, <code class="cCode">_gp_dectoasc</code>, <code class="cCode">_gp_dectodbl</code>, <code class="cCode">_gp_dectoflt</code>, <code class="cCode">_gp_dectoint</code>, and <code class="cCode">_gp_dectolong</code>).</li>
</ul></div>
<p class="pBody"><a name="wp1057478"> </a>
The following table summarizes the conversion rules presented in this section.
</p>
<p class="pGraphic"><a name="wp1057679"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1057482table1057479"><caption><a name="wp1057482"> </a>
Table 5-2  Summary of Conversion Rules

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1057500"> </a>
src type
</div>
</th>
    <th colspan="8" rowspan="1"><div class="pCellHeading"><a name="wp1057502"> </a>
dest type
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057518"> </a>
<code class="cCode">-</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057520"> </a>
<code class="cCode">char</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057522"> </a>
<code class="cCode">short</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057524"> </a>
<code class="cCode">long</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057526"> </a>
<code class="cCode">float</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057528"> </a>
<code class="cCode">double</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057530"> </a>
<code class="cCode">string</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057532"> </a>
<code class="cCode">carray</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057534"> </a>
<code class="cCode">dec_t</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057536"> </a>
<code class="cCode">char</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057538"> </a>
<code class="cCode">-</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057540"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057542"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057544"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057546"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057548"> </a>
<code class="cCode">st[0]=c</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057550"> </a>
<code class="cCode">array[0]=c</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057552"> </a>
<code class="cCode">d</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057554"> </a>
<code class="cCode">short</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057556"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057558"> </a>
<code class="cCode">-</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057560"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057562"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057564"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057566"> </a>
<code class="cCode">sprintf</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057568"> </a>
<code class="cCode">sprintf</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057570"> </a>
<code class="cCode">d</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057572"> </a>
<code class="cCode">long</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057574"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057576"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057578"> </a>
<code class="cCode">-</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057580"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057582"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057584"> </a>
<code class="cCode">sprintf</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057586"> </a>
<code class="cCode">sprintf</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057588"> </a>
<code class="cCode">d</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057590"> </a>
<code class="cCode">float</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057592"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057594"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057596"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057598"> </a>
<code class="cCode">-</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057600"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057602"> </a>
<code class="cCode">sprintf</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057604"> </a>
<code class="cCode">sprintf</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057606"> </a>
<code class="cCode">d</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057608"> </a>
<code class="cCode">double</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057610"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057612"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057614"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057616"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057618"> </a>
<code class="cCode">-</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057620"> </a>
<code class="cCode">sprintf</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057622"> </a>
<code class="cCode">sprintf</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057624"> </a>
<code class="cCode">d</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057626"> </a>
<code class="cCode">string</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057628"> </a>
<code class="cCode">c=st[0]</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057630"> </a>
<code class="cCode">atoi</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057632"> </a>
<code class="cCode">atol</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057634"> </a>
<code class="cCode">atof</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057636"> </a>
<code class="cCode">atof</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057638"> </a>
<code class="cCode">-</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057640"> </a>
<code class="cCode">drop 0</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057642"> </a>
<code class="cCode">d</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057644"> </a>
<code class="cCode">carray</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057646"> </a>
<code class="cCode">c=array[0]</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057648"> </a>
<code class="cCode">atoi</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057650"> </a>
<code class="cCode">atol</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057652"> </a>
<code class="cCode">atof</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057654"> </a>
<code class="cCode">atof</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057656"> </a>
<code class="cCode">add 0</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057658"> </a>
<code class="cCode">-</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057660"> </a>
<code class="cCode">d</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057662"> </a>
<code class="cCode">dec_t</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057664"> </a>
<code class="cCode">d</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057666"> </a>
<code class="cCode">d</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057668"> </a>
<code class="cCode">d</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057670"> </a>
<code class="cCode">d</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057672"> </a>
<code class="cCode">d</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057674"> </a>
<code class="cCode">d</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057676"> </a>
<code class="cCode">d</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057678"> </a>
<code class="cCode">-</code>
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<p class="pBody"><a name="wp1057680"> </a>
The following table defines the entries listed in the previous table.
</p>
<p class="pGraphic"><a name="wp1057743"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1057684table1057681"><caption><a name="wp1057684"> </a>
Table 5-3  Meanings of Entries in the Summary of Conversion Rules

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1057688"> </a>
Entry
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1057690"> </a>
Meaning
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057692"> </a>
<code class="cCode">-</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057694"> </a>
<code class="cCode">src</code> and <code class="cCode">dest</code> are the same type; no conversion required
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057696"> </a>
<code class="cCode">cast</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057698"> </a>
Conversion done using C assignment with type casting
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057700"> </a>
<code class="cCode">sprintf</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057702"> </a>
Conversion done using <code class="cCode">sprintf</code> function
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057704"> </a>
<code class="cCode">atoi</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057706"> </a>
Conversion done using <code class="cCode">atoi</code> function
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057708"> </a>
<code class="cCode">atof</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057710"> </a>
Conversion done using <code class="cCode">atof</code> function
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057712"> </a>
<code class="cCode">atol</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057714"> </a>
Conversion done using <code class="cCode">atol</code> function
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057716"> </a>
<code class="cCode">add 0</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057718"> </a>
Conversion done by concatenating NULL byte
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057720"> </a>
<code class="cCode">drop 0</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057722"> </a>
Conversion done by dropping terminating NULL byte
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057724"> </a>
<code class="cCode">c=array[0]</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057726"> </a>
Character set to first byte of array
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057728"> </a>
<code class="cCode">array[0]=c</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057730"> </a>
First byte of array is set to character
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057732"> </a>
<code class="cCode">c=st[0]</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057734"> </a>
Character set to first byte of string
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057736"> </a>
<code class="cCode">st[0]=c</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057738"> </a>
First byte of string set to c
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057740"> </a>
<code class="cCode">d</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057742"> </a>
<code class="cCode">decimal</code>(3c) conversion function
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1084302"> </a>
Converting FLD_MBSTRING Fields
</h2><p class="pBody"><a name="wp1084303"> </a>
The following set of functions is provided to handle code-set encoding conversion of data in user type of <code class="cCode">FLD_MBSTRING</code>:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1084307"> </a><a href="../rf3fml/rf3fml.html">Fmbpack32(3fml)</a></li>
<li><a name="wp1084311"> </a><a href="../rf3fml/rf3fml.html">Fmbunpack32(3fml)</a></li>
<li><a name="wp1084315"> </a><a href="../rf3fml/rf3fml.html">tpconvfmb32(3fml)</a></li>
</ul></div>
<p class="pBody"><a name="wp1084324"> </a>
These functions prepare the encoding name and multibyte data information for an <code class="cCode">FLD_MBSTRING</code> field, extract the encoding name and multibyte data information from an <code class="cCode">FLD_MBSTRING</code> field, and convert the multibyte characters in an <code class="cCode">FLD_MBSTRING</code> field to a named target encoding. The following figure shows through example how encoding conversion works.
</p>
<div class="pFigureTitle"><a name="wp1087874"> </a>
Figure&#160;5-1  Encoding Conversion Using FML32 Buffers&#8212;Example
</div>

 
 <p class="pGraphic"><a name="wp1088000"> </a>
</p>
<div class="figure" align="left"><img src="wwimages/fml-5-1-1.gif" height="503" width="469" alt="Encoding Conversion Using FML32 Buffers&#8212;Example" id="wp1087876"/></div><p class="pGraphic">

</p>
<p class="pBody"><a name="wp1088001"> </a>
As indicated in the example, the <code class="cCode">FLD_MBSTRING</code> field is capable of carrying information identifying the code-set <em class="cEmphasis">character encoding</em>, or simply <em class="cEmphasis">encoding</em>, of its user data. In the example, the client-request <code class="cCode">FLD_MBSTRING</code> field holds Japanese user data represented by the Shift-JIS (SJIS) encoding, while the server-reply <code class="cCode">FLD_MBSTRING</code> field holds Japanese user data represented by the Extended UNIX Code (EUC) encoding. The multibyte character encoding feature reads environment variables <code class="cCode">TPMBENC</code> and <code class="cCode">TPMBACONV</code> to determine the source encoding, the target encoding, and the state (on or off) of automatic encoding conversion.
</p>
<p class="pBody"><a name="wp1089991"> </a>
As shown in the following figure, the FML32 typed buffer, itself, is capable of carrying information identifying the character encoding of its user data.
</p>
<div class="pFigureTitle"><a name="wp1088638"> </a>
Figure&#160;5-2  Using Global Encoding
</div>

 
 <p class="pGraphic"><a name="wp1088771"> </a>
</p>
<div class="figure" align="left"><img src="wwimages/fml-5-1-2.gif" height="200" width="510" alt="Using Global Encoding" id="wp1088640"/></div><p class="pGraphic">

</p>
<p class="pBody"><a name="wp1090094"> </a>
For an FML32 typed buffer holding many <code class="cCode">FLD_MBSTRING</code> fields, using global encoding is a more efficient way to transport multibyte user data via FML32 buffers than adding a character encoding name to each <code class="cCode">FLD_MBSTRING</code> field. Using the <code class="cCode">Fmbpack32()</code> function, application developers can choose global encoding or individual encoding for each <code class="cCode">FLD_MBSTRING</code> field created via <code class="cCode">Fmbpack32()</code>. Only one global encoding name is allowed per FML32 buffer.
</p>
<p class="pBody"><a name="wp1090095"> </a>
The encoding conversion capability enables the underlying Tuxedo system software to convert the encoding representation of an incoming <code class="cCode">FLD_MBSTRING</code> field to an encoding representation supported by the machine on which the receiving process is running. The conversion is neither a conversion between character code sets nor a translation between languages, but rather a conversion between different character encodings for the same language.
</p>
<h3 class="pHeading2"><a name="wp1086101"> </a>
Fmbpack32
</h3>
<p class="pBody"><a name="wp1086108"> </a>
This function prepares the encoding name and multibyte data information for an <code class="cCode">FLD_MBSTRING</code> field input to an FML32 typed buffer. <code class="cCode">Fmbpack32()</code> is used before the <code class="cCode">FLD_MBSTRING</code> field is added to an FML32 buffer via FML32 APIs.
</p>
<p class="pBody"><a name="wp1093119"> </a>
For more information about this function, refer to the <span class="cHyperlink">
Fmbpack3</span><a href="../rf3fml/rf3fml.html"></a>2(3fml) function in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1086140"> </a>
Fmbunpack32
</h3>
<p class="pBody"><a name="wp1086147"> </a>
This function extracts the encoding name and multibyte data information from an <code class="cCode">FLD_MBSTRING</code> field in an FML32 typed buffer. <code class="cCode">Fmbunpack32()</code> is used after the <code class="cCode">FLD_MBSTRING</code> field is extracted from an FML32 buffer via FML32 APIs (<code class="cCode">Ffind32()</code>, <code class="cCode">Fget32()</code>, ...).
</p>
<p class="pBody"><a name="wp1093190"> </a>
For more information about this function, refer to the <span class="cHyperlink">
Fmbunpack32</span><a href="../rf3fml/rf3fml.html"></a>(3fml) function in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1086317"> </a>
tpconvfmb32
</h3>
<p class="pBody"><a name="wp1086325"> </a>
This function converts the multibyte characters in an <code class="cCode">FLD_MBSTRING</code> field in an FML32 typed buffer to a named target encoding. Specifically, <code class="cCode">tpconvfmb32()</code> <em class="cEmphasis">compares</em> the source encoding name specified for the <code class="cCode">FLD_MBSTRING</code> field <em class="cEmphasis">with</em> the target encoding name defined in <code class="cCodeEmphasis">target_encoding</code>; if the encoding names are different, <code class="cCode">tpconvfmb32()</code> converts the <code class="cCode">FLD_MBSTRING</code> field data to the target encoding.
</p>
<p class="pBody"><a name="wp1099180"> </a>
For more information about this function, refer to the <a href="../rf3fml/rf3fml.html">tpconvfmb32(3fml)</a> function in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1099200"> </a>
tpconvvmb32
</h3>
<p class="pBody"><a name="wp1099202"> </a>
This function converts the multibyte characters in an <code class="cCode">MBSTRING</code> field in a VIEW32 typed buffer to a named target encoding. Specifically, <code class="cCode">tpconvvmb32()</code> compares the source encoding name specified for the <code class="cCode">MBSTRING</code> field with the target encoding name defined in <code class="cCode">target_encoding</code>; if the encoding names are different, <code class="cCode">tpconvvmb32()</code> converts the <code class="cCode">MBSTRING</code> field data to the target encoding.
</p>
<p class="pBody"><a name="wp1099204"> </a>
For more information about this function, refer to the <a href="../rf3fml/rf3fml.html">tpconvvmb32(3fml)</a> function in Oracle Tuxedo ATMI FML Function Reference.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1099183"> </a>
Indexing Functions
</h2><p class="pBody"><a name="wp1057746"> </a>
When a fielded buffer is initialized by <code class="cCode">Finit</code> or <code class="cCode">Falloc</code>, an index is automatically set up. This index is used to expedite fielded buffer accesses and is transparent to you. As fields are added to or deleted from the fielded buffer, the index is automatically updated.
</p>
<p class="pBody"><a name="wp1057747"> </a>
However, when storing a fielded buffer on a long-term storage device, or when transferring it between cooperating processes, it may be desirable to save space by eliminating its index and regenerating it upon receipt. The functions described in this section may be used to perform such index manipulations.
</p>
<h3 class="pHeading2"><a name="wp1057748"> </a>
Fidxused
</h3>
<p class="pBody"><a name="wp1057749"> </a>
This function returns the amount of space used by the index of a buffer.
</p>
<a name="wp1057750"> </a><div class="pPreformatted"><pre>long<br />Fidxused(FBFR *<code class="cCodeEmphasis">fbfr</code>)</pre></div><p class="pBody"><a name="wp1057751"> </a>
Here <code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.
</p>
<p class="pBody"><a name="wp1057752"> </a>
You can use this function to determine the size of the index of a buffer, and whether significant time or space can be saved by deleting the index.
</p>
<p class="pBody"><a name="wp1064015"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fidxused,&#160;Fidxused32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057753"> </a>
Findex
</h3>
<p class="pBody"><a name="wp1057754"> </a>
The function <code class="cCode">Findex</code> may be used at any time to index an unindexed fielded buffer.
</p>
<a name="wp1057755"> </a><div class="pPreformatted"><pre>int<br />Findex(FBFR *<code class="cCodeEmphasis">fbfr</code>. FLDOCC <code class="cCodeEmphasis">intvl</code>)</pre></div><p class="pBody"><a name="wp1057756"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057757"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057758"> </a><code class="cCodeEmphasis">intvl</code> is the indexing interval.</li>
</ul></div>
<p class="pBody"><a name="wp1057759"> </a>
The second argument to <code class="cCode">Findex</code> specifies the indexing interval for the buffer. If 0 is specified, the value <code class="cCode">FSTDXINT</code> (defined in <code class="cCode">fml.h</code>) is used. The user may ensure that all fields are indexed by specifying an interval of 1.
</p>
<p class="pBody"><a name="wp1057760"> </a>
Note that more space may be made available in an existing buffer for user data by increasing the indexing interval, and reindexing the buffer. This represents a space/time trade-off, however, since reducing the number of index elements (by increasing the index interval), means, in general, that searches for fields will take longer. Most operations attempt to drop the entire index if they run out of space before returning a &#8220;no space&#8221; error.
</p>
<p class="pBody"><a name="wp1064025"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Findex,&#160;Findex32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057761"> </a>
Frstrindex
</h3>
<p class="pBody"><a name="wp1057762"> </a>
This function can be used instead of <a href="fml05.html#wp1057753"><code class="cCode">Findex</code></a> for cases in which the fielded buffer has not been altered since its index was removed.
</p>
<a name="wp1057763"> </a><div class="pPreformatted"><pre>int<br />Frstrindex(FBFR *<code class="cCodeEmphasis">fbfr</code>, FLDOCC <code class="cCodeEmphasis">numidx</code>)</pre></div><p class="pBody"><a name="wp1057764"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057765"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1064041"> </a><code class="cCodeEmphasis">numidx</code> is the value returned by the <code class="cCode">Funindex</code> function.</li>
</ul></div>
<p class="pBody"><a name="wp1064053"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Frstrindex,&#160;Frstrindex32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1064043"> </a>
Funindex
</h3>
<p class="pBody"><a name="wp1064044"> </a>
<code class="cCode">Funindex</code> discards the index of a fielded buffer and returns the number of index entries the buffer had before the index was stripped.
</p>
<a name="wp1057769"> </a><div class="pPreformatted"><pre>FLDOCC<br />Funindex(FBFR *<code class="cCodeEmphasis">fbfr</code>)</pre></div><p class="pBody"><a name="wp1057770"> </a>
Here <code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.
</p>
<p class="pBody"><a name="wp1064063"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Funindex,&#160;Funindex32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057772"> </a>
Example of Sending a Fielded Buffer Without an Index
</h3>
<p class="pBody"><a name="wp1057773"> </a>
To transmit a fielded buffer without its index, complete a procedure such as the following:
</p>
<div class="pSmartList1"><ol type="1" class="pSmartList1">
<li><a name="wp1057774"> </a>Remove the index:</li>
<a name="wp1057775"> </a><div class="pPreformattedRelative"><pre>save = Funindex(fbfr);</pre></div><li><a name="wp1057776"> </a>Get the number of bytes to send (that is, the number of significant bytes from the beginning of the buffer):</li>
<a name="wp1057777"> </a><div class="pPreformattedRelative"><pre>num_to_send = Fused(fbfr);</pre></div><li><a name="wp1057778"> </a>Send the buffer without the index: </li>
<a name="wp1057779"> </a><div class="pPreformattedRelative"><pre>transmit(fbfr,num_to_send);</pre></div><li><a name="wp1057780"> </a>Restore the index to the buffer: </li>
<a name="wp1057781"> </a><div class="pPreformattedRelative"><pre>Frstrindex(fbfr,save);</pre></div></ol></div>
<p class="pBody"><a name="wp1057782"> </a>
The index may be regenerated on the receiving side by the following statement:
</p>
<a name="wp1057783"> </a><div class="pPreformatted"><pre>Findex(fbfr);</pre></div><p class="pBody"><a name="wp1057784"> </a>
Note that the receiving process cannot call <a href="fml05.html#wp1057761"><code class="cCode">Frstrindex</code></a> because it did not remove the index itself, and the index was not sent with the file.
</p>
<a name="wp1057785"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The space used in memory by the index is not freed by calling <a href="fml05.html#wp1064043"><code class="cCode">Funindex</code></a>. The <code class="cCode">Funindex</code> function only saves space on disk or when sending a buffer to another process. Of course, you are always free to send a fielded buffer and its index to another process and avoid using these functions.</td>
</tr>
</table>

<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1057787"> </a>
Input/Output Functions
</h2><p class="pBody"><a name="wp1057788"> </a>
The functions described in this section support input and output of fielded buffers to standard I/O or to file streams.
</p>
<h3 class="pHeading2"><a name="wp1057789"> </a>
Fread and Fwrite
</h3>
<p class="pBody"><a name="wp1057790"> </a>
The I/O functions <code class="cCode">Fread</code> and <code class="cCode">Fwrite</code> work with the standard I/O library:
</p>
<a name="wp1057791"> </a><div class="pPreformatted"><pre>int Fread(FBFR *fbfr, FILE *iop)<br />int Fwrite(FBFR *fbfr, FILE *iop)</pre></div><p class="pBody"><a name="wp1057792"> </a>
The stream to which&#8212;or from which&#8212;I/O is directed is determined by a <code class="cCode">FILE</code> pointer argument. This argument must be set up using the normal standard I/O library functions.
</p>
<p class="pBody"><a name="wp1057793"> </a>
A fielded buffer may be written into a standard I/O stream with the function <code class="cCode">Fwrite</code>, as follows:
</p>
<a name="wp1057794"> </a><div class="pPreformatted"><pre>if (Fwrite(fbfr, iop) &lt; 0)<br />  F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057795"> </a>
A buffer written with <code class="cCode">Fwrite</code> may be read with <code class="cCode">Fread</code>, as follows.
</p>
<a name="wp1057796"> </a><div class="pPreformatted"><pre>if(Fread(fbfr, iop) &lt; 0)<br /> F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1057797"> </a>
Although the contents of the fielded buffer pointed to by <code class="cCode">fbfr</code> are replaced by the fielded buffer read in, the capacity of the fielded buffer (that is, the size of the buffer) remains unchanged.
</p>
<p class="pBody"><a name="wp1057798"> </a>
<code class="cCode">Fwrite</code> discards the buffer index, writing only as much of the fielded buffer as has been used (as returned by <a href="fml05.html#wp1056933"><code class="cCode">Fused</code></a>).
</p>
<p class="pBody"><a name="wp1057799"> </a>
<code class="cCode">Fread</code> restores the index of a buffer by calling <a href="fml05.html#wp1057753"><code class="cCode">Findex</code></a>. The buffer is indexed with the same indexing interval with which it was written by <code class="cCode">Fwrite</code>. <code class="cCode">Fread32</code> ignores the <code class="cCode">FLD_PTR</code> field type.
</p>
<p class="pBody"><a name="wp1064543"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fread,&#160;Fread32(3fml)</a> and <a href="../rf3fml/rf3fml.html">Fwrite,&#160;Fwrite32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057800"> </a>
Fchksum
</h3>
<p class="pBody"><a name="wp1057801"> </a>
A checksum may be calculated for verifying I/O, as follows:
</p>
<a name="wp1057802"> </a><div class="pPreformatted"><pre>long chk;<br />. . .<br />chk = Fchksum(fbfr);</pre></div><p class="pBody"><a name="wp1057803"> </a>
The user is responsible for calling <code class="cCode">Fchksum</code>, writing the checksum value out, along with the fielded buffer, and checking it on input. <a href="fml05.html#wp1057789">Fwrite</a> does not write the checksum automatically. For pointer fields (<code class="cCode">FLD_PTR)</code>, the name of the pointer field in the checksum calculation (rather than the pointer or the data referenced by the pointer) is included.
</p>
<p class="pBody"><a name="wp1064566"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fchksum,&#160;Fchksum32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057804"> </a>
Fprint and Ffprint
</h3>
<p class="pBody"><a name="wp1057805"> </a>
The <code class="cCode">Fprint</code> function prints a fielded buffer on the standard output in text format.
</p>
<a name="wp1057806"> </a><div class="pPreformatted"><pre>Fprint(FBFR *fbfr)</pre></div><p class="pBody"><a name="wp1057807"> </a>
Here <code class="cCode">fbfr</code> is a pointer to a fielded buffer.
</p>
<p class="pBody"><a name="wp1057808"> </a>
<code class="cCode">Ffprint</code> is similar to <code class="cCode">Fprint</code>, except that it sends text to a specified output stream, as in the following line:
</p>
<a name="wp1057809"> </a><div class="pPreformatted"><pre>Ffprint(FBFR *<code class="cCodeEmphasis">fbfr</code>, FILE *<code class="cCodeEmphasis">iop</code>)</pre></div><p class="pBody"><a name="wp1057810"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057811"> </a><code class="cCodeEmphasis">fbfr</code> is a pointer to a fielded buffer.</li>
<li><a name="wp1057812"> </a><code class="cCodeEmphasis">iop</code> is a pointer of type <code class="cCode">FILE</code> to the output stream.</li>
</ul></div>
<p class="pBody"><a name="wp1057813"> </a>
Each of these print functions prints, for each field occurrence, the field name and the field value, separated by a tab and followed by a new line. <code class="cCode">Fname</code> is used to determine the field name. If the field name cannot be determined, then the field identifier is printed. Non-printable characters in the field values for strings and character arrays are represented by a backslash followed by their two-character hexadecimal value. Backslashes occurring in the text are escaped with an extra backslash. A blank line is printed following the output of the printed buffer.
</p>
<p class="pBody"><a name="wp1057814"> </a>
For values of type <code class="cCode">FLD_PTR</code>, <code class="cCode">Fprint32</code> prints the field name or field identifier and the pointer value in hexadecimal. Although this function prints pointer information, the<code class="cCode"> Fextread32</code> function ignores the <code class="cCode">FLD_PTR</code> field type. For values of type <code class="cCode">FLD_FML32</code>, <code class="cCode">Fprint32</code> recursively prints the FML32 buffer, with leading tabs added for each level of nesting. For values of type <code class="cCode">FLD_VIEW32</code>, this function prints the VIEW32 field name and structure member name/value pairs.
</p>
<p class="pBody"><a name="wp1064576"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fprint,&#160;Fprint32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1057816"> </a>
Fextread
</h3>
<p class="pBody"><a name="wp1057817"> </a>
<code class="cCode">Fextread</code> may be used to construct a fielded buffer from its printed format, that is, from the output of <code class="cCode">Fprint</code> (hexadecimal values output by <code class="cCode">Fprint</code> are interpreted properly). 
</p>
<a name="wp1057818"> </a><div class="pPreformatted"><pre>int<br />Fextread(FBFR *<code class="cCodeEmphasis">fbfr</code>, FILE *<code class="cCodeEmphasis">iop</code>)</pre></div><p class="pBody"><a name="wp1057819"> </a>
<code class="cCode">Fextread</code> accepts an optional flag preceding the field name/field identifier specification in the output of <code class="cCode">Fprint</code>, as shown in the following table.
</p>
<p class="pBody"><a name="wp1057848"> </a>
If no flag is specified, the default action is to <code class="cCode">Fadd</code> the field to the buffer.
</p>
<p class="pBody"><a name="wp1057849"> </a>
Field values may be extended across lines by beginning each overflow line with a tab (which is later discarded). A single blank line signals the end of the buffer; successive blank lines yield a null buffer. For embedded buffers <code class="cCode">FLD_FML32</code> and <code class="cCode">FLD_VIEW32</code>, <code class="cCode">Fextread</code> generates nested FML32 buffers and VIEW32 fields, respectively. <code class="cCode">Fextread32</code> ignores the <code class="cCode">FLD_PTR</code> field type.
</p>
<p class="pBody"><a name="wp1057850"> </a>
If an error has occurred, <code class="cCode">-1</code> is returned, and <code class="cCode">Ferror</code> is set accordingly. If the end of the file is reached before a blank line, <code class="cCode">Ferror</code> is set to <code class="cCode">FSYNTAX</code>.
</p>
<p class="pBody"><a name="wp1064586"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fextread,&#160;Fextread32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1057852"> </a>
Boolean Expressions of Fielded Buffers
</h2><p class="pBody"><a name="wp1068451"> </a>
This topic includes the following sections:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057854"> </a><a href="fml05.html#wp1057866">Definitions of Boolean Expressions</a></li>
<li><a name="wp1057855"> </a><a href="fml05.html#wp1057970">Field Names and Types</a></li>
<li><a name="wp1057856"> </a><a href="fml05.html#wp1057987">How a Boolean Expression Is Converted for Evaluation</a></li>
<li><a name="wp1057857"> </a><a href="fml05.html#wp1057996">Description of Boolean Primary Expressions</a></li>
</ul></div>
<p class="pBody"><a name="wp1057860"> </a>
This section describes the functions available for evaluating Boolean expressions in which the &#8220;variables&#8221; are the values of fields in a fielded buffer or a VIEW. Functions described in this section allow you to: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057861"> </a>Compile a Boolean expression into a compact form suitable for evaluation</li>
<li><a name="wp1057862"> </a>Evaluate a Boolean expression against a fielded buffer or a VIEW, returning a true or false answer</li>
<li><a name="wp1057863"> </a>Print a compiled Boolean expression</li>
</ul></div>
<p class="pBody"><a name="wp1057864"> </a>
A function is provided that compiles the expression into a compact form suitable for efficient evaluation. A second function evaluates the compiled form against a fielded buffer to produce a true or false answer.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1057866"> </a>
Definitions of Boolean Expressions
</h2><p class="pBody"><a name="wp1057867"> </a>
This section describes, in detail, the expressions accepted by the Boolean compilation function, and explains how each expression is evaluated.
</p>
<p class="pBody"><a name="wp1057868"> </a>
The following standard C language operators are not supported:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057869"> </a>Shift operators: &lt;&lt; and &gt;&gt;</li>
<li><a name="wp1057870"> </a>Bitwise &#8220;or&#8221; and &#8220;and&#8221; operators: <code class="cCode">||</code> and &amp;&amp;</li>
<li><a name="wp1057871"> </a>Conditional operator: ?</li>
<li><a name="wp1057872"> </a>Prefix and postfix incrementation and decrementation operators: ++ and --</li>
<li><a name="wp1057873"> </a>Address and indirection operators: &amp; and *</li>
<li><a name="wp1057874"> </a>Assignment operator: =</li>
<li><a name="wp1057875"> </a>Comma operator: , </li>
</ul></div>
<p class="pBody"><a name="wp1057876"> </a>
The following table shows the Backus-Naur Form definitions of the accepted Boolean expressions.
</p>
<p class="pGraphic"><a name="wp1057967"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1057880table1057877"><caption><a name="wp1057880"> </a>
Table 5-5  BNF Boolean Expression Definitions &#160;

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1057884"> </a>
Expression
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1057886"> </a>
Definition
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057888"> </a>
&lt;boolean&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057890"> </a>
&lt;boolean&gt; <code class="cCode">||</code> &lt;logical and&gt; <code class="cCode">|</code> &lt;logical and&gt;
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057892"> </a>
&lt;logical and&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057894"> </a>
&lt;logical and&gt; &amp;&amp; &lt;xor expr&gt; <code class="cCode">|</code> &lt;xor expr&gt;
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057896"> </a>
&lt;xor expr&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057898"> </a>
&lt;xor expr&gt; ^ &lt;equality expr&gt; <code class="cCode">|</code> &lt;equality expr&gt;
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057900"> </a>
&lt;equality expr&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057902"> </a>
&lt;equality expr&gt; &lt;eq op&gt; &lt;relational expr&gt; <code class="cCode">|</code> &lt;relational expr&gt;
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057904"> </a>
&lt;eq op&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057906"> </a>
== <code class="cCode">|</code> != <code class="cCode">|</code> %% <code class="cCode">|</code> !%
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057908"> </a>
&lt;relational expr&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057910"> </a>
&lt;relational expr&gt; &lt;rel op&gt; &lt;additive expr&gt; <code class="cCode">|</code> &lt;additive expr&gt;
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057912"> </a>
&lt;rel op&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057914"> </a>
&lt; <code class="cCode">|</code> &lt;= <code class="cCode">|</code> &gt;= <code class="cCode">|</code> &gt; <code class="cCode">|</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057916"> </a>
&lt;additive expr&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057918"> </a>
&lt;additive expr&gt; &lt;add op&gt; &lt;multiplicative expr&gt; <code class="cCode">|</code> &lt;multiplicative expr&gt;
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057920"> </a>
&lt;add op&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057922"> </a>
+ <code class="cCode">|</code> -
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057924"> </a>
&lt;multiplicative expr&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057926"> </a>
&lt;multiplicative expr&gt; &lt;mult op&gt; &lt;unary expr&gt; <code class="cCode">|</code> &lt;unary expr&gt;
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057928"> </a>
&lt;mult op&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057930"> </a>
* <code class="cCode">|</code> / <code class="cCode">|</code> %
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057932"> </a>
&lt;unary expr&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057934"> </a>
&lt;unary op&gt; &lt;primary expr&gt; <code class="cCode">|</code> &lt;primary expr&gt;
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057936"> </a>
&lt;unary op&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057938"> </a>
+ <code class="cCode">|</code> - <code class="cCode">|</code> ~ <code class="cCode">|</code> !
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057940"> </a>
&lt;primary expr&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057942"> </a>
( &lt;boolean&gt; ) <code class="cCode">|</code> &lt;unsigned constant&gt; <code class="cCode">|</code> &lt;field ref&gt;
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057944"> </a>
&lt;unsigned constant&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057946"> </a>
&lt;unsigned number&gt; <code class="cCode">|</code> &lt;string&gt;
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057948"> </a>
&lt;unsigned number&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057950"> </a>
&lt;unsigned float&gt; <code class="cCode">|</code> &lt;unsigned int&gt;
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057952"> </a>
&lt;string&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057954"> </a>
&#39; &lt;character&gt; {&lt;character&gt;. . .} &#39;
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057956"> </a>
&lt;field ref&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057958"> </a>
&lt;field name&gt; <code class="cCode">|</code> &lt;field name&gt;[&lt;field occurrence&gt;]
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057960"> </a>
&lt;field occurrence&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057962"> </a>
&lt;unsigned int&gt; <code class="cCode">|</code> &lt;meta&gt;
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057964"> </a>
&lt;meta&gt;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1057966"> </a>
?
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<p class="pBody"><a name="wp1057968"> </a>
The following sections describe Boolean expressions in greater detail.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1057970"> </a>
Field Names and Types
</h2><p class="pBody"><a name="wp1057971"> </a>
The only variables allowed in Boolean expressions are field references. There are several restrictions on field names. Names are made up of letters and digits; the first character must be a letter. The underscore ( <code class="cCode">_</code> ) counts as a letter; it is useful for improving the readability of long variable names. Up to 30 characters are significant. There are no reserved words.
</p>
<p class="pBody"><a name="wp1057972"> </a>
For a fielded buffer evaluation, any field that is referenced in a Boolean expression must exist in a field table. This implies that the <code class="cCode">FLDTBLDIR</code> and <code class="cCode">FIELDTBLS</code> environment variables are set, as described in <a href="fml03.html">Setting Up Your Environment for FML and VIEWS</a> before using the Boolean compilation function. The field types used in Booleans are those allowed for FML fields: <code class="cCode">short</code>, <code class="cCode">long</code>, <code class="cCode">float</code>, <code class="cCode">double</code>, <code class="cCode">char</code>, <code class="cCode">string</code>, and <code class="cCode">carray</code>. Along with the field name, the field type is kept in the field table. Thus, the field type can always be determined.
</p>
<p class="pBody"><a name="wp1057976"> </a>
For a VIEW evaluation, any field that is referenced in a Boolean expression must exist as a C structure element name, not the associated fielded buffer name, in the VIEW. This implies that the <code class="cCode">VIEWDIR</code> and <code class="cCode">VIEWFILES</code> environment variables are set, as described in <a href="fml03.html">Setting Up Your Environment for FML and VIEWS</a><span style="font-weight: bold"> </span>before using the Boolean compilation function. The field types used in Booleans are those allowed for FML VIEWS: <code class="cCode">short</code>, <code class="cCode">long</code>, <code class="cCode">float</code>, <code class="cCode">double</code>, <code class="cCode">char</code>, <code class="cCode">string</code>, <code class="cCode">carray</code>, plus <code class="cCode">int</code> and <code class="cCode">dec_t</code>. Along with the field name, the field type is kept in the view definition. Thus, the field type can always be determined.
</p>
<h3 class="pHeading2"><a name="wp1057980"> </a>
Strings
</h3>
<p class="pBody"><a name="wp1057981"> </a>
A string is a group of characters within single quotes. The ASCII code for a character may be substituted for the character via an escape sequence. An escape sequence takes the form of a backslash followed by exactly two hexadecimal digits. <b class="cBold">This convention differs from the C language convention of using a hexadecimal escape sequence that starts with </b><code class="cCode">\x</code><b class="cBold">.</b>
</p>
<p class="pBody"><a name="wp1057982"> </a>
As an example, consider <code class="cCode">hello&#8217;</code> and <code class="cCode">hell\\6f&#8217;</code>. They are equivalent strings because the hexadecimal code for an <code class="cCode">o</code>&#8217; is <code class="cCode">6f</code>.
</p>
<p class="pBody"><a name="wp1057983"> </a>
Octal escape sequences and escape sequences such as <code class="cCode">\n</code> are not supported.
</p>
<h3 class="pHeading2"><a name="wp1057984"> </a>
Constants
</h3>
<p class="pBody"><a name="wp1057985"> </a>
Numeric integer and floating point constants are accepted, as in C. (Octal and hexadecimal constants are not recognized.) Integer constants are treated as <code class="cCode">long</code>s and floating point constants are treated as <code class="cCode">double</code>s. (Decimal constants for the <code class="cCode">dec_t</code> type are not supported.)
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1057987"> </a>
How a Boolean Expression Is Converted for Evaluation
</h2><p class="pBody"><a name="wp1057988"> </a>
To evaluate a Boolean expression, the Boolean compiler performs the following conversions:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057989"> </a>It converts <code class="cCode">short</code> and <code class="cCode">int</code> values to <code class="cCode">long</code>s.</li>
<li><a name="wp1057990"> </a>It converts <code class="cCode">float</code> and <code class="cCode">decimal</code> values to <code class="cCode">double</code>s.</li>
<li><a name="wp1057991"> </a>It converts characters to <code class="cCode">string</code>s.</li>
<li><a name="wp1057992"> </a>To compare a non-quoted string within a field to a numeric, it converts the string to a numeric value.</li>
<li><a name="wp1057993"> </a>To compare a <code class="cCode">constant</code> (that is, a quoted) string to a numeric, it converts the numeric to a string, and does a lexical comparison.</li>
<li><a name="wp1057994"> </a>To compare a <code class="cCode">long</code> and a <code class="cCode">double</code>, it converts the <code class="cCode">long</code> to a <code class="cCode">double</code>.</li>
</ul></div>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1057996"> </a>
Description of Boolean Primary Expressions
</h2><p class="pBody"><a name="wp1057997"> </a>
Boolean expressions are built from primary expressions, which can be any of the following: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1057998"> </a><code class="cCode">field name</code>&#8212;a field name</li>
<li><a name="wp1057999"> </a><code class="cCode">field name[constant]</code>&#8212;a field name and a constant subscript</li>
<li><a name="wp1058000"> </a><code class="cCode">field name[?]</code>&#8212;a field name and the <code class="cCode">?</code>&#8217; subscript</li>
<li><a name="wp1058001"> </a><code class="cCode">constant</code>&#8212;a constant</li>
<li><a name="wp1058002"> </a><code class="cCode">(expression)</code>&#8212;an expression in parentheses</li>
</ul></div>
<p class="pBody"><a name="wp1058003"> </a>
A field name or a field name followed by a subscript is a primary expression. The subscript indicates which occurrence of the field is being referenced. The subscript may be either an integer constant, or <code class="cCode">?</code> indicating any occurrence; the subscript cannot be an expression. If the field name is not subscripted, field occurrence 0 is assumed.
</p>
<p class="pBody"><a name="wp1058004"> </a>
If a field name reference appears without an arithmetic, unary, equality, or relational operator, then its value is the long integer value 1 if the field exists and 0 if the field does not exist. This may be used to test the existence of a field in the fielded buffer regardless of field type. (Note that there is no <code class="cCode">*</code> indirection operator.)
</p>
<p class="pBody"><a name="wp1058005"> </a>
A constant is a primary expression. Its type may be <code class="cCode">long</code>, <code class="cCode">double</code>, or <code class="cCode">carray</code>, as discussed in the conversion section.
</p>
<p class="pBody"><a name="wp1058006"> </a>
A parenthesized expression is a primary expression for which the type and value are identical to those of the unadorned expression. Parentheses may be used to change the precedence of operators, which is discussed in the next section.
</p>
<h3 class="pHeading2"><a name="wp1058007"> </a>
Description of Boolean Expression Operators
</h3>
<p class="pBody"><a name="wp1058008"> </a>
The following table lists the Boolean expression operators in descending order of precedence.
</p>
<p class="pGraphic"><a name="wp1058051"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1058012table1058009"><caption><a name="wp1058012"> </a>
Table 5-6  Boolean Expression Operators

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1058016"> </a>
Type
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1058018"> </a>
Operators
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058020"> </a>
Unary
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058022"> </a>
+, -, !, ~
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058024"> </a>
Multiplicative
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058026"> </a>
*, /, %
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058028"> </a>
Additive
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058030"> </a>
+, -
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058032"> </a>
Relational
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058034"> </a>
&lt; , &gt;, &lt;=, &gt;=, ==, !=
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058036"> </a>
Equality and matching
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058038"> </a>
==, !=, %%, !%
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058040"> </a>
Exclusive OR
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058042"> </a>
^
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058044"> </a>
Logical AND
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058046"> </a>
&amp;&amp;
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058048"> </a>
Logical OR
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1058050"> </a>
<code class="cCode">||</code>
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<p class="pBody"><a name="wp1058052"> </a>
The operators classified as the same operator type have equal precedence. The following sections discuss each operator type in detail. As in C, you can override the precedence of operators by using parentheses.
</p>
<h3 class="pHeading2"><a name="wp1058053"> </a>
Unary Operators Used in Boolean Expressions
</h3>
<p class="pBody"><a name="wp1058054"> </a>
The following unary operators are recognized:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1058055"> </a>Unary plus operator: <code class="cCode">+</code></li>
<li><a name="wp1058056"> </a>Unary minus operator: <code class="cCode">-</code></li>
<li><a name="wp1058057"> </a>The one&#8217;s complement operator: <code class="cCode">~</code></li>
<li><a name="wp1058058"> </a>Logical not operator: <code class="cCode">!</code></li>
</ul></div>
<p class="pBody"><a name="wp1058059"> </a>
Expressions in which unary operators are used group right-to-left:
</p>
<a name="wp1058060"> </a><div class="pPreformatted"><pre>+ <code class="cCodeEmphasis">expression<br /></code>- <code class="cCodeEmphasis">expression<br /></code>~ <code class="cCodeEmphasis">expression<br /></code>! <code class="cCodeEmphasis">expression</code></pre></div><p class="pBody"><a name="wp1058061"> </a>
The unary plus operator has no effect on the operand; it is recognized and ignored. The result of the unary minus operator is the negative of its operand. The usual arithmetic conversions are performed. Unsigned entities do not exist in FML and thus cause no problems with this operator.
</p>
<p class="pBody"><a name="wp1058062"> </a>
The result of the logical negation operator is 1 if the value of its operand is 0, and 0 if the value of its operand is non-zero. The type of the result is <code class="cCode">long</code>.
</p>
<p class="pBody"><a name="wp1058063"> </a>
The result of the one&#8217;s complement operator is the one&#8217;s complement of its operand. The type of the result is <code class="cCode">long</code>.
</p>
<h3 class="pHeading2"><a name="wp1058064"> </a>
Multiplicative Operators Used in Boolean Expressions
</h3>
<p class="pBody"><a name="wp1058065"> </a>
The multiplicative operators&#8212;<code class="cCode">*</code>, <code class="cCode">/</code>, and <code class="cCode">%</code>&#8212;group left-to-right. The usual arithmetic conversions are performed:
</p>
<a name="wp1058066"> </a><div class="pPreformatted"><pre><code class="cCodeEmphasis">expression</code> * <code class="cCodeEmphasis">expression<br />expression</code> / <code class="cCodeEmphasis">expression<br />expression</code> % <code class="cCodeEmphasis">expression</code></pre></div><p class="pBody"><a name="wp1058067"> </a>
The binary <code class="cCode">*</code> operator indicates multiplication. The <code class="cCode">*</code> operator is associative and expressions with several multiplications at the same level may be rearranged by the compiler.
</p>
<p class="pBody"><a name="wp1058068"> </a>
The binary <code class="cCode">/</code> operator indicates division. When positive integers are divided, truncation is toward 0, but the form of truncation is machine-dependent if either operand is negative.
</p>
<p class="pBody"><a name="wp1058069"> </a>
The binary<code class="cCode"> %</code> operator yields the remainder from the division of the first expression by the second. The usual arithmetic conversions are performed. The operands must not be <code class="cCode">float</code> or <code class="cCode">double</code>.
</p>
<h3 class="pHeading2"><a name="wp1058070"> </a>
Additive Operators Used in Boolean Expressions
</h3>
<p class="pBody"><a name="wp1058071"> </a>
The additive operators <code class="cCode">+</code> and <code class="cCode">-</code> group left-to-right. The usual arithmetic conversions are performed: 
</p>
<a name="wp1058072"> </a><div class="pPreformatted"><pre><code class="cCodeEmphasis">expression</code> + <code class="cCodeEmphasis">expression<br />expression</code> - <code class="cCodeEmphasis">expression</code></pre></div><p class="pBody"><a name="wp1058073"> </a>
The result of the <code class="cCode">+</code> operator is the sum of the operands. The <code class="cCode">+</code> operator is associative and expressions with several additions at the same level may be rearranged by the compiler. The operands must not both be <code class="cCode">string</code>s; if one is a <code class="cCode">string</code>, it is converted to the arithmetic type of the other.
</p>
<p class="pBody"><a name="wp1058074"> </a>
The result of the <code class="cCode">-</code> operator is the difference of the operands. The usual arithmetic conversions are performed. The operands must not both be <code class="cCode">string</code>s; if one is a <code class="cCode">string</code>, it is converted to the arithmetic type of the other.
</p>
<h3 class="pHeading2"><a name="wp1058075"> </a>
Equality and Match Operators Used in Boolean Expressions
</h3>
<p class="pBody"><a name="wp1058076"> </a>
These operators group left-to-right: 
</p>
<a name="wp1058077"> </a><div class="pPreformatted"><pre><code class="cCodeEmphasis">expression</code> == <code class="cCodeEmphasis">expression<br />expression</code> != <code class="cCodeEmphasis">expression<br />expression</code> %% <code class="cCodeEmphasis">expression<br />expression</code> !% <code class="cCodeEmphasis">expression</code></pre></div><p class="pBody"><a name="wp1058078"> </a>
The <code class="cCode">==</code> (equal to) and the <code class="cCode">!=</code> (not equal to) operators yield 0 if the specified relation is false and 1 if it is true. The type of the result is <code class="cCode">long</code>. The usual arithmetic conversions are performed.
</p>
<p class="pBody"><a name="wp1058079"> </a>
The <code class="cCode">%%</code> operator takes, as its second expression, a regular expression against which it matches its first expression. The second expression (the regular expression) must be a quoted string. The first expression may be an FML field name or a quoted string. This operator yields a 1 if the first expression is fully matched by the second expression (the regular expression). The operator yields a 0 in all other cases.
</p>
<p class="pBody"><a name="wp1058080"> </a>
The <code class="cCode">!%</code> operator is the <em class="cEmphasis">not regular expression match</em> operator. It takes exactly the same operands as the <code class="cCode">%%</code> operator, but yields exactly the opposite results. The relationship between <code class="cCode">%%</code> and <code class="cCode">!%</code> is analogous to the relationship between <code class="cCode">==</code> and <code class="cCode">!=</code>.
</p>
<p class="pBody"><a name="wp1058081"> </a>
The regular expressions allowed are described on the <a href="../rf3c/rf3c.html">tpsubscribe(3c)</a> reference page in the <em class="cEmphasis">Oracle Tuxedo ATMI C Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1058085"> </a>
Relational Operators Used in Boolean Expressions
</h3>
<p class="pBody"><a name="wp1058086"> </a>
These operators group left-to-right: 
</p>
<a name="wp1058087"> </a><div class="pPreformatted"><pre><code class="cCodeEmphasis">expression</code> &lt; <code class="cCodeEmphasis">expression<br />expression</code> &gt; <code class="cCodeEmphasis">expression<br />expression</code> &lt;= <code class="cCodeEmphasis">expression<br />expression</code> &gt;= <code class="cCodeEmphasis">expression</code></pre></div><p class="pBody"><a name="wp1058088"> </a>
The operators <code class="cCode">&lt;</code> (less than), <code class="cCode">&gt;</code> (greater than), <code class="cCode">&lt;=</code> (less than or equal to) and <code class="cCode">&gt;=</code> (greater than or equal to) all yield 0 if the specified relation is false and 1 if it is true. The type of the result is <code class="cCode">long</code>. The usual arithmetic conversions are performed.
</p>
<h3 class="pHeading2"><a name="wp1058089"> </a>
Exclusive OR Operator Used in Boolean Expressions
</h3>
<p class="pBody"><a name="wp1058090"> </a>
The <code class="cCode">^</code> operator groups left-to-right: 
</p>
<a name="wp1058091"> </a><div class="pPreformatted"><pre><code class="cCodeEmphasis">expression</code> ^ <code class="cCodeEmphasis">expression</code></pre></div><p class="pBody"><a name="wp1058092"> </a>
It returns the bitwise exclusive OR function of the operands. The result is always a <code class="cCode">long</code>.
</p>
<h3 class="pHeading2"><a name="wp1058093"> </a>
Logical AND Operator Used in Boolean Expressions
</h3>
<a name="wp1058094"> </a><div class="pPreformatted"><pre><code class="cCodeEmphasis">expression</code> &amp;&amp; <code class="cCodeEmphasis">expression</code></pre></div><p class="pBody"><a name="wp1058095"> </a>
The <code class="cCode">&amp;&amp;</code> operator groups left-to-right. It returns 1 if both its operands are non-zero; otherwise, it returns 0. The <code class="cCode">&amp;&amp;</code> operator guarantees left-to-right evaluation. However, it is <em class="cEmphasis">not</em> guaranteed that the second operand is not evaluated if the first operand is 0; this is different from the C language. The operands need not have the same type. The result is always a <code class="cCode">long</code>.
</p>
<h3 class="pHeading2"><a name="wp1058096"> </a>
Logical OR Operator Used in Boolean Expressions
</h3>
<p class="pBody"><a name="wp1058097"> </a>
The <code class="cCode">||</code> operator groups left-to-right: 
</p>
<a name="wp1058098"> </a><div class="pPreformatted"><pre><code class="cCodeEmphasis">expression</code> || <code class="cCodeEmphasis">expression</code></pre></div><p class="pBody"><a name="wp1058099"> </a>
It returns <code class="cCode">1</code> if either of its operands is non-zero; otherwise, it returns <code class="cCode">0</code>. The <code class="cCode">||</code> operator guarantees left-to-right evaluation. However, it is not guaranteed that the second operand is not evaluated if the first operand is non-zero; this is different from the C language. The operands need not have the same type, and the result is always a <code class="cCode">long</code>.
</p>
<h3 class="pHeading2"><a name="wp1058100"> </a>
Sample Boolean Expressions
</h3>
<p class="pBody"><a name="wp1058101"> </a>
The following field table defines the fields used for the sample Boolean expressions: 
</p>
<a name="wp1058102"> </a><div class="pPreformatted"><pre>EMPID    200    carray<br />SEX      201    char<br />AGE      202    short<br />DEPT     203    long<br />SALARY   204    float<br />NAME     205    string</pre></div><p class="pBody"><a name="wp1058103"> </a>
Boolean expressions always evaluate to either true or false. The following example is true if both of the following conditions are true:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1058104"> </a>Field occurrence 2 of <code class="cCode">EMPID</code> exists and begins with the characters &#8220;123.&#8221;</li>
<li><a name="wp1058105"> </a>The age field (occurrence 0) appears and is less than 32. </li>
<a name="wp1058106"> </a><div class="pPreformatted"><pre>&quot;EMPID[2] %% &#39;123.*&#39; &amp;&amp; AGE &lt; 32&quot;</pre></div></ul></div>
<p class="pBody"><a name="wp1058107"> </a>
This example uses a constant integer as a subscript to <code class="cCode">EMPID</code>. In the following example, the <code class="cCode">?</code> subscript is used, instead:
</p>
<a name="wp1058108"> </a><div class="pPreformatted"><pre>&quot;PETS[?] == &#39;dog&#39;&quot;</pre></div><p class="pBody"><a name="wp1058109"> </a>
This expression is true if <code class="cCode">PETS</code> exists and any occurrence of it contains the characters &#8220;dog&#8221;.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1058111"> </a>
Boolean Functions
</h2><p class="pBody"><a name="wp1058112"> </a>
The following sections describe the various functions that take Boolean expressions as arguments.
</p>
<h3 class="pHeading2"><a name="wp1058113"> </a>
Fboolco and Fvboolco
</h3>
<p class="pBody"><a name="wp1058114"> </a>
<code class="cCode">Fboolco</code> compiles a Boolean expression for FML and returns a pointer to an evaluation tree:
</p>
<a name="wp1058115"> </a><div class="pPreformatted"><pre>char *<br />Fboolco(char *expression)</pre></div><p class="pBody"><a name="wp1058116"> </a>
Here <code class="cCode">*expression</code> is a pointer to an expression to be compiled. This function fails if any of the following field types is used: <code class="cCode">FLD_PTR</code>, <code class="cCode">FLD_FML32</code>, or <code class="cCode">FLD_VIEW32</code>. If one of these field types is encountered, <code class="cCode">Ferror</code> is set to <code class="cCode">FEBADOP</code>.
</p>
<p class="pBody"><a name="wp1058117"> </a>
<code class="cCode">Fvboolco</code> compiles a Boolean expression for a VIEW and returns a pointer to an evaluation tree:
</p>
<a name="wp1058118"> </a><div class="pPreformatted"><pre>char *<br />Fvboolco(char *expression, char *viewname)</pre></div><p class="pBody"><a name="wp1058119"> </a>
Here <code class="cCode">*expression</code> is a pointer to an expression to be compiled, and <code class="cCode">*viewname</code> is a pointer to the view name for which the fields are evaluated.
</p>
<p class="pBody"><a name="wp1058120"> </a>
Space is allocated using <code class="cCode">malloc</code>(3) to hold the evaluation tree. For example, the following code compiles a Boolean expression that checks whether the <code class="cCode">FIRSTNAME</code> field is in the buffer, whether it begins with J&#8217; and ends with n&#8217; (such as &#8220;John&#8221; or &#8220;Joan&#8221;), and whether the <code class="cCode">SEX</code> field is equal to M&#8217;.
</p>
<a name="wp1058121"> </a><div class="pPreformatted"><pre>#include &quot;&lt;stdio.h&gt;&quot;<br />#include &quot;fml.h&quot;<br />extern char *Fboolco;<br />char *tree;<br />. . .<br />if((tree=Fboolco(&quot;FIRSTNAME %% &#39;J.*n&#39; &amp;&amp; SEX == &#39;M&#39;&quot;)) == NULL)<br />  F_error(&quot;pgm_name&quot;);</pre></div><p class="pBody"><a name="wp1058122"> </a>
The first and second characters of the tree array form the least significant byte and the most significant byte, respectively, of an unsigned 16-bit quantity that gives the length, in bytes, of the entire array. This value is useful for copying or otherwise manipulating the array.
</p>
<p class="pBody"><a name="wp1058123"> </a>
Because the evaluation tree produced by <code class="cCode">Fboolco</code> is used by the Boolean functions described in the following sections, it is not necessary to recompile the expression constantly.
</p>
<p class="pBody"><a name="wp1058124"> </a>
Use the <code class="cCode">free</code>(3) function to free the space allocated to an evaluation tree when the Boolean expression will no longer be used. Compiling many Boolean expressions without freeing the evaluation tree when it is no longer needed may cause a program to run out of data space.
</p>
<p class="pBody"><a name="wp1064615"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fboolco,&#160;Fboolco32,&#160;Fvboolco,&#160;Fvboolco32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1058125"> </a>
Fboolpr and Fvboolpr
</h3>
<p class="pBody"><a name="wp1058126"> </a>
<code class="cCode">Fboolpr</code> prints a compiled expression to the specified file stream. The expression is fully parenthesized, as it was parsed (as indicated by the evaluation tree).
</p>
<a name="wp1058127"> </a><div class="pPreformatted"><pre>void<br />Fboolpr(char *tree, FILE *iop)</pre></div><p class="pBody"><a name="wp1058128"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1058129"> </a><code class="cCode">*tree</code> is a pointer to a Boolean tree previously compiled by <code class="cCode">Fboolco</code>.</li>
<li><a name="wp1058130"> </a><code class="cCode">*iop</code> is a pointer of type <code class="cCode">FILE</code> to an output file stream.</li>
</ul></div>
<p class="pBody"><a name="wp1058131"> </a>
<code class="cCode">Fvboolpr</code> prints a compiled expression to the specified file stream. 
</p>
<a name="wp1058132"> </a><div class="pPreformatted"><pre>void<br />Fvboolpr(char *tree, FILE *iop, char *viewname)</pre></div><p class="pBody"><a name="wp1058133"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1058134"> </a><code class="cCode">*tree</code> is a pointer to a Boolean tree previously compiled by <code class="cCode">Fvboolco</code>.</li>
<li><a name="wp1058135"> </a><code class="cCode">*iop</code> is a pointer of type <code class="cCode">FILE</code> to an output file stream.</li>
<li><a name="wp1058136"> </a><code class="cCode">*viewname</code> is the name of the view whose fields are used.</li>
</ul></div>
<p class="pBody"><a name="wp1058137"> </a>
This function is useful for debugging.
</p>
<p class="pBody"><a name="wp1058138"> </a>
Executing <code class="cCode">Fboolpr</code> on the expression compiled above produces the following results:
</p>
<a name="wp1058139"> </a><div class="pPreformatted"><pre>(((FIRSTNAME[0]) %% (&#39;J.*n&#39;)) &amp;&amp; ((SEX[0]) == (&#39;M&#39;)))</pre></div><p class="pBody"><a name="wp1064638"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fboolpr,&#160;Fboolpr32,&#160;Fvboolpr,&#160;Fvboolpr32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<h3 class="pHeading2"><a name="wp1058140"> </a>
Fboolev and Ffloatev, Fvboolev and Fvfloatev
</h3>
<p class="pBody"><a name="wp1058141"> </a>
These functions evaluate a fielded buffer against a Boolean expression.
</p>
<p class="pBody"><a name="wp1058142"> </a>
<code class="cCode">int Fboolev(FBFR *</code><code class="cCodeEmphasis">fbfr</code><code class="cCode">,char *</code><code class="cCodeEmphasis">tree</code><code class="cCode">)<br />double Ffloatev(FBFR *</code><code class="cCodeEmphasis">fbfr</code><code class="cCode">,char *</code><code class="cCodeEmphasis">tree</code><code class="cCode">)</code>
</p>
<p class="pBody"><a name="wp1058143"> </a>
Here: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1058144"> </a><code class="cCodeEmphasis">fbfr</code> is the fielded buffer referenced by an evaluation tree produced by <code class="cCode">Fboolco</code>.</li>
<li><a name="wp1058145"> </a><code class="cCodeEmphasis">tree</code> is a pointer to an evaluation tree that references the fielded buffer pointed to by <code class="cCode">fbfr</code>.</li>
</ul></div>
<p class="pBody"><a name="wp1058146"> </a>
The VIEW equivalents are as follows: 
</p>
<a name="wp1058147"> </a><div class="pPreformatted"><pre>int<br />Fvboolev(FBFR *<code class="cCodeEmphasis">fbfr</code>,char *<code class="cCodeEmphasis">tree</code>,char *<code class="cCodeEmphasis">viewname</code>)</pre></div><a name="wp1058148"> </a><div class="pPreformatted"><pre>double<br />Fvfloatev(FBFR *<code class="cCodeEmphasis">fbfr</code>,char *<code class="cCodeEmphasis">tree</code>,char *<code class="cCodeEmphasis">viewname</code>)</pre></div><p class="pBody"><a name="wp1058149"> </a>
<code class="cCode">Fboolev</code> returns true (1) if the fielded buffer matches the Boolean conditions specified in the evaluation tree. This function does not change either the fielded buffer or the evaluation tree. Using the evaluation tree compiled above, the following code prints &#8220;Buffer selected&#8221;:
</p>
<a name="wp1058150"> </a><div class="pPreformatted"><pre>#include &lt;stdio.h&gt;<br />#include &quot;fml.h&quot;<br />#include &quot;fldtbl.h&quot;<br />FBFR *fbfr;<br />. . .<br />Fchg(fbfr,FIRSTNAME,0,&quot;John&quot;,0);<br />Fchg(fbfr,SEX,0,&quot;M&quot;,0);<br />if(Fboolev(fbfr,tree) &gt; 0)<br />  fprintf(stderr,&quot;Buffer selected\n&quot;);<br />else<br />  fprintf(stderr,&quot;Buffer not selected\n&quot;);</pre></div><p class="pBody"><a name="wp1058151"> </a>
<code class="cCode">Ffloatev</code> and <code class="cCode">Ffloatev32</code> are similar to <code class="cCode">Fboolev</code>, but return the value of the expression as a <code class="cCode">double</code>. For example, the following code prints &#8220;6.6&#8221;:
</p>
<a name="wp1058152"> </a><div class="pPreformatted"><pre>#include &lt;stdio.h&gt;<br />#include &quot;fml.h&quot;<br />FBFR *fbfr;<br />. . .<br />main() {<br />  char *Fboolco;<br />  char *tree;<br />  double Ffloatev;<br />  if (tree=Fboolco(&quot;3.3+3.3&quot;)) {<br />      printf(&quot;%lf&quot;,Ffloatev(fbfr,tree));<br />  }<br />}</pre></div><p class="pBody"><a name="wp1058153"> </a>
If <code class="cCode">Fboolev</code> is used instead of <code class="cCode">Ffloatev</code> in the previous example, a 1 is printed.
</p>
<p class="pBody"><a name="wp1064661"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fboolev,&#160;Fboolev32,&#160;Fvboolev,&#160;Fvboolev32(3fml)</a> and <a href="../rf3fml/rf3fml.html">Ffloatev,&#160;Ffloatev32,&#160;Fvfloatev,&#160;Fvfloatev32(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1058155"> </a>
VIEW Conversion to and from Target Format
</h2><p class="pBody"><a name="wp1058156"> </a>
A VIEW can be converted to and from a target record format. The default target format is that of IBM System/370 COBOL records.
</p>
<h3 class="pHeading2"><a name="wp1058157"> </a>
Fvstot, Fvftos and Fcodeset
</h3>
<p class="pBody"><a name="wp1058158"> </a>
The following functions convert targets:
</p>
<a name="wp1058159"> </a><div class="pPreformatted"><pre>long<br />Fvstot(char *cstruct, char *trecord, long treclen, char *viewname)</pre></div><a name="wp1058160"> </a><div class="pPreformatted"><pre>long<br />Fvttos(char *cstruct, char *trecord, char *viewname)</pre></div><a name="wp1058161"> </a><div class="pPreformatted"><pre>int <br />Fcodeset(char *translation_table)</pre></div><p class="pBody"><a name="wp1058162"> </a>
The <code class="cCode">Fvstot</code> function transfers data from a C structure to a target record type. The <code class="cCode">Fvttos</code> function transfers data from a target record to a C structure. <code class="cCode">trecord</code> is a pointer to the target record. <code class="cCodeEmphasis">cstruct</code> is a pointer to a C structure. <code class="cCode">viewname</code> is a pointer to the name of a compiled view description. The <code class="cCode">VIEWDIR</code> and <code class="cCode">VIEWFILES</code> environment variables are used to find the directory and file containing the compiled view description.
</p>
<p class="pBody"><a name="wp1058163"> </a>
To convert an FML buffer to a target record, complete the following procedure.
</p>
<div class="pSmartList1"><ol type="1" class="pSmartList1">
<li><a name="wp1058164"> </a>Call <code class="cCode">Fvftos</code> to convert the FML buffer to a C structure.</li>
<li><a name="wp1058165"> </a>Call <code class="cCode">Fvstot</code> to convert to a target record. </li>
</ol></div>
<p class="pBody"><a name="wp1058166"> </a>
To convert a target record to an FML buffer, complete the following procedure.
</p>
<div class="pSmartList1"><ol type="1" class="pSmartList1">
<li><a name="wp1058167"> </a>Call <code class="cCode">Fvttos</code> to convert to a C structure.</li>
<li><a name="wp1058168"> </a>Call <code class="cCode">Fvstof</code> to convert the structure to an FML buffer.</li>
</ol></div>
<p class="pBody"><a name="wp1058169"> </a>
The default target is that of IBM/370 COBOL records. The default data conversion is done as shown in the following table.
</p>
<p class="pBody"><a name="wp1058218"> </a>
No filler bytes are provided between fields in an IBM/370 record. The COBOL SYNC clause should not be specified for any data items that are a part of the structure corresponding to the view. An integer field is converted to either a four-byte or two-byte integer, depending on the size of integers on the machine on which the conversion is done. A string field in the view must be terminated with a null when converting to and from the IBM/370 format. The data in a <code class="cCode">carray</code> field is passed unchanged; no data translation is performed.
</p>
<p class="pBody"><a name="wp1058219"> </a>
Packed decimals exist in the IBM/370 environment as two decimal digits packed into one byte with the low-order half byte used to store the sign. The length of a packed decimal may be 1 to 16 bytes with storage available for 1 to 31 digits and a sign. Packed decimals are supported in C structures using the <code class="cCode">dec_t</code> field type. The <code class="cCode">dec_t</code> field has a defined size consisting of two numbers separated by a comma. The number to the left of the comma is the total number of bytes occupied by the decimal. The number to the right is the number of digits to the right of the decimal point. The following formula is used for conversion:
</p>
<a name="wp1058220"> </a><div class="pPreformatted"><pre>dec_t(<em class="cEmphasis">m, n</em>) &lt;=&gt; S9(2*<em class="cEmphasis">m</em>-(<em class="cEmphasis">n</em>+1))V9(<em class="cEmphasis">n</em>)COMP-3</pre></div><p class="pBody"><a name="wp1058221"> </a>
Decimal values may be converted to and from other data types (such as <code class="cCode">int</code>, <code class="cCode">long</code>, <code class="cCode">string</code>, <code class="cCode">double</code>, and <code class="cCode">float</code>) using the functions described in <a href="../rf3c/rf3c.html">decimal(3c)</a>.
</p>
<p class="pBody"><a name="wp1058222"> </a>
See the <a href="../rf3fml/rf3fml.html">Fvstof,&#160;Fvstof32(3fml)</a> for a description of the default character conversion of ASCII to EBCDIC, and vice-versa.
</p>
<p class="pBody"><a name="wp1058223"> </a>
An alternate character translation table can be used at run time by calling <code class="cCode">Fcodeset</code>. The <code class="cCode">translation_table</code> must point to 512 bytes of binary data. The first 256 bytes of data are interpreted as the ASCII-to-EBCDIC translation table. The second 256 bytes of data are interpreted as the EBCDIC-to-ASCII table. Any data after the 512th byte is ignored. If the pointer is NULL, the default translation is used. 
</p>
<p class="pBody"><a name="wp1064682"> </a>
For more information, refer to <a href="../rf3fml/rf3fml.html">Fvstot,&#160;Fvttos(3fml)</a> in <em class="cEmphasis">Oracle Tuxedo ATMI FML Function Reference</em>.
</p>
 
<br/>
    <table id="SummaryNotReq2" width="100%" border="0" cellpadding="0" cellspacing="0">
      <tr> 
        <td>
&nbsp;
<a href="fml05.html"><img id="LongDescNotReq8" src="/global_resources/images/backtop.gif" width="90" height="25" alt="Back to Top" title="Back to Top" border="0" /></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a accesskey="4" href="fml04.html"><img id="LongDescNotReq9" src="/global_resources/images/prevtop.gif" border="0" alt="Previous" /></a>&nbsp;
<a accesskey="5" href="fml06.html"><img id="LongDescNotReq10" src="/global_resources/images/nexttop.gif" border="0" alt="Next" /></a>
<script language="Javascript1.1" type="text/javascript">
Copyright();
</script>
<noscript><a href="http://edocs.bea.com/copyright.html">&copy; BEA Systems</a></noscript>
        </td>
      </tr>
    </table>

<!-- WebAnalytics BEGIN -->

<!--#include virtual="/global_resources/edocs_wt.html"-->
      
<!-- WebAnalytics END -->

  </body>
</html>
