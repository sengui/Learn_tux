<?Fm Document txc04.fm?>
<Chapter Id = "g1023232">
<?Fm Condition HardcopyHide Blue NO_OVERRIDE show?>

<?Fm Condition HardcopyOnly Blue NO_OVERRIDE show?>

<?Fm Condition SoftcopyOnly Magenta NO_OVERRIDE show?>

<?Fm Condition Hide Blue NO_OVERRIDE show?>

<?Fm Condition RevRec Red NO_OVERRIDE hide?>

<?Fm Condition BetaDraft Red NO_OVERRIDE show?>

<?Fm Condition Comment Magenta NO_OVERRIDE show?>

<?Fm Condition HTML Blue NO_OVERRIDE show?>

<?Fm Condition PSPDF AsIs NO_OVERRIDE show?>

<Title Id = "i1007698">Building RPC Client and Server Programs</Title>
<?Fm Condstart Comment?><Comment>&lsqb;oc--the first image has a GraphicDesc element added to it. you need to add it to the rest of the images in this chapter.&rsqb;</Comment><?Fm Condend Comment?>
<Para>This topic includes the following sections:</Para>
<ItemizedList mark = "Bullet"><ListItem><Para><XRef Role = "Section Head Number &#x0026; Title" Linkend = "i1006512"/></Para></ListItem>
<ListItem><Para><XRef Role = "Section Head Number &#x0026; Title" Linkend = "i1006517"/></Para></ListItem>
<ListItem><Para><XRef Role = "Section Head Number &#x0026; Title" Linkend = "i1006558"/></Para></ListItem>
<ListItem><Para><XRef Role = "Section Head Number &#x0026; Title" Linkend = "i1018899"/></Para></ListItem>
<ListItem><Para><XRef Role = "Section Head Number &#x0026; Title" Linkend = "i1006847"/></Para></ListItem>
<ListItem><Para><XRef Role = "Section Head Number &#x0026; Title" Linkend = "i1006903"/></Para></ListItem></ItemizedList>
<Sect1 Id = "i1006512"><Title>Prerequisite Knowledge</Title>
<Para>The TxRPC programmer should be familiar with the C compilation system and building Oracle Tuxedo ATMI clients and servers. Information on building Oracle Tuxedo ATMI clients and servers is provided in the &programc;, &programc;, and &programfml;. Building Workstation clients is provided in &workstation;.</Para></Sect1>
<Sect1 Id = "i1006517"><Title>Building an RPC Server</Title>
<Para>RPC servers are built and configured in much that same way that ATMI Request&sol;Response servers are. In fact, the service name space for RPC and Request&sol;Response servers is the same. However, the names advertised for RPC services are different. For Request&sol;Response servers, a service name is mapped to a procedure. For RPC servers, a service name is mapped to an IDL interface name. The RPC service advertised will be <Emphasis Role = "CodeInline">&lt;</Emphasis><Emphasis Role = "CodeInlineItalic">interface</Emphasis><Emphasis Role = "CodeInline">>v&lt;</Emphasis><Emphasis Role = "CodeInlineItalic">major</Emphasis><Emphasis Role = "CodeInline">>&lowbar;&lt;</Emphasis><Emphasis Role = "CodeInlineItalic">minor</Emphasis><Emphasis Role = "CodeInline">></Emphasis>, where <Emphasis Role = "CodeInline">&lt;</Emphasis><Emphasis Role = "CodeInlineItalic">interface</Emphasis><Emphasis Role = "CodeInline">></Emphasis> is the interface name, and <Emphasis Role = "CodeInline">&lt;</Emphasis><Emphasis Role = "CodeInlineItalic">major</Emphasis><Emphasis Role = "CodeInline">></Emphasis> and <Emphasis Role = "CodeInline">&lt;</Emphasis><Emphasis Role = "CodeInlineItalic">minor</Emphasis><Emphasis Role = "CodeInline">></Emphasis> are the major and minor numbers of the version, as specified (or defaulted to 0.0) in the interface definition. Because the service name is limited to 15 characters, this limits the length of the interface name to 13 characters minus the number of digits in the major and minor version numbers. This also implies that an exact match is used on major AND minor version numbers because of the way name serving is done in the Oracle Tuxedo system. Note that the interface, and not individual operations, are advertised (similar to DCE&sol;RPC). The server stub automatically takes care of calling the correct operation within the interface.</Para>
<Para>RPC servers are built using the <Emphasis Role = "CodeInline">buildserver(1)</Emphasis> command. We recommend using the <Emphasis Role = "CodeInline">-s</Emphasis> option to specify the service (interface) names at compilation time. The server can then be booted using the <Emphasis Role = "CodeInline">-A</Emphasis> option to get the services automatically advertised. This approach is used in the sample application, as shown in <XRef Role = "Appendix Number &#x0026; Title (period)" Linkend = "g1027039"/></Para>
<Para>The <Emphasis Role = "CodeInline">buildserver(1)</Emphasis> command automatically links in the Oracle Tuxedo libraries. However, the RPC run time must be linked in explicitly. This is done by specifying the <Emphasis Role = "CodeInline">-f -ltrpc</Emphasis> option after any application files on the <Emphasis Role = "CodeInline">buildserver</Emphasis> line. Normally, the output of the <Emphasis Role = "CodeInline">tidl(1)</Emphasis> command is a server stub object file. This can be passed directly to the <Emphasis Role = "CodeInline">buildserver</Emphasis> command. Note that the server stub and the application source, object, and library files implementing the operations should be specified ahead of the run-time library, also using the <Emphasis Role = "CodeInline">-f</Emphasis> option. See the makefile <Emphasis Role = "CodeInline">rpcsimp.mk</Emphasis>, in <XRef Role = "Appendix Number &#x0026; Title (comma)" Linkend = "g1027039"/> for an example.</Para></Sect1>
<Sect1 Id = "i1006558"><Title>Building an RPC Client</Title>
<Para>A native RPC client is built using the <Emphasis Role = "CodeInline">buildclient(1)</Emphasis> command. This command automatically links in the Oracle Tuxedo libraries. However, the RPC run time must be linked in explicitly. This is done by specifying the <Emphasis Role = "CodeInline">-f -ltrpc</Emphasis> option after any application files on the <Emphasis Role = "CodeInline">buildclient</Emphasis> command line. Generally, the output of the <Emphasis Role = "CodeInline">tidl(1)</Emphasis> command is a client stub object file. This can be passed directly to the <Emphasis Role = "CodeInline">buildclient</Emphasis> command. Note that the client stub and the application source, object, and library files executing the remote procedure calls should be specified ahead of the run-time library, also using the <Emphasis Role = "CodeInline">-f</Emphasis> option. For an example, see the makefile <Emphasis Role = "CodeInline">rpcsimp.mk</Emphasis> in <XRef Role = "Appendix Number &#x0026; Title (period)" Linkend = "g1027039"/></Para>
<Para>To build a UNIX Workstation client, simply add the <Emphasis Role = "CodeInline">-w</Emphasis> option to the <Emphasis Role = "CodeInline">buildclient(1)</Emphasis> command line so that the Workstation libraries are linked in instead of the native libraries.</Para></Sect1>
<Sect1 Id = "i1018899"><Title>Building a Windows Workstation RPC Client</Title>
<Para>Compilation of the client stub for Windows requires the <Emphasis Role = "CodeInline">-D&lowbar;TM&lowbar;WIN</Emphasis> definition as a compilation option. This ensures that the correct function prototypes for the TxRPC and Oracle Tuxedo ATMI run time functions are used. While the client stub source is the same, it must be compiled specially to handle the fact that the text and data segments for the DLL will be different from the code calling it. The header file and stub are automatically generated to allow for the declarations to be changed easily, using C preprocessor definitions. The definition <Emphasis Role = "CodeInline">&lowbar;TMF</Emphasis> (for "far") appears before all pointers in the header file and <Emphasis Role = "CodeInline">&lowbar;TMF</Emphasis> is automatically defined as "<Emphasis Role = "CodeInline">&lowbar;far</Emphasis>" if <Emphasis Role = "CodeInline">&lowbar;TM&lowbar;WIN</Emphasis> is defined.</Para>
<Para>In most cases, using standard libraries, the <Emphasis Role = "CodeInline">buildclient(1)</Emphasis> command can be used to link the client. The library to be used is <Emphasis Role = "CodeInline">wtrpc.lib</Emphasis>.</Para>
<Para>The sample also shows how to create a Dynamic Link Library (DLL) using the client stub. This usage will be very popular when used with a visual application builder that requires DLL use (where the application code cannot be statically linked in). Windows functions are traditionally declared to have the <Emphasis Role = "CodeInline">&lowbar;pascal</Emphasis> calling convention. The header file and stub are automatically generated to allow for the declarations to be changed easily, using C preprocessor definitions. <Emphasis Role = "CodeInline">&lowbar;TMX</Emphasis> (for "eXport") appears before all declared functions. By default, this definition is defined to nothing. When compiling a stub for inclusion in a DLL, <Emphasis Role = "CodeInline">&lowbar;TMX</Emphasis> should be defined to <Emphasis Role = "CodeInline">&lowbar;far &lowbar;pascal</Emphasis>. Also, the files to be included in the DLL must be compiled with the large memory model. Because using <Emphasis Role = "CodeInline">&lowbar;pascal</Emphasis> automatically converts the function names to uppercase in the library, it is a good idea to run with the <Emphasis Role = "CodeInline">-port case</Emphasis> option turned on, which does additional validation to see if two declared names differ only in case.</Para>
<Para>A complete example of building a Windows DLL is shown in <XRef Role = "Appendix Number &#x0026; Title (period)" Linkend = "g1027039"/></Para>
<Note><InformalTable Colsep = "0" Frame = "Topbot" Rowsep = "0" Summary = "This is a layout table to format a note" Tabstyle = "Note" Title = "Note"><TGroup Cols = "1" Colsep = "0" Rowsep = "0" TGroupStyle = "Note">
<ColSpec Colname = "1" Colnum = "1" Colsep = "0" Colwidth = "4.333313in"/>
<TBody>
<Row Rowsep = "0">
<Entry Colname = "1"><Para>Note</Para>
<Para>A compilation error may occur if a TxRPC client includes <Emphasis Role = "CodeInline">windows.h</Emphasis>, due to a duplicate <Emphasis Role = "CodeInline">uuid&lowbar;t</Emphasis> definition. It will be necessary for the application to either not include <Emphasis Role = "CodeInline">windows.h</Emphasis> (because it is included already) or to include it within a different file in the application.</Para></Entry>
</Row>
</TBody>
</TGroup></InformalTable></Note></Sect1>
<Sect1 Id = "i1006847"><Title>Using C&plus;&plus;</Title>
<Para>Clients and servers can be built using C or C&plus;&plus;, interchangeably. The header files and generated stub source files are defined in such a way that all Stub Support functions and generated operations allow for complete interoperability between C&plus;&plus; and C. They are declared with C linkage, that is, as extern "C," so that name mangling is turned off.</Para>
<Para>The stub object files can be built using C&plus;&plus; by specifying <Emphasis Role = "CodeInline">CC -c</Emphasis> for the <Emphasis Role = "CodeInline">-cc&lowbar;cmd</Emphasis> option of <Emphasis Role = "CodeInline">tidl(1)</Emphasis>. The <Emphasis Role = "CodeInline">CC</Emphasis> command can be used to compile and link client and server programs by setting and exporting the <Emphasis Role = "CodeInline">CC</Emphasis> environment variable before running <Emphasis Role = "CodeInline">buildclient(1)</Emphasis> and <Emphasis Role = "CodeInline">buildserver(1)</Emphasis>. For example: </Para>
<InformalExample><ProgramListing>tidl -cc&lowbar;cmd "CC -c" -keep all t.idl</ProgramListing>
<ProgramListing>CC&equals;CC buildserver -o server -s tv1&lowbar;0 -f "-I. t&lowbar;sstub.o server.c -ltrpc"</ProgramListing>
<ProgramListing></ProgramListing></InformalExample>
<Para>In the Windows environment, C&plus;&plus; compilation is normally accomplished via a flag on the compilation command line or a configuration option rather than a different command name. Use the appropriate options to get C&plus;&plus; compilation.</Para></Sect1>
<Sect1 Id = "i1006903"><Title>Interoperating with DCE&sol;RPC</Title>
<Para>The Oracle Tuxedo TxRPC compiler uses the same IDL interface as OSF&sol;DCE but the generated stubs do not use the same protocol. Thus, an Oracle Tuxedo TxRPC stub cannot directly communicate with a stub generated by the DCE IDL compiler.</Para>
<Para>However, it is possible to have the following interoperations between DCE&sol;RPC and Oracle Tuxedo TxRPC: </Para>
<ItemizedList mark = "Bullet"><ListItem><Para>Client side stubs from both DCE and Oracle Tuxedo TxRPC can be called from the same program (either client or server).</Para></ListItem>
<ListItem><Para>An Oracle Tuxedo ATMI server stub can call application code that calls a DCE client stub (as well as an Oracle Tuxedo TxRPC client stub).</Para></ListItem>
<ListItem><Para>A DCE server (manager) can call application code that calls an Oracle Tuxedo TxRPC client stub.</Para></ListItem></ItemizedList>
<Para>The following sections show possible interactions between Oracle Tuxedo TxRPC and OSF&sol;DCE. In each case, the originator of the request is called the requester. This term is used instead of "client" because the requester could, in fact, be a DCE or Oracle Tuxedo ATMI service making a request of another service. The terms "client" and "server" refer to the client and server stubs generated by the IDL compilers (either DCE <Emphasis Role = "CodeInline">idl</Emphasis>(1) or Oracle Tuxedo <Emphasis Role = "CodeInline">tidl(1)</Emphasis>); these terms are used for consistency with the DCE and TxRPC terminology. Finally, the term "application service" is used for the application code that implements the procedure that is being called remotely (it is generally transparent whether the invoking software is the server stub generated by DCE or Oracle Tuxedo).</Para>
<Sect2><Title>Oracle Tuxedo Requester to DCE Service via Oracle Tuxedo Gateway</Title>
<Figure><Title>Oracle Tuxedo Requester to DCE Service via Oracle Tuxedo Gateway</Title>
<Graphic Role = "AnAnchor"><GraphicFile xoffset = "0.014in" yoffset = "0.014in" Entityref = "GraphicFile4" position = "inline" dpi = "150" impby = "ref" sideways = "0" impang = "0.000" align = "acenter" cropped = "0" float = "0" width = "3.354in" height = "0.408in" angle = "0.000" bloffset = "0.000in" nsoffset = "0.000in"/>
<?Fm Condstart HTML?><GraphicDesc><Para>Replace this text with an adequate description of the above image.</Para>
</GraphicDesc><?Fm Condend HTML?></Graphic></Figure>
<Para>The first approach uses a "gateway" such that the Oracle Tuxedo ATMI client stub invokes an Oracle Tuxedo ATMI server stub, via TxRPC, that has a DCE client stub linked in (instead of the application services) that invokes the DCE services, via DCE RPC. The advantage to this approach is that it is not necessary to have DCE on the client platform. In fact, the set of machines running Oracle Tuxedo and the set of machines running DCE could be disjoint except for one machine where all such gateways are running. This also provides a migration path with the ability to move services between Oracle Tuxedo and DCE. A sample application that implements this approach is described in <XRef Role = "Appendix Number &#x0026; Title (period)" Linkend = "g1026316"/></Para>
<Para>In this configuration, the requester is built as a normal Oracle Tuxedo ATMI client or server. Similarly, the server is built as a normal DCE server. The additional step is to build the gateway process which acts as an Oracle Tuxedo ATMI server using a TxRPC server stub and a DCE client using a DCE&sol;RPC client stub.</Para>
<Para>The process of running the two IDL compilers and linking the resultant files is simplified with the use of the <Emphasis Role = "CodeInline">blds&lowbar;dce(1)</Emphasis> command, which builds an Oracle Tuxedo ATMI server with DCE linked in.</Para>
<Para>The usage for <Emphasis Role = "CodeInline">blds&lowbar;dce</Emphasis> is as follows:</Para>
<InformalExample><ProgramListing>blds&lowbar;dce &lsqb;-o <Emphasis Role = "Italic">output&lowbar;file</Emphasis>&rsqb; &lsqb;-i <Emphasis Role = "Italic">idl&lowbar;options</Emphasis>&rsqb; &lsqb;-f <Emphasis Role = "Italic">firstfiles</Emphasis>&rsqb; &lsqb;-l <Emphasis Role = "Italic">lastfile</Emphasis>&rsqb; &bsol;</ProgramListing>
<ProgramListing>   &lsqb;<Emphasis Role = "Italic">idl&lowbar;file</Emphasis> . . . &rsqb;</ProgramListing>
<ProgramListing></ProgramListing></InformalExample>
<Para>The command takes as input one or more IDL files so that the gateway can handle one or more interfaces. For each one of these files, <Emphasis Role = "CodeInline">tidl</Emphasis> is run to generate a server stub and <Emphasis Role = "CodeInline">idl</Emphasis> is run to generate a client stub.</Para>
<Para>This command knows about various DCE environments and provides the necessary compilation flags and DCE libraries for compilation and linking. If you are developing in a new environment, it may be necessary to modify the command to add the options and libraries for your environment.</Para>
<Para>This command compiles the source files in such a way (with -<Emphasis Role = "CodeInline">DTMDCEGW</Emphasis> defined) that memory allocation is always done using <Emphasis Role = "CodeInline">rpc&lowbar;ss&lowbar;allocate</Emphasis>(3c) and <Emphasis Role = "CodeInline">rpc&lowbar;ss&lowbar;free</Emphasis>(3c), as described in the &ref3c;. This ensures that memory is freed on return from the Oracle Tuxedo ATMI server. The use of -<Emphasis Role = "CodeInline">DTMDCEGW</Emphasis> also includes DCE header files instead of Oracle Tuxedo TxRPC header files.</Para>
<Para>The IDL output object files are compiled, optionally with specified application files (using the -<Emphasis Role = "CodeInline">f</Emphasis> and -<Emphasis Role = "CodeInline">l</Emphasis> options), to generate an Oracle Tuxedo ATMI server using <Emphasis Role = "CodeInline">buildserver(1)</Emphasis>. The name of the executable server can be specified with the -<Emphasis Role = "CodeInline">o</Emphasis> option.</Para>
<Para>When running this configuration, the DCE server would be started first in the background, then the Oracle Tuxedo configuration including the DCE gateway would be booted, and then the requester would be run. Note that the DCE gateway is single-threaded so you will need to configure and boot as many gateway servers as you want concurrently executing services.</Para>
<Para>There are several optional things to consider when building this gateway.</Para>
<Sect3><Title>Setting the DCE Login Context</Title>
<Para>First, as a DCE client, it is normal that the process runs as some DCE principal. There are two approaches to getting a login context. One approach is to "log in" to DCE. In some environments, this occurs simply by virtue of logging into the operating system. In many environments, it requires running <Emphasis Role = "CodeInline">dce&lowbar;login</Emphasis>. If the Oracle Tuxedo ATMI server is booted on the local machine, then it is possible to run <Emphasis Role = "CodeInline">dce&lowbar;login</Emphasis>, then run <Emphasis Role = "CodeInline">tmboot(1)</Emphasis> and the booted server will inherit the login context. If the server is to be booted on a remote machine which is done indirectly via <Emphasis Role = "CodeInline">tlisten(1)</Emphasis>, it is necessary to run <Emphasis Role = "CodeInline">dce&lowbar;login</Emphasis> before starting <Emphasis Role = "CodeInline">tlisten</Emphasis>. In each of these cases, all servers booted in the session will be run by the same principal. The other drawback to this approach is that the credentials will eventually expire.</Para>
<Para>The other alternative is to have the process set up and maintain its own login context. The  <Xulink Url = "../../rf3c/rf3c.html"><Emphasis Role = "CodeInline">tpsvrinit(3c)</Emphasis></Xulink> function provided for the server can set up the context and then start a thread that will refresh the login context before it expires. Sample code to do this is provided in <Emphasis Role = "CodeInline">&dollar;TUXDIR&sol;lib&sol;dceserver.c</Emphasis>; it must be compiled with the -<Emphasis Role = "CodeInline">DTPSVRINIT</Emphasis> option to generate a simple <Emphasis Role = "CodeInline">tpsvrinit()</Emphasis> function. (It can also be used as the <Emphasis Role = "CodeInline">main()</Emphasis> for a DCE server, as described in the following section.) This code is described in further detail in <XRef Role = "Appendix Number &#x0026; Title (period)" Linkend = "g1026316"/></Para></Sect3>
<Sect3><Title>Using DCE Binding Handles</Title>
<Para>Oracle Tuxedo TxRPC does not support binding handles. When sending an RPC from the requester's client stub to the server stub within the gateway, the Oracle Tuxedo system handles all of the name resolution and choosing the server, doing load balancing between available servers. However, when going from the gateway to the DCE server, it is possible to use DCE binding. If this is done, it is recommended that two versions of the IDL file be used in the same directory or that two different directories be used to build the requester, and the gateway and server. The former approach of using two different filenames is shown in the example with the IDL file linked to a second name. In the initial IDL file, no binding handles or binding attributes are specified. With the second IDL file, which is used to generate the gateway and DCE server, there is an associated ACF file that specifies &lsqb;explicit&lowbar;handle&rsqb; such that a binding handle is inserted as the first parameter of the operation. From the Oracle Tuxedo server stub in the gateway, a NULL handle will be generated (because handles aren't supported). That means that somewhere between the Oracle Tuxedo ATMI server stub and the DCE client stub in the gateway, a valid binding handle must be generated.</Para>
<Para>This can be done by making use of the manager entry point vector. By default, the IDL compiler defines a structure with a function pointer prototype for each operation in the interface, and defines and initializes a structure variable with default function names based on the operation names. The structure is defined as:</Para>
<InformalExample><ProgramListing>&lt;<Emphasis Role = "Italic">INTERF</Emphasis>>&lowbar;v&lt;<Emphasis Role = "Italic">major</Emphasis>>&lowbar;&lt;<Emphasis Role = "Italic">minor</Emphasis>>&lowbar;epv&lowbar;t&lt;<Emphasis Role = "Italic">INTERF</Emphasis>>&lowbar;v&lt;<Emphasis Role = "Italic">major</Emphasis>>&lowbar;&lt;<Emphasis Role = "Italic">minor</Emphasis>>&lowbar;s&lowbar;epv </ProgramListing>
<ProgramListing></ProgramListing></InformalExample>
<Para>where <Emphasis Role = "CodeInline">&lt;</Emphasis><Emphasis Role = "CodeInlineItalic">INTERF</Emphasis><Emphasis Role = "CodeInline">></Emphasis> is the interface name and <Emphasis Role = "CodeInline">&lt;</Emphasis><Emphasis Role = "CodeInlineItalic">major</Emphasis><Emphasis Role = "CodeInline">>&lowbar;&lt;</Emphasis><Emphasis Role = "CodeInlineItalic">minor</Emphasis><Emphasis Role = "CodeInline">></Emphasis> is the interface version. This variable is dereferenced when calling the server stub functions. The IDL compiler option, <Emphasis Role = "CodeInline">-no&lowbar;mepv</Emphasis>, inhibits the definition and initialization of this variable, allowing the application to provide it in cases where there is a conflict or difference in function names and operation names. In the case where an application wants to provide explicit or implicit binding instead of automatic binding, the <Emphasis Role = "CodeInline">-no&lowbar;mepv</Emphasis> option can be specified, and the application can provide a structure definition that points to functions taking the same parameters as the operations but different (or static) names. The functions can then create a valid binding handle that is passed, either explicitly or implicitly, to the DCE&sol;RPC client stub functions (using the actual operation names).</Para>
<Para>This is shown in the example in <XRef Role = "Appendix Number &#x0026; Title (period)" Linkend = "g1026316"/> The file <Emphasis Role = "CodeInline">dcebind.c</Emphasis> generates the binding handle, and the entry point vector and associated functions are shown in <Emphasis Role = "CodeInline">dceepv.c</Emphasis>.</Para>
<Para>Note that to specify the <Emphasis Role = "CodeInline">-no&lowbar;mepv</Emphasis> option when using the <Emphasis Role = "CodeInline">blds&lowbar;dce</Emphasis>, the <Emphasis Role = "CodeInline">-i -no&lowbar;mepv</Emphasis> option must be specified so that the option is passed through to the IDL compiler. This is shown in the makefile, <Emphasis Role = "CodeInline">rpcsimp.mk</Emphasis>, in <XRef Role = "Appendix Number &#x0026; Title (period)" Linkend = "g1026316"/></Para></Sect3>
<Sect3><Title>Authenticated RPC</Title>
<Para>Now that we have a login context and a handle, it is possible to use authenticated RPC calls. As part of setting up the binding handle, it is also possible to annotate the binding handle for authentication by calling <Emphasis Role = "CodeInline">rpc&lowbar;binding&lowbar;set&lowbar;auth&lowbar;info</Emphasis>(), as described in the &ref3c;. This is shown as part of generating the binding handle in <Emphasis Role = "CodeInline">dcebind.c</Emphasis> in <XRef Role = "Appendix Number &#x0026; Title (period)" Linkend = "g1026316"/> This sets up the authentication (and potentially encryption) between the gateway and the DCE server. If the requester is an Oracle Tuxedo ATMI server, then it is guaranteed to be running as the Oracle Tuxedo administrator. For more information about authentication for Oracle Tuxedo clients, see <Emphasis Role = "Italic">Administering the Oracle Tuxedo System</Emphasis>.</Para></Sect3>
<Sect3><Title>Transactions</Title>
<Para>OSF&sol;DCE does not support transactions. That means that if the gateway is running in a group with a resource manager and the RPC comes into the Oracle Tuxedo ATMI client stub in transaction mode, the transaction will not <Emphasis Role = "CodeInline">carray</Emphasis> to the DCE server. There is not much you can do to solve this; just be aware of it.</Para></Sect3></Sect2>
<Sect2><Title>DCE Requester to Oracle Tuxedo Service Using Oracle Tuxedo Gateway</Title>
<Figure><Title>DCE Requester to Oracle Tuxedo Service Using Oracle Tuxedo Gateway</Title>
<Graphic Role = "AnAnchor"><GraphicFile xoffset = "0.014in" yoffset = "0.014in" Entityref = "GraphicFile5" position = "inline" dpi = "150" impby = "ref" sideways = "0" impang = "0.000" align = "acenter" cropped = "0" float = "0" width = "3.354in" height = "0.408in" angle = "0.000" bloffset = "0.000in" nsoffset = "0.000in"/></Graphic></Figure>
<Para>In the preceding figure, the DCE requester uses a DCE client stub to invoke a DCE service which calls the Oracle Tuxedo ATMI client stub (instead of the application services), which invokes the Oracle Tuxedo ATMI service (via TxRPC). Note that in this configuration, the client has complete control over the DCE binding and authentication. The fact that the application programmer builds the middle server means that the application also controls the binding of the DCE server to Oracle Tuxedo ATMI service. This approach would be used in the case where the DCE requester does not want to directly link in and call the Oracle Tuxedo system.</Para>
<Para>The <Emphasis Role = "CodeInline">main()</Emphasis> for the DCE server should be based on the code provided in <Emphasis Role = "CodeInline">&dollar;TUXDIR&sol;lib&sol;dceserver.c</Emphasis>. If you already have your own template for the <Emphasis Role = "CodeInline">main()</Emphasis> of a DCE server, there are a few things that may need to be added or modified.</Para>
<Para>First, <Emphasis Role = "CodeInline">tpinit(3c)</Emphasis> should be called to join the ATMI application. If application security is configured, then additional information may be needed in the <Emphasis Role = "CodeInline">TPINIT</Emphasis> buffer such as the username and application password. Prior to exiting, <Emphasis Role = "CodeInline">tpterm(3c)</Emphasis> should be called to cleanly terminate participation in the ATMI application. If you look at <Emphasis Role = "CodeInline">dceserver.c</Emphasis>, you will see that by compiling it with -<Emphasis Role = "CodeInline">DTCLIENT</Emphasis>, code is included that calls <Emphasis Role = "CodeInline">tpinit</Emphasis> and <Emphasis Role = "CodeInline">tpterm</Emphasis>. The code that sets up the <Emphasis Role = "CodeInline">TPINIT</Emphasis> buffer must be modified appropriately for your application. To provide more information with respect to administration, it might be helpful to indicate that the client is a DCE client in either the user or client name (the example sets the client name to <Emphasis Role = "CodeInline">DCECLIENT</Emphasis>). This information shows up when printing client information from the administration interface.</Para>
<Para>Second, since the Oracle Tuxedo ATMI system software is not thread-safe, the threading level passed to <Emphasis Role = "CodeInline">rpc&lowbar;server&lowbar;listen</Emphasis> must be set to 1. In the sample <Emphasis Role = "CodeInline">dceserver.c</Emphasis>, the threading level is set to 1 if compiled with -<Emphasis Role = "CodeInline">DTCLIENT</Emphasis> and to the default, <Emphasis Role = "CodeInline">rpc&lowbar;c&lowbar;listen&lowbar;max&lowbar;calls&lowbar;default</Emphasis>, otherwise. (For more information, refer to the &ref3c;.)</Para>
<Para>In this configuration, the requester is built as a normal DCE client or server. Similarly, the server is built as a normal Oracle Tuxedo ATMI server. The additional step is to build the gateway process, which acts as an Oracle Tuxedo ATMI client using a TxRPC client stub, and a DCE server, using a DCE&sol;RPC server stub.</Para>
<Para>The process of running the two IDL compilers and linking the resultant files is simplified with the use of the <Emphasis Role = "CodeInline">bldc&lowbar;dce(1)</Emphasis> command which builds an Oracle Tuxedo ATMI client with DCE linked in.</Para>
<Para>The usage for <Emphasis Role = "CodeInline">bldc&lowbar;dce</Emphasis> is as follows:</Para>
<InformalExample><ProgramListing>bldc&lowbar;dce &lsqb;-o <Emphasis Role = "Italic">output&lowbar;file</Emphasis>&rsqb; &lsqb;-w&rsqb; &lsqb;-i <Emphasis Role = "Italic">idl&lowbar;options</Emphasis>&rsqb; &lsqb;-f <Emphasis Role = "Italic">firstfiles</Emphasis>&rsqb; &bsol;</ProgramListing>
<ProgramListing>   &lsqb;-l <Emphasis Role = "Italic">lastfiles</Emphasis>&rsqb; &lsqb;<Emphasis Role = "Italic">idl&lowbar;file</Emphasis> . . . &rsqb;</ProgramListing>
<ProgramListing></ProgramListing></InformalExample>
<Para>The command takes as input one or more IDL files so that the gateway can handle one or more interfaces. For each one of these files, <Emphasis Role = "CodeInline">tidl</Emphasis> is run to generate a client stub and <Emphasis Role = "CodeInline">idl</Emphasis> is run to generate a server stub.</Para>
<Para>This command knows about various DCE environments and provides the necessary compilation flags and DCE libraries. If you are developing in a new environment, it may be necessary to modify the command to add the options and libraries for your environment. The source is compiled in such a way (with -<Emphasis Role = "CodeInline">DTMDCEGW</Emphasis> defined) that memory allocation is always done using <Emphasis Role = "CodeInline">rpc&lowbar;ss&lowbar;allocate</Emphasis> and <Emphasis Role = "CodeInline">rpc&lowbar;ss&lowbar;free</Emphasis> (described in the &ref3c;) to ensure that memory is freed on return. The use of -<Emphasis Role = "CodeInline">DTMDCEGW</Emphasis> also includes DCE header files instead of Oracle Tuxedo TxRPC header files.</Para>
<Para>The IDL output object files are compiled, optionally with specified application files (using the -<Emphasis Role = "CodeInline">f</Emphasis> and -<Emphasis Role = "CodeInline">l</Emphasis> options), to generate an Oracle Tuxedo ATMI client using <Emphasis Role = "CodeInline">buildclient(1)</Emphasis>. Note that one of the files included should be the equivalent of the <Emphasis Role = "CodeInline">dceserver.o</Emphasis>, compiled with the -<Emphasis Role = "CodeInline">DTCLIENT</Emphasis> option.</Para>
<Para>The name of the executable client can be specified with the -<Emphasis Role = "CodeInline">o</Emphasis> option.</Para>
<Para>When running this configuration, the Oracle Tuxedo ATMI configuration must be booted before starting the DCE server so that it can join the Oracle Tuxedo ATMI application before listening for DCE requests.</Para></Sect2>
<Sect2><Title>Oracle Tuxedo Requester to DCE Service Using DCE-only</Title>
<Figure><Title>Oracle Tuxedo Requester to DCE Service Using DCE-only</Title>
<Graphic Role = "AnAnchor"><GraphicFile xoffset = "0.014in" yoffset = "0.014in" Entityref = "GraphicFile6" position = "inline" dpi = "150" impby = "ref" sideways = "0" impang = "0.000" align = "acenter" cropped = "0" float = "0" width = "2.188in" height = "0.408in" angle = "0.000" bloffset = "0.000in" nsoffset = "0.000in"/></Graphic></Figure>
<Para>This approach assumes that the DCE environment is directly available to the client (this can be a restriction or disadvantage in some configurations). The client program has direct control over the DCE binding and authentication. Note that this is presumably a mixed environment in which the requester is either an Oracle Tuxedo ATMI service that calls DCE services, or an Oracle Tuxedo client (or server) that calls both Oracle Tuxedo and DCE services.</Para>
<Para>When compiling Oracle Tuxedo TxRPC code that will be used mixed with DCE code, the code must be compiled such that DCE header files are used instead of the TxRPC header files. This is done by defining -<Emphasis Role = "CodeInline">DTMDCE</Emphasis> at compilation time, both for client and server stub files and for your application code. If you are generating object files from <Emphasis Role = "CodeInline">tidl(1)</Emphasis>, you must add the <Emphasis Role = "CodeInline">-cc&lowbar;opt -DTMDCE</Emphasis> option to the command line. The alternative is to generate <Emphasis Role = "CodeInline">c&lowbar;source</Emphasis> from the IDL compiler and pass this C source (not object files) to <Emphasis Role = "CodeInline">bldc&lowbar;dce or blds&lowbar;dce</Emphasis> as in the following examples: </Para>
<InformalExample><ProgramListing>tidl -keep c&lowbar;source -server none t.idl</ProgramListing>
<ProgramListing>idl -keep c&lowbar;source -server none dce.idl</ProgramListing>
<ProgramListing>bldc&lowbar;dce -o output&lowbar;file -f client.c -f t&lowbar;cstub.c -f dce&lowbar;cstub.c</ProgramListing>
<ProgramListing></ProgramListing></InformalExample>
<Para>or</Para>
<InformalExample><ProgramListing>blds&lowbar;dce -o output&lowbar;file -s service -f server.c -f t&lowbar;cstub.c -f dce&lowbar;cstub.c</ProgramListing>
<ProgramListing></ProgramListing></InformalExample>
<Para>In this example, we are not building a gateway process so <Emphasis Role = "CodeInline">.idl</Emphasis> files <Emphasis Role = "Italic">cannot</Emphasis> be specified to the <Emphasis Role = "CodeInline">build</Emphasis> commands. Also note that the <Emphasis Role = "CodeInline">blds&lowbar;dce</Emphasis> command cannot figure out the service name associated with the server so it must be supplied on the command line using the -<Emphasis Role = "CodeInline">s</Emphasis> option.</Para></Sect2>
<Sect2 Id = "i1006908"><Title>DCE Requester to Oracle Tuxedo Service Using Oracle Tuxedo-only</Title>
<Figure><Title>DCE Requester to Oracle Tuxedo Service Using Oracle Tuxedo-only</Title>
<Graphic Role = "AnAnchor"><GraphicFile xoffset = "0.014in" yoffset = "0.014in" Entityref = "GraphicFile7" position = "inline" dpi = "150" impby = "ref" sideways = "0" impang = "0.000" align = "acenter" cropped = "0" float = "0" width = "2.188in" height = "0.408in" angle = "0.000" bloffset = "0.000in" nsoffset = "0.000in"/></Graphic></Figure>
<Para>In this final case, the DCE requester calls the Oracle Tuxedo client stub directly.</Para>
<Para>Again, -<Emphasis Role = "CodeInline">DTMDCE</Emphasis> must be used at compilation time, both for client and server stub files and for your application code. In this case the requester must be an Oracle Tuxedo ATMI client: </Para>
<InformalExample><ProgramListing>tidl -keep c&lowbar;source -client none t.idl</ProgramListing>
<ProgramListing>bldc&lowbar;dce -o output&lowbar;file -f -DTCLIENT -f dceserver.c -f t&lowbar;cstub.c</ProgramListing>
<ProgramListing></ProgramListing></InformalExample>
<Para>Note that <Emphasis Role = "CodeInline">dceserver.c</Emphasis> should call <Emphasis Role = "CodeInline">tpinit(3c)</Emphasis> to join the application and <Emphasis Role = "CodeInline">tpterm(3c)</Emphasis> to leave the application, as was discussed earlier.</Para></Sect2>
<Sect2><Title>Building Mixed DCE&sol;RPC and Oracle Tuxedo TxRPC Clients and Servers</Title>
<Para>This section summarizes the rules to follow if you are compiling a mixed client or server without using the <Emphasis Role = "CodeInline">bldc&lowbar;dce(1)</Emphasis> or <Emphasis Role = "CodeInline">blds&lowbar;dce(1)</Emphasis> commands: </Para>
<ItemizedList mark = "Bullet"><ListItem><Para>When compiling the generated client and server stubs, and compiling the client and server application software that includes the header file generated by <Emphasis Role = "CodeInline">tidl(1)</Emphasis>, <Emphasis Role = "CodeInline">TMDCE</Emphasis> must be defined (for example, <Emphasis Role = "CodeInline">-DTMDCE&equals;1</Emphasis>). This causes some DCE header files to be used instead of the Oracle Tuxedo TxRPC header files. Also, some versions of DCE have a DCE compilation shell that adds the proper directories for the DCE header files and ensures the proper DCE definitions for the local environment. This shell should be used instead of directly using the C compiler. The DCE&sol;RPC compiler and TMDCE definition can be specified using the <Emphasis Role = "CodeInline">-cc&lowbar;cmd</Emphasis> option on <Emphasis Role = "CodeInline">tidl</Emphasis>. For example:</Para>
<InformalExample><ProgramListing>tidl -cc&lowbar;cmd "&sol;opt&sol;dce&sol;bin&sol;cc -c -DTMDCE&equals;1" simp.idl</ProgramListing>
<ProgramListing></ProgramListing></InformalExample>
<Para>or </Para>
<InformalExample><ProgramListing>tidl -keep c&lowbar;source simp.idl </ProgramListing>
<ProgramListing> &sol;opt&sol;dce&sol;bin&sol;cc -DTMDCE&equals;1 -c -I. -I&dollar;TUXDIR&sol;include simp&lowbar;cstub.c</ProgramListing>
<ProgramListing> &sol;opt&sol;dce&sol;bin&sol;cc -DTMDCE&equals;1 -c -I. -I&dollar;TUXDIR&sol;include client.c</ProgramListing>
<ProgramListing></ProgramListing></InformalExample>
<Para>On a system without such a compiler shell, it might look like the following: </Para>
<InformalExample><ProgramListing>cc &lt;<Emphasis Role = "Italic">DCE options</Emphasis>> -DTMDCE&equals;1 -c -I. -I&dollar;(<Emphasis Role = "Italic">TUXDIR</Emphasis>)&sol;include &bsol;</ProgramListing>
<ProgramListing>   -I&sol;usr&sol;include&sol;dce simp&lowbar;cstub.c</ProgramListing>
<ProgramListing></ProgramListing></InformalExample>
<Para>Refer to the DCE&sol;RPC documentation for your environment.</Para></ListItem>
<ListItem><Para>If the server makes an RPC call, then <Emphasis Role = "CodeInline">set&lowbar;client&lowbar;alloc&lowbar;free()</Emphasis> should be called to set the use of <Emphasis Role = "CodeInline">rpc&lowbar;ss&lowbar;allocate()</Emphasis> and <Emphasis Role = "CodeInline">rpc&lowbar;ss&lowbar;free()</Emphasis>, as described earlier. (For more information, refer to the &ref3c;.)</Para></ListItem>
<ListItem><Para>When linking the executable, use <Emphasis Role = "CodeInline">-ldrpc</Emphasis> instead of <Emphasis Role = "CodeInline">-ltrpc</Emphasis> to get a version of the Oracle Tuxedo TxRPC runtime that is compatible with DCE&sol;RPC. For example:</Para></ListItem></ItemizedList>
<InformalExample><ProgramListing>buildclient -o client -f client.o -f simp&lowbar;cstub.o -f dce&lowbar;cstub.o &bsol;</ProgramListing>
<ProgramListing>   -f-ldrpc -f-ldce -f-lpthreads -f-lc&lowbar;r</ProgramListing>
<ProgramListing></ProgramListing></InformalExample>
<Para>or </Para>
<InformalExample><ProgramListing>CC&equals;&sol;opt&sol;dce&sol;bin&sol;cc buildclient -d " " -f client.o -f simp&lowbar;cstub.o &bsol; </ProgramListing>
<ProgramListing>   -f dce&lowbar;cstub.o -f -ldrpc -o client</ProgramListing>
<ProgramListing></ProgramListing></InformalExample>
<Para>Assume that <Emphasis Role = "CodeInline">simp&lowbar;cstub.o</Emphasis> was generated by <Emphasis Role = "CodeInline">tidl(1)</Emphasis> and <Emphasis Role = "CodeInline">dce&lowbar;cstub.o</Emphasis> was generated by <Emphasis Role = "CodeInline">idl</Emphasis>. The first example shows building the client without a DCE compiler shell; in this case, the DCE library (<Emphasis Role = "CodeInline">-ldce</Emphasis>), threads library (<Emphasis Role = "CodeInline">-lpthreads</Emphasis>), and re-entrant C library (<Emphasis Role = "CodeInline">-lc&lowbar;r</Emphasis>) must be explicitly specified. The second example shows the use of a DCE compiler shell which transparently includes the necessary libraries. In some environments, the libraries included by <Emphasis Role = "CodeInline">buildserver</Emphasis> and <Emphasis Role = "CodeInline">buildclient</Emphasis> for networking and XDR will conflict with the libraries included by the DCE compiler shell (there may be re-entrant versions of these libraries). In this case, the <Emphasis Role = "CodeInline">buildserver(1)</Emphasis> and <Emphasis Role = "CodeInline">buildclient(1)</Emphasis> libraries may be modified using the <Emphasis Role = "CodeInline">-d</Emphasis> option. If a link problem occurs, trying using <Emphasis Role = "CodeInline">-d " "</Emphasis> to leave out the networking and XDR libraries, as shown in the example above. If the link still fails, try running the command without the <Emphasis Role = "CodeInline">-d</Emphasis> option and with the <Emphasis Role = "CodeInline">-v</Emphasis> option to determine the libraries that are used by default; then use the <Emphasis Role = "CodeInline">-d</Emphasis> option to specify a subset of the libraries if there is more than one. The correct combination of libraries is environment-dependent because the networking, XDR, and DCE libraries vary from one environment to another.</Para>
<Note><InformalTable Colsep = "0" Frame = "Topbot" Rowsep = "0" Summary = "This is a layout table to format a note" Tabstyle = "Note" Title = "Note"><TGroup Cols = "1" Colsep = "0" Rowsep = "0" TGroupStyle = "Note">
<ColSpec Colname = "1" Colnum = "1" Colsep = "0" Colwidth = "4.333313in"/>
<TBody>
<Row Rowsep = "0">
<Entry Colname = "1"><Para>Note</Para>
<Para>Mixing DCE and Oracle Tuxedo TxRPC stubs is not currently supported on Windows.</Para></Entry>
</Row>
</TBody>
</TGroup></InformalTable></Note></Sect2></Sect1></Chapter>
