<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>

<!-- LOCALIZATION RELATED INFORMATION -->
<meta name="LOC_PROJ_ID" content="WLPF8.1" />
<meta name="LOC_OWNER" content="BEAJ" />
<meta name="LOC_STATUS" content="READY!" />
<meta name="LOC_COMMENT" content="LOC_COMMENT" />
<meta name="LOC_US_REV" content="2" />
<meta name="LOC_US_CHANGE" content="41908" />
<meta name="LOC_US_SRCFILE" content="//depot/tuxedo/tux12c/CORBA_ref/fm/tpfw.fm" />
<!-- LOCALIZATION RELATED INFORMATION -->

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="GENERATOR" content="Quadralay WebWorks AutoMap 2003 Platinum Edition for FrameMaker 8.6.6577.0" />
    <meta name="TEMPLATEBASE" content="BEA_WFP_Template_V1.04" />
    <meta name="LASTUPDATED" content="06/26/12 11:01:17" />
    <link rel="StyleSheet" href="/global_resources/edocs.css" type="text/css" media="all" />

<title>TP Framework</title>

<!-- BEA scripts begin -->

<script language="Javascript" src="/global_resources/js/banner.js" type="text/javascript"></script>
<!-- This script outputs the banner required for edocs documentation. -->

<script language="Javascript" src="floatwin.js" type="text/javascript"></script>
<!-- This script opens a new small floating window and puts TOC<i>&lt;name&gt;</i>.html and IX<i>&lt;name&gt;</i>.html files in it and sets a generic popup window code to enable the display of some viewlets in the WebLogic Platform Tour. -->

<script language="Javascript1.1" src="/global_resources/js/footer.js" type="text/javascript"></script>
<!-- This script outputs the footer with the correct copyright date and link to copyright page.-->

<script language="Javascript1.1" src="/global_resources/js/googlesearch4.js" type="text/javascript"></script>
<!-- This script outputs the google search form. -->

<script language="Javascript1.1" src="/global_resources/js/note.js" type="text/javascript"></script>
<!-- This script outputs a note such as a BETA note. -->

<script language="JavaScript1.1" src="/global_resources/js/search.js" type="text/javascript"></script>
<!-- This script is not for online documents. It is only used by the QuestAgent Java Applet for CD search indexes. -->

<!-- BEA scripts end -->

  </head>

  <body>


<script language="Javascript1.1" type="text/javascript">
GoogleURL();
</script><noscript>This script outputs the google search URL required for search on edocs documentation.</noscript>

<script language="Javascript1.1" type="text/javascript">
Banner();
</script><noscript>This script outputs the banner required for edocs documentation.</noscript>

<script language="Javascript1.1" type="text/javascript">
GoogleSearchCollection();
</script><noscript>This script outputs the google search parameters required for search on edocs documentation.</noscript>

<!-- page title -->
<h1 class="booktitle">CORBA Programming Reference
</h1>
<!-- page title end -->

    <table id="SummaryNotReq1" width="100%" border="0" align="left" cellpadding="2%" cellspacing="0">
      <tr> 
        <td>
&nbsp;&nbsp;&nbsp;&nbsp;
<a accesskey="4" href="imp_cnfg.html"><img id="LongDescNotReq1" src="/global_resources/images/doc_nav_prev.gif" border="0" alt="Previous" /></a>&nbsp;
<a accesskey="5" href="boot.html"><img id="LongDescNotReq2" src="/global_resources/images/doc_nav_next.gif" border="0" alt="Next" /></a>&nbsp;
<img id="LongDescNotReq3" src="/global_resources/images/doc_nav_dots.gif" border="0" alt="" />&nbsp;
<a accesskey="1" href="javascript:OpenWindowToc();" onmouseover="window.status='Table of Contents'; return true" onfocus="window.status='Table of Contents'; return true" onmouseout="window.status=''; return true" onblur="window.status=''; return true" title="Open TOC in new window">      <img id="LongDescNotReq4" src="/global_resources/images/doc_nav_contents.gif" alt="Open TOC in new window" border="0" /></a>&nbsp;
&nbsp;
<a href="../pdf/CORBA_ref.pdf" target="pdf"><img id="LongDescNotReq5" src="/global_resources/images/doc_nav_pdf.gif" width="59" height="44" alt="View as PDF - New Window" title="View as PDF - New Window" border="0" /></a>&nbsp;
<a href="http://www.adobe.com/products/acrobat/alternate.html" target="_blank"><img id="LongDescNotReq6" src="/global_resources/images/get_reader.gif" width="52" height="44" alt="Get Adobe Reader - New Window" title="Get Adobe Reader - New Window" border="0" /></a>
<a name="link_group_0"></a>
	</td>
      </tr>
    </table>

<a name="skipnav" title="Content starts here"><img src="/global_resources/images/_.gif" alt="Content starts here" border="0" height="1" width="1" /></a>



<h1 class="pChapHead"><a name="wp1152965"> </a>
TP Framework
</h1>
<p class="pBody"><a name="wp1096987"> </a>
This topic includes the following sections:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1096993"> </a><a href="tpfw.html#wp1020212">A Simple Programming Model</a>. This section describes:</li>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1092558"> </a><a href="tpfw.html#wp1021701">Control Flow</a></li>
<li><a name="wp1093008"> </a><a href="tpfw.html#wp1021713">Object State Management</a></li>
<li><a name="wp1093018"> </a><a href="tpfw.html#wp1022181">Transaction Integration</a></li>
<li><a name="wp1093023"> </a><a href="tpfw.html#wp1023606">Object Housekeeping</a></li>
<li><a name="wp1093028"> </a><a href="tpfw.html#wp1023609">High-level Services</a></li>
</ul></div>
<li><a name="wp1093042"> </a><a href="tpfw.html#wp1029459">State Management</a>. This section describes:</li>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1092579"> </a><a href="tpfw.html#wp1029465">Activation Policy</a></li>
<li><a name="wp1093060"> </a><a href="tpfw.html#wp1032093">Application-controlled Activation and Deactivation</a></li>
<li><a name="wp1093069"> </a><a href="tpfw.html#wp1062648">Servant Lifetime</a></li>
<li><a name="wp1093074"> </a><a href="tpfw.html#wp1036047">Saving and Restoring Object State</a></li>
</ul></div>
<li><a name="wp1093094"> </a><a href="tpfw.html#wp1037991">Transactions</a>. This section describes:</li>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1092982"> </a><a href="tpfw.html#wp1039795">Transaction Policies</a></li>
<li><a name="wp1093100"> </a><a href="tpfw.html#wp1041353">Transaction Initiation</a></li>
<li><a name="wp1093105"> </a><a href="tpfw.html#wp1099586">Transaction Termination</a></li>
<li><a name="wp1093118"> </a><a href="tpfw.html#wp1043452">Transaction Suspend and Resume</a></li>
<li><a name="wp1093123"> </a><a href="tpfw.html#wp1043475">Restrictions on Transactions</a></li>
<li><a name="wp1093128"> </a><a href="tpfw.html#wp1043789">SQL and Global Transactions</a></li>
<li><a name="wp1093133"> </a><a href="tpfw.html#wp1045227">Voting on Transaction Outcome</a></li>
<li><a name="wp1161343"> </a><a href="tpfw.html#wp1045904">Transaction Timeouts</a></li>
</ul></div>
<li><a name="wp1161347"> </a><a href="tpfw.html#wp1155499">IIOP Client Failover</a></li>
<li><a name="wp1168240"> </a><a href="tpfw.html#wp1168162">WebLogic CORBA Clustering and Load Balancing Support</a></li>
<li><a name="wp1092987"> </a><a href="tpfw.html#wp1170256">Parallel Objects</a></li>
<li><a name="wp1099855"> </a><a href="tpfw.html#wp1099879">TP Framework API</a></li>
<li><a name="wp1092992"> </a><a href="tpfw.html#wp1019900">Error Conditions, Exceptions, and Error Messages</a></li>
</ul></div>
<p class="pBody"><a name="wp1092549"> </a>
The Oracle Tuxedo CORBA TP Framework provides a programming TP Framework that enables users to create servers for high-performance TP applications. This chapter describes the TP Framework programming model and the TP Framework application programming interface (API) in detail. Additional information about how to use this API can be found in <a href="../cservers/index.html">Creating CORBA Server Applications</a>.
</p>
<p class="pBody"><a name="wp1026483"> </a>
The TP Framework is required when developing Oracle Tuxedo CORBA servers. Later releases will relax this requirement, though it is expected that most customers will use the TP Framework as an integral part of their applications.
</p>
<p class="pBody"><a name="wp1099453"> </a>
Oracle Tuxedo provides the infrastructure for providing load balancing, transactional capabilities, and administrative infrastructure. The base API used by the TP Framework is the CORBA API with Oracle extensions. The TP Framework API is exposed to customers. The Oracle Tuxedo ATMI is an optional API that can be mixed in with TP Framework APIs, allowing a customer to deploy distributed applications using a mix of CORBA servers and ATMI servers.
</p>
<p class="pBody"><a name="wp1099460"> </a>
Before Oracle Tuxedo CORBA, ORB products did not approach Oracle Tuxedo&#8217;s performance in large-scale environments. Oracle Tuxedo systems support applications that can process hundreds of transactions per second. These applications are built using the Oracle Tuxedo stateless-service programming model that minimizes the amount of system resources used for each request, and thus maximizes throughput and price performance.
</p>
<p class="pBody"><a name="wp1093218"> </a>
Now, Oracle Tuxedo CORBA and its TP Framework give customers a way to develop CORBA applications with performance similar to Oracle Tuxedo ATMI applications. Oracle Tuxedo CORBA servers provide throughput, response time, and price performance approaching the Oracle Tuxedo stateless-service programming model, while using the CORBA programming model.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1020212"> </a>
A Simple Programming Model
</h2><p class="pBody"><a name="wp1097121"> </a>
The TP Framework provides a simple, useful subset of the wide range of possible CORBA object implementation choices. You use it for the development of server-side object implementations only. When using any client-side CORBA ORB, clients interact with CORBA objects whose server-side implementations are managed by the TP Framework. Clients are unaware of the existence of the TP Framework&#8212;a client written to access a CORBA object executing in a non-Oracle Tuxedo server environment will be able to access that same CORBA object executing in an Oracle Tuxedo server environment without any changes or restrictions to the client interface.
</p>
<p class="pBody"><a name="wp1020220"> </a>
The TP Framework provides a server environment and an API that is easier to use and understand than the CORBA Portable Object Adapter (POA) API, and is specifically geared towards enterprise applications. It is a simple server programming model and an orthodox implementation of the CORBA model, which will be familiar to programmers using ORBs such as ORBIX or VisiBroker.
</p>
<p class="pBody"><a name="wp1021687"> </a>
The TP Framework simplifies the programming of Oracle Tuxedo CORBA servers by reducing the complexity of the server environment in the following ways:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1021689"> </a>The TP Framework does all interactions with the POA and the Naming Service. The application programmer requires no knowledge of POA or Naming Service interfaces.</li>
<li><a name="wp1021691"> </a>The TP Framework is single threaded&#8212;only one request on one CORBA object will be processed at a time, obviating the need to write thread-safe implementations.</li>
<li><a name="wp1021693"> </a>A CORBA object may be involved in only one transaction at a time (consistent with the association of one object ID to one servant).</li>
</ul></div>
<p class="pBody"><a name="wp1021695"> </a>
The TP Framework provides the following functionality:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1021696"> </a>Control Flow</li>
<li><a name="wp1021697"> </a>Object State Management</li>
<li><a name="wp1021698"> </a>Transaction Integration</li>
<li><a name="wp1021699"> </a>Object Housekeeping</li>
<li><a name="wp1021700"> </a>High-level Services</li>
</ul></div>
<h3 class="pHeading2"><a name="wp1021701"> </a>
Control Flow
</h3>
<p class="pBody"><a name="wp1021702"> </a>
The TP Framework, in conjunction with the ORB and the POA, controls the flow of the application program by doing the following:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1021704"> </a>Controlling the server mainline and invoking callback methods on TP Framework-defined classes at appropriate times for server startup and shutdown. This relieves the application programmer from complex interactions related to ORB and POA initialization and coordination of transactions, resource managers, and object state on shutdown.</li>
<li><a name="wp1021708"> </a>Scheduling objects for activation and deactivation when client requests arrive and are completed. This removes the complexity of management of object activation and deactivation from the realm of the application programmer and enables the use of the TP monitor infrastructure&#8217;s powerful load-balancing capabilities, crucial to performance of mission-critical tasks.</li>
</ul></div>
<h3 class="pHeading2"><a name="wp1021713"> </a>
Object State Management
</h3>
<p class="pBody"><a name="wp1021714"> </a>
The TP Framework API provides callback methods for application code to implement flexible state management schemes for CORBA objects. State management involves the saving and restoring of object state on object deactivation and activation. It also concerns the duration of activation of objects, which influences the performance of servers and their resource usage. The default duration of object activation is controlled by policies assigned to implementations at IDL compile time.
</p>
<h3 class="pHeading2"><a name="wp1022181"> </a>
Transaction Integration
</h3>
<p class="pBody"><a name="wp1021682"> </a>
TP Framework transaction integration provides the following features:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1023594"> </a>CORBA objects can participate in global transactions.</li>
<li><a name="wp1023595"> </a>Objects participating in transactions can be implemented as stateful objects that remain in memory for the duration of a transaction (by using the transaction activation policy), to decrease client response time.</li>
<li><a name="wp1023598"> </a>CORBA objects that participate in transactions can affect transaction outcome either during their transactional work or just prior to the system&#8217;s execution of the two-phase commit algorithm after all transactional work has been completed.</li>
<li><a name="wp1023601"> </a>Transactions can be automatically initiated on the server transparent to the client.</li>
</ul></div>
<h3 class="pHeading2"><a name="wp1023606"> </a>
Object Housekeeping
</h3>
<p class="pBody"><a name="wp1023607"> </a>
When a server is shut down, the TP Framework rolls back any transactions that the server is involved in and deactivates any CORBA objects that are currently active.
</p>
<h3 class="pHeading2"><a name="wp1023609"> </a>
High-level Services
</h3>
<p class="pBody"><a name="wp1023610"> </a>
The TP interface in the TP Framework API provides methods for performing object registrations and utility functions. The following services are provided:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1025054"> </a>Object reference creation</li>
<li><a name="wp1023613"> </a>Factory-based routing support</li>
<li><a name="wp1023614"> </a>Accessors for system objects, such as the ORB</li>
<li><a name="wp1023615"> </a>Registration and unregistration of factories with the FactoryFinder</li>
<li><a name="wp1023616"> </a>Application-controlled activation and deactivation</li>
<li><a name="wp1023617"> </a>User logging</li>
</ul></div>
<p class="pBody"><a name="wp1023618"> </a>
The purpose of these high-level service methods is to eliminate the need for developers to understand the CORBA POA, CORBA Naming Service, and Oracle Tuxedo APIs, which they use for their underlying implementations. By encapsulating the underlying API calls with a high-level set of methods, programmers can focus their efforts on providing business logic rather than understanding and using the more complex underlying facilities.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1029459"> </a>
State Management
</h2><p class="pBody"><a name="wp1029460"> </a>
State management involves the saving and restoring of object state on object deactivation and activation. It also concerns the duration of activation of objects, which influences the performance of servers and their resource usage. The external API of the TP Framework provides <code class="cCode">activate_object</code> and <code class="cCode">deactivate_object</code> methods, which are a possible location for state management code.
</p>
<h3 class="pHeading2"><a name="wp1029465"> </a>
Activation Policy
</h3>
<p class="pBody"><a name="wp1029466"> </a>
State management is provided in the TP Framework by the activation policy. This policy controls the activation and deactivation of servants for a particular IDL interface (as opposed to the creation and destruction of the servants). This policy is applicable only to CORBA objects using the TP Framework.
</p>
<p class="pBody"><a name="wp1029915"> </a>
The activation policy determines the default in-memory activation duration for a CORBA object. A CORBA object is active in a POA if the POA&#39;s active object map contains an entry that associates an object ID with an existing servant. Object deactivation removes the association of an object ID with its active servant. You can choose from one of three activation policies:<code class="cCode"> method</code> (the default), <code class="cCode">transaction</code>, or <code class="cCode">process</code>.
</p>
<a name="wp1032040"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The activation policies are set in an ICF file that is configured at OMG IDL compile time. For a description of the ICF file, refer to the <a href="imp_cnfg.html">Implementation Configuration File (ICF)</a> section.</td>
</tr>
</table>

<p class="pBody"><a name="wp1032072"> </a>
The activation policies are described below:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1032073"> </a><code class="cCode">method</code> (This is the default activation policy.)</li>
<p class="pBodyRelative"><a name="wp1032074"> </a>
The activation of the CORBA object (that is, the association between the object ID and the servant) lasts until the end of the method. At the completion of a method, the object is deactivated. When the next method is invoked on the object reference, the CORBA object is activated (the object ID is associated with a new servant). This behavior is similar to that of an Oracle Tuxedo stateless service.
</p>
<li><a name="wp1030264"> </a><code class="cCode">transaction</code> </li>
<p class="pBodyRelative"><a name="wp1031826"> </a>
The activation of the CORBA object (that is, the association between the object ID and the servant) lasts until the end of the transaction. During the transaction, multiple object methods can be invoked. The object is activated before the first method invocation on the object and is deactivated in one of the following ways:
</p>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1030267"> </a>If a user-initiated transaction is in effect when the object is activated, the object is deactivated when the first of the following occurs: the transaction is committed or rolled back, or the server is shut down in an orderly fashion. The latter is done using either the <code class="cCode">tmshutdown</code> or <code class="cCode">tmadmin</code> command. These commands are described in the <a href="../rfcm/index.html">Oracle Tuxedo Command Reference</a> online document.</li>
<li><a name="wp1030335"> </a>If a user-initiated transaction is not in effect when the TP object is activated, the TP object is deactivated when the method completes.</li>
<p class="pBodyRelative"><a name="wp1099505"> </a>
The <code class="cCode">transaction</code> activation policy provides a means for an object to vote on the outcome of the transaction prior to the execution of the two-phase commit algorithm. An object votes to roll back the transaction by calling <code class="cCode">Current.rollback_only()</code> in the <code class="cCode">Tobj_ServantBase::deactivate_object</code> method. It votes to commit the transaction by not calling <code class="cCode">Current.rollback_only()</code> in the method.
</p>
<a name="wp1099506"> </a><table class="ListNote">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>This is a model of resource allocation that is similar to that of an Oracle Tuxedo conversational service. However, this model is less expensive than the<span style="font-weight: bold"> </span>Oracle Tuxedo conversational service in that it uses fewer system resources. This is because of the Oracle Tuxedo ORB&#8217;s multicontexted dispatching model (that is, the presence of many servants in memory at the same time for one server), which makes it possible for a single server process to be shared by many concurrently active servants that service many clients. In the Oracle Tuxedo system, the process would be dedicated to a single client and to only one service for the duration of a conversation.</td>
</tr>
</table>

</ul></div>
<li><a name="wp1030342"> </a><code class="cCode">process</code></li>
<p class="pBodyRelative"><a name="wp1031863"> </a>
The activation of the CORBA object begins when it is invoked while in an inactive state and, by default, lasts until the end of the process. 
</p>
<a name="wp1031974"> </a><table class="ListNote">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The TP Framework API provides an interface method (<code class="cCode">TP::deactivateEnable</code>) that allows the application to control the timing of object deactivation for objects that have the <code class="cCode">activation policy</code> set to <code class="cCode">process</code>. For a description of this method, see the section <a href="tpfw.html#wp1017782">TP::deactivateEnable()</a>.</td>
</tr>
</table>

</ul></div>
<h3 class="pHeading2"><a name="wp1032093"> </a>
Application-controlled Activation and Deactivation
</h3>
<p class="pBody"><a name="wp1032094"> </a>
Ordinarily, activation and deactivation decisions are made by the TP Framework, as discussed earlier in this chapter. The techniques in this section show how to use alternate mechanisms. The application can control the timing of activation and deactivation explicitly for objects with particular policies.
</p>
<h4 class="pHeading3"><a name="wp1032097"> </a>
Explicit Activation
</h4>
<p class="pBody"><a name="wp1032098"> </a>
Application code can bypass the on-demand activation feature of the TP Framework for objects that use the <code class="cCode">process</code> activation policy. The application can &#8220;preactivate&#8221; an object (that is, activate it before any invocation) using the <code class="cCode">TP::create_active_object_reference</code> call.
</p>
<p class="pBody"><a name="wp1077388"> </a>
Preactivation works as follows. Before the application creates an object reference, the application instantiates a servant and initializes that servant&#8217;s state. The application uses <code class="cCode">TP::create_active_object_reference</code> to put the object into the Active Object Map (that is, associate the servant with an <code class="cCode">ObjectId</code>). Then, when the first invocation is made, the TP Framework immediately directs the request to the process that created the object reference and then to the existing servant, bypassing the necessity to call <code class="cCode">Server::create_servant</code> and then the servant&#8217;s <code class="cCode">activate_object</code> method (just as if this were the second or later invocation on the object). Note that the object reference for such an object will not be directed to another server and the object will never go through on-demand activation as long as the object remains activated.
</p>
<p class="pBody"><a name="wp1060801"> </a>
Since the preactivated object has the <code class="cCode">process</code> activation policy, it will remain active until one of two events occurs: (1) the ending of the process or (2) a <code class="cCode">TP::deactivateEnable</code> call.
</p>
<h5 class="pHeading4"><a name="wp1033573"> </a>
Usage Notes
</h5>
<p class="pBody"><a name="wp1033574"> </a>
Preactivation is especially useful if the application needs to establish the servant with an initial state in the same process, perhaps using shared memory to initialize state. Waiting to initialize state until a later time and in a potentially different process may be very difficult if that state includes pointers, object references, or complex data structures. <code class="cCode">TP::create_active_object_reference</code> guarantees that the preactivated object is in the same process as the code that is doing the preactivation. While this is convenient, preactivation should be used sparingly, as should all process objects, because it preallocates precious resources. However, when needed and used properly, preallocation is more efficient than alternatives.
</p>
<p class="pBody"><a name="wp1033582"> </a>
Examples of such usage might be an object using the &#8220;iterator&#8221; pattern. For example, there might a potentially long list of items that could be returned (in an unbound IDL sequence) from a &#8220;database_query&#8221; method (for example, the contents of the telephone book). Returning all such items in the sequence is impractical because the message size and the memory requirements would be too large.
</p>
<p class="pBody"><a name="wp1083605"> </a>
On an initial call to get the list, an object using the iterator pattern returns only a limited number of items in the sequence and also returns a reference to an &#8220;iterator&#8221; object that can be invoked to receive further elements. This iterator object is initialized by the initial object; that is, the initial object creates a servant and sets its state to keep track of where in the long list of items the iteration currently stands (the pointer to the database, the query parameters, the cursor, and so forth).
</p>
<p class="pBody"><a name="wp1083606"> </a>
The initial object preactivates this iterator object by using <code class="cCode">TP::create_active_object_reference</code>. It also creates an object reference to that object to return to the client. The client then invokes repeatedly on the iterator object to receive, say, the next 100 items in the list each time. The advantage of preactivation in this situation is that the state might be complex. It is often easiest to set such state initially, from a method that has all the information in its context (call frame), when the initial object still has control.
</p>
<p class="pBody"><a name="wp1090946"> </a>
When the client is finished with the iterator object, it invokes a final method on the initial object which deacativates the iterator object. The initial object deactivates the iterator object by invoking a method on the iterator object that calls the <code class="cCode">TP::deactivateEnable</code> method, that is, the iterator object calls <code class="cCode">TP::deactivateEnable</code> on itself. 
</p>
<h5 class="pHeading4"><a name="wp1033597"> </a>
Caution to Users
</h5>
<p class="pBody"><a name="wp1033598"> </a>
For objects to be preactivated in this fashion, the state usually cannot be recovered if a crash occurs. (This is because the state was considered too complex or inconvenient to set upon initial, delayed activation.) This is a valid object technique, essentially stating that the object is valid only for a single activation period. 
</p>
<p class="pBody"><a name="wp1079582"> </a>
However, a problem may arise because of the &#8220;one-time&#8221; usage. Since a client still holds an object reference that leads to the process containing that state, and since the state cannot be recreated after the crash, care must be taken that the client&#8217;s next invocation does not automatically provoke a new activation of the object, because that object would have inapplicable state.
</p>
<p class="pBody"><a name="wp1079595"> </a>
The solution is to refuse to allow the object to be activated automatically by the TP Framework. If the user provides the <code class="cCode">TobjS::ActivateObjectFailed</code> exception to the TP Framework as a result of the <code class="cCode">activate_object</code> call, the TP Framework will not complete the activation and will return an exception to the client, <code class="cCode">CORBA::OBJECT_NOT_EXIST</code>. The client has presumably been warned about this possibility, since it knows about the iterator (or similar) pattern. The client must be prepared to restart the iteration.
</p>
<a name="wp1082700"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>This defensive measure may not be necessary in the future; the TP Framework itself may detect that the object reference is no longer valid. In particular, you should not depend on the possibility that the <code class="cCode">activate_object</code> method might be called. If the TP Framework does in fact change, activate_object will not be called and the framework itself will generate the <code class="cCode">OBJECT_NOT_EXIST</code> exception.</td>
</tr>
</table>

<h4 class="pHeading3"><a name="wp1036053"> </a>
Self Deactivation
</h4>
<p class="pBody"><a name="wp1036054"> </a>
Just as it is possible to preactivate an object with the <code class="cCode">process</code> activation policy, it is possible to request the deactivation of an object with the <code class="cCode">process</code> activation policy. The ability to preactivate and the ability to request deactivation are independent; regardless of how an object was activated, it can be deactivated explicitly.
</p>
<p class="pBody"><a name="wp1060889"> </a>
A method in the application can request (via <code class="cCode">TP::deactivateEnabl</code>e) that the object be deactivated. When <code class="cCode">TP::deactivateEnable</code> is called and the object is subsequently deactivated, no guarantee is made that subsequent invocations on the CORBA object will result in reactivation in the same process as a previous activation. The association between the <code class="cCode">ObjectId</code> and the servant exists from the activation of the CORBA object until one of the following events occurs: (1) the shutdown of the server process or (2) the application calls <code class="cCode">TP::deactivateEnable</code>. After the association is broken, when the object is invoked again, it can be reactivated anywhere that is allowed by the Oracle Tuxedo configuration parameters.
</p>
<p class="pBody"><a name="wp1061023"> </a>
There are two forms of <code class="cCode">TP::deactivateEnable</code>. In the first form (with no parameters), the object currently executing will be deactivated after completion of the method in which the call is made. The object itself makes the decision that it should be deactivated. This is often done during a method call that acts as a &quot;signoff&quot; signal.
</p>
<p class="pBody"><a name="wp1061054"> </a>
The second form of <code class="cCode">TP::deactivateEnable</code> allows a server to request deactivation of any active object, whether it is the object that is executing or not; that is, any part of the server can ask that the object be deactivated. This form takes parameters identifying the object to be deactivated. Explicit deactivation is not allowed for objects with an activation policy of <code class="cCode">transaction</code>, because such objects cannot be safely deactivated until the end of a transaction.
</p>
<p class="pBody"><a name="wp1061068"> </a>
In the <code class="cCode">TP::deactivateEnable</code> call, the TP Framework calls the servant&#8217;s <code class="cCode">deactivate_object</code> method. Exactly when the TP Framework invokes <code class="cCode">deactivate_object</code> depends on the state of the object to be deactivated. If the object is not currently in execution, the TP Framework deactivates it before returning to the caller. The object might be currently executing a method; this is always the case for <code class="cCode">TP::deactivateEnable </code>with no parameters (since it refers to the currently executing object). In this case, <code class="cCode">TP::deactivateEnable</code> is not told whether the object was deactivated immediately or not.
</p>
<a name="wp1098134"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The <code class="cCode">TP::deactivateEnable(interface, object id, servant) method</code> can be used to deactivate an object. However, if that object is currently in a transaction, the object will be deactivated when the transaction commits or rolls back. If an invoke occurs on the object before the transaction is committed or rolled back, the object will not be deactivated.</td>
</tr>
</table>

<a name="wp1098167"> </a><table class="Note">
<tr>
<td valign="top"><b class="texthide">Note:</b></td>
<td>To ensure the desired behavior, make sure that the object is not in a transaction or ensure that no invokes occur on the object after the <code class="cCode">TP::deactivateEnable()</code> call until the transaction is complete.</td>
</tr>
</table>
<h3 class="pHeading2"><a name="wp1062648"> </a>
Servant Lifetime
</h3>
<p class="pBody"><a name="wp1062664"> </a>
A servant is a C++ class that contains methods to implement an IDL interface&#8217;s operations. The user writes the servant code. The TP Framework invokes methods in the servant code to satisfy requests. The servant is created by the C++ &#8220;new&#8221; statement and is destroyed by the C++ &#8220;delete&#8221; statement. Exactly who does the creation and who does the deletion, and the timing of creation and deletion, is the subject of this section.
</p>
<h4 class="pHeading3"><a name="wp1062753"> </a>
The Normal Case
</h4>
<p class="pBody"><a name="wp1062807"> </a>
In the normal case, the TP Framework completely controls the lifetime of a servant. The basic model is that, when a request for an inactive object arrives, the TP Framework obtains a servant and then activates it (by calling its <code class="cCode">activate_object</code> method). At deactivation time, the TP Framework calls the servant&#8217;s <code class="cCode">deactivate_object</code> method and then disposes of the servant.
</p>
<p class="pBody"><a name="wp1062836"> </a>
The phase &#8220;the TP Framework obtains a servant&#8221; means that when the TP Framework needs a servant to be created, it calls a user-written Server method, either <code class="cCode">Server::create_servant</code> or <code class="cCode">ServerBase::create_servant_with_id</code>. At that time, the application code must return a pointer to the requested servant. The application almost always does this by using the C++ &#8220;new&#8221; statement to create a new instance of a servant. The phrase &#8220;disposes of the servant&#8221; means that the TP Framework removes the reference to the servant, which actually deletes it.
</p>
<p class="pBody"><a name="wp1064706"> </a>
The application must be aware that this current behavior of always creating and removing a servant may change in future versions of this product. The application should not depend on the current behavior, but should write servant code that allows reuse of a servant. Specifically, the servant code must work even if the servant has not been freshly created (by the C++ &#8220;new&#8221; statement). The TP Framework reserves the right not to remove a servant after it has been deactivated and then to reactivate it. This means that the servant must completely initialize itself at the time of the callback on the servant&#8217;s <code class="cCode">activate_object</code> method, not at the time of servant creation (not in the constructor). 
</p>
<h4 class="pHeading3"><a name="wp1064707"> </a>
Special Cases
</h4>
<p class="pBody"><a name="wp1064708"> </a>
There are two techniques an application can use to alter the normal TP Framework use of servants. The first has to do with obtaining a servant and the second has to do with disposing of the servant. 
</p>
<p class="pBody"><a name="wp1064709"> </a>
The application can alter the &#8220;obtaining&#8221; mechanism by using explicit preactivation. In this case, the application creates and initializes a servant before asking the TP Framework to declare it activated. Once such a servant has been turned over to the TP Framework (by the <code class="cCode">TP::create_active_object_reference</code> call), that servant is treated by the TP Framework just like every other servant. The only difference is in its method of creation and initialization.
</p>
<p class="pBody"><a name="wp1064710"> </a>
The application can alter the &#8220;disposing&#8221; mechanism by taking the responsibility for disposing of a servant instead of leaving that responsibility with the TP Framework. Once a servant is known to the TP Framework (through <code class="cCode">Server::create_servant</code>, <code class="cCode">ServerBase::create_servant_with_id</code>, or <code class="cCode">TP::create_active_object_reference</code>), the TP Framework&#8217;s default behavior is to remove that servant itself. In this case, the application code must no longer use references to the servant after deactivation.
</p>
<p class="pBody"><a name="wp1064711"> </a>
However, the application may tell the TP Framework not to dispose of the servant after the TP Framework deactivates it. Taking responsibility for a servant is done on an individual servant basis, not for a whole class of servants, by calling <code class="cCode">Tobj_ServantBase::_add_ref</code> with a parameter identifying the servant.
</p>
<a name="wp1143177"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>In applications written using Oracle Tuxedo release 8.0 or later, use the <code class="cCode">Tobj_ServantBase::_add_ref</code> method instead of the <code class="cCode">TP::application_responsibility()</code> method. Unlike the <code class="cCode">TP::application_responsibility()</code> method, the <code class="cCode">add_ref()</code> method takes no arguments.</td>
</tr>
</table>

<p class="pBody"><a name="wp1064712"> </a>
The advantage of the application taking responsibility for the servant is that the servant does not have to be created anew. If obtaining the servant is an expensive proposition, the application may choose to save the servant and reuse it later. This is especially likely to be true for servants for preactivated objects, but is true in general. For example, the next time the TP Framework makes a call on <code class="cCode">Server::create_servant</code> or<code class="cCode"> ServerBase::create_servant_with_id</code>, the application might return a previously saved servant. 
</p>
<p class="pBody"><a name="wp1134863"> </a>
Additionally, once an application has taken responsibility for a servant, the application must take care to remove the servant (using <code class="cCode">Tobj_ServantBase::_remove_ref</code>) when the servant is no longer needed, that is, when the reference count drops to zero, the same as for any other C++ instance. For more information about how the <code class="cCode">_remove_ref()</code> method works, see <a href="tpfw.html#wp1103813">Tobj_ServantBase::_remove_ref()</a>.
</p>
<p class="pBody"><a name="wp1134892"> </a>
For more information on writing single-threaded and multithreaded server applications, see <a href="../cservers/index.html">Creating CORBA Server Applications</a>.
</p>
<h3 class="pHeading2"><a name="wp1036047"> </a>
Saving and Restoring Object State
</h3>
<p class="pBody"><a name="wp1037977"> </a>
While CORBA objects are active, their state is contained in a servant. Unless an application uses <code class="cCode">TP::create_active_object_reference</code>, state must be initialized when the object is first invoked (that is, the first time a method is invoked on a CORBA object after its object reference is created), and on subsequent invocations after they have been deactivated. While a CORBA object is deactivated, its state must be saved outside the process in which the servant was active. The object&#8217;s state can be saved in shared memory, in a file, or in a database. Before a CORBA object is deactivated, its state must be saved, and when it is activated, its state must be restored. 
</p>
<p class="pBody"><a name="wp1039385"> </a>
The programmer determines what constitutes an object&#8217;s state and what must be saved before an object is deactivated, and restored when an object is activated.
</p>
<h5 class="pHeading4"><a name="wp1037986"> </a>
Note On Use of Constructors and Destructors for CORBA Objects
</h5>
<p class="pBody"><a name="wp1037987"> </a>
The state of CORBA objects must not be initialized, saved, or restored in the constructors or destructors for the servant classes. This is because the TP Framework may reuse an instance of a servant rather than deleting it at deactivation. No guarantee is made as to the timing of the creation and deletion of servant instances.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1037991"> </a>
Transactions
</h2><p class="pBody"><a name="wp1058351"> </a>
The following sections provide information about transaction policies and how to use transactions.
</p>
<h3 class="pHeading2"><a name="wp1039795"> </a>
Transaction Policies
</h3>
<p class="pBody"><a name="wp1039796"> </a>
Eligibility of CORBA objects to participate in global transactions is controlled by the transaction policies assigned to implementations at compile time. The following policies can be assigned.
</p>
<a name="wp1041339"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The transaction policies are set in an ICF file that is configured at OMG IDL compile time. For a description of the ICF file, refer to the <a href="imp_cnfg.html">Implementation Configuration File (ICF)</a> section.</td>
</tr>
</table>

<div class="pSmartList1Bullet"><ul>
<li><a name="wp1039451"> </a><code class="cCode">never</code></li>
<p class="pBodyRelative"><a name="wp1039815"> </a>
The implementation is not transactional. Objects created for this interface can never be involved in a transaction. The system generates an exception (<code class="cCode">INVALID_TRANSACTION</code>) if an implementation with this policy is involved in a transaction. An <code class="cCode">AUTOTRAN</code> policy specified in the <code class="cCode">UBBCONFIG</code> file for the interface is ignored.
</p>
<li><a name="wp1039452"> </a><code class="cCode">ignore</code></li>
<p class="pBodyRelative"><a name="wp1039822"> </a>
The implementation is not transactional. This policy instructs the system to allow requests within a transaction to be made of this implementation. An <code class="cCode">AUTOTRAN</code> policy specified in the <code class="cCode">UBBCONFIG</code> file for the interface is ignored. 
</p>
<li><a name="wp1039453"> </a><code class="cCode">optional </code>(This is the default <code class="cCode">transaction_policy</code>.)</li>
<p class="pBodyRelative"><a name="wp1039829"> </a>
The implementation may be transactional. Objects can be involved in a transaction if the request is transactional. Servers containing transactional objects must be configured within a group associated with an XA-compliant resource manager. If the <code class="cCode">AUTOTRAN</code> parameter is specified in the <code class="cCode">UBBCONFIG</code> file for the interface, <code class="cCode">AUTOTRAN</code> is on.
</p>
<li><a name="wp1039454"> </a><code class="cCode">always</code></li>
<p class="pBodyRelative"><a name="wp1039874"> </a>
The implementation is transactional. Objects are required to always be involved in a transaction. If a request is made outside a transaction, the system automatically starts a transaction before invoking the method. The transaction is committed when the method ends. (This is the same behavior that results from specifying <code class="cCode">AUTOTRAN</code> for an object with the option transaction policy, except that no administrative configuration is necessary to achieve this behavior, and it cannot be overridden by administrative configuration.) Servers containing transactional objects must be configured within a group that is associated with an XA-compliant resource manager.
</p>
</ul></div>
<a name="wp1039877"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The <code class="cCode">optional</code> policy is the only transaction policy that can be influenced by administrative configuration. If the system administrator sets the <code class="cCode">AUTOTRAN</code> attribute for the interface by means of the <code class="cCode">UBBCONFIG</code> file or by using administrative tools, the system automatically starts a transaction upon invocation of the object, if it is not already infected with a transaction (that is, the behavior is as if the <code class="cCode">always</code> policy were specified).</td>
</tr>
</table>

<h3 class="pHeading2"><a name="wp1041353"> </a>
Transaction Initiation
</h3>
<p class="pBody"><a name="wp1041354"> </a>
Transactions are initiated in one of two ways:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1041355"> </a>By the application code via use of the <code class="cCode">CosTransactions::Current::begin()</code> operation. This can be done in either the client or the server. For a description of this operation, see <a href="../trans/index.html">Using CORBA Transactions</a>.</li>
<li><a name="wp1041358"> </a>By the system when an invocation is done on an object which has either:</li>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1041512"> </a>Transaction policy <code class="cCode">always</code></li>
<li><a name="wp1099578"> </a>Transaction policy <code class="cCode">optional</code> and a setting of <code class="cCode">AUTOTRAN</code> for the interface </li>
<p class="pBodyRelative"><a name="wp1099584"> </a>
For more information, see <a href="../trans/index.html">Using CORBA Transactions</a>.
</p>
</ul></div>
</ul></div>
<h3 class="pHeading2"><a name="wp1099586"> </a>
Transaction Termination
</h3>
<p class="pBody"><a name="wp1043363"> </a>
In general, the handling of the outcome of a transaction is the responsibility of the initiator. Therefore, the following are true:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1043364"> </a>If the client or server application code initiates transactions, the TP Framework never commits a transaction. The Oracle Tuxedo system may roll back the transaction if server processing tries to return to the client while the transaction is in an illegal state.</li>
<li><a name="wp1043365"> </a>If the system initiates a transaction, the commit or rollback will always be handled by the Oracle Tuxedo system.</li>
</ul></div>
<p class="pBody"><a name="wp1043366"> </a>
The following behavior is enforced by the Oracle Tuxedo system:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1043367"> </a>If no transaction is active when a method on a CORBA object is invoked and that method begins a transaction, the transaction must be either committed, rolled back, or suspended when the method invocation returns. If none of these actions is taken, the transaction is rolled back by the TP Framework, and the <code class="cCode">CORBA::OBJ_ADAPTER</code> exception is raised to the client application. This exception is raised because the transaction was initiated in the server application; therefore, the client application would not expect a transactional error condition such as <code class="cCode">TRANSACTION_ROLLEDBACK</code>.</li>
</ul></div>
<h3 class="pHeading2"><a name="wp1043452"> </a>
Transaction Suspend and Resume
</h3>
<p class="pBody"><a name="wp1043453"> </a>
The CORBA object must follow strict rules with respect to suspending and resuming a transaction within a method invocation. These rules and the error conditions that result from their violation are described below.
</p>
<p class="pBody"><a name="wp1043454"> </a>
When a CORBA object method begins execution, it can be in one of the following three states with respect to transactions:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1043455"> </a>The client application began the transaction.</li>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1043456"> </a><em class="cEmphasis">Legal server application behavior:</em> Suspend and resume the transaction within the method execution.</li>
<li><a name="wp1043457"> </a><em class="cEmphasis">Illegal server application behavior:</em> Return from the method with the transaction in the suspended state (that is, return from the method without invoking resume if suspend was invoked).</li>
<li><a name="wp1043458"> </a><em class="cEmphasis">Error Processing:</em> If illegal behavior occurs, the TP Framework raises the <code class="cCode">CORBA::TRANSACTION_ROLLEDBACK</code> exception to the client application and the transaction is rolled back by the Oracle Tuxedo system.</li>
</ul></div>
<li><a name="wp1043459"> </a>The system began a transaction to provide <code class="cCode">AUTOTRAN</code> or transaction policy <code class="cCode">always</code> behavior.</li>
</ul></div>
<a name="wp1043460"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>For each CORBA interface, set <code class="cCode">AUTOTRAN</code> to <code class="cCode">Yes</code> if you want a transaction to start automatically when an operation invocation is received. Setting <code class="cCode">AUTOTRAN</code> to <code class="cCode">Yes</code> has no effect if the interface is already in transaction mode. For more information about <code class="cCode">AUTOTRAN</code>, see <a href="../trans/index.html">Using CORBA Transactions</a>.</td>
</tr>
</table>

<div class="pSmartList1Bullet"><ul>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1043464"> </a><em class="cEmphasis">Legal server behavior: </em>Suspend and resume the transaction within the method execution.</li>
<a name="wp1043465"> </a><table class="ListNote">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Not recommended. The transaction may be timed out and aborted before the method causes the transaction to be resumed.</td>
</tr>
</table>

<li><a name="wp1043466"> </a><em class="cEmphasis">Illegal server behavior: </em>Return from the method with the transaction in the suspended state (that is, return from the method without invoking resume if suspend was invoked).</li>
<li><a name="wp1043467"> </a><em class="cEmphasis">Error Processing:</em> If illegal behavior occurs, the TP Framework raises the <code class="cCode">CORBA::OBJ_ADAPTER</code> exception to the client, and the transaction is rolled back by the system. The <code class="cCode">CORBA::OBJ_ADAPTER</code> exception is raised because the client application did not initiate the transaction, and, therefore, does not expect transaction error conditions to be raised. </li>
</ul></div>
<li><a name="wp1043468"> </a>The CORBA object is not involved in a transaction when it starts executing. </li>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1043469"> </a><em class="cEmphasis">Legal server behavior:</em> </li>
<div class="pSmartList1NoteBullet"><ul>
<li><a name="wp1043470"> </a>Begin and commit a transaction within the method execution.</li>
<li><a name="wp1043471"> </a>Begin and roll back a transaction within the method execution.</li>
<li><a name="wp1043472"> </a>Begin and suspend a transaction within the method execution.</li>
</ul></div>
<li><a name="wp1043473"> </a><em class="cEmphasis">Illegal server behavior:</em> Begin a transaction and return from the method with the transaction active.</li>
<li><a name="wp1043474"> </a><em class="cEmphasis">Error Processing:</em> If illegal behavior occurs, the TP Framework raises the <code class="cCode">CORBA::OBJ_ADAPTER</code> exception to the client application and the transaction is rolled back by the Oracle Tuxedo system. The <code class="cCode">CORBA::OBJ_ADAPTER</code> exception is raised because the client application did not initiate the transaction, and, therefore, does not expect transaction error conditions to be raised. </li>
</ul></div>
</ul></div>
<h3 class="pHeading2"><a name="wp1043475"> </a>
Restrictions on Transactions
</h3>
<p class="pBody"><a name="wp1043476"> </a>
The following restrictions apply to Oracle Tuxedo CORBA transactions:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1043477"> </a>A CORBA object in the Oracle Tuxedo system must have the same transaction context when it returns from a method invocation that it had when the method was invoked.</li>
<li><a name="wp1043478"> </a>A CORBA object can be infected by only one transaction at a time. If an invocation tries to infect an already infected object, a <code class="cCode">CORBA::INVALID_TRANSACTION</code> exception is returned.</li>
<li><a name="wp1043479"> </a>If a CORBA object is infected with a transaction and a nontransactional request is made on it, a <code class="cCode">CORBA::OBJ_ADAPTER</code> exception is raised.</li>
<li><a name="wp1043480"> </a>If the application begins a transaction in <code class="cCode">Server::initialize(),</code> it must either commit or roll back the transaction before returning from the method. If the application does not, the TP Framework shuts down the server. This is because the application has no predictable way of regaining control after completing the <code class="cCode">Server::initialize</code> method.</li>
<li><a name="wp1043481"> </a>If a CORBA object is infected by a transaction and with an activation policy of <code class="cCode">transaction</code>, and if the reason code passed to the method is either <code class="cCode">DR_TRANS_COMMITTING</code> or <code class="cCode">DR_TRANS_ABORTED</code>, no invocation on any CORBA object can be done from within the <code class="cCode">Tobj_ServantBase::deactivate_object </code>method. Such an invocation results in a <code class="cCode">CORBA::BAD_INV_ORDER</code> exception.</li>
</ul></div>
<h3 class="pHeading2"><a name="wp1043789"> </a>
SQL and Global Transactions
</h3>
<p class="pBody"><a name="wp1079635"> </a>
Adhere to the following guidelines when using SQL and Global Transactions:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1043790"> </a>Care should be taken when executing SQL statements outside the scope of a global transaction. The SQL standard specifies that a local transaction should be started implicitly by the database resource manager whenever an SQL statement that needs the context of a transaction is executed and no transaction is active. The standard also says that a transaction that is implicitly started by the database resource manager must then be explicitly terminated by executing a COMMIT or ROLLBACK SQL statement; the TP Framework is not responsible for terminating transactions that are started by the resource manager.</li>
<a name="wp1044167"> </a><table class="ListNote">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>This is not an issue when an application uses the XA library to connect to the Oracle server because those applications can operate only on global transactions. The Oracle server does not allow local transactions when it is using XA.</td>
</tr>
</table>

<li><a name="wp1043800"> </a>The SQL COMMIT and ROLLBACK statements cannot be used to terminate a global transaction that has been either started explicitly using <code class="cCode">Current.begin()</code> or started implicitly by the system. Check the database vendor documentation for each database product for other possible restrictions when using global transactions.</li>
<li><a name="wp1043804"> </a>SQL cursors may be closed when transactions are terminated. Consult your database product documentation for exact information about cursor handling rules. Application programmers should be careful to use cursors only with CORBA objects with appropriate activation policies and within appropriate transaction boundaries.</li>
</ul></div>
<h3 class="pHeading2"><a name="wp1045227"> </a>
Voting on Transaction Outcome
</h3>
<p class="pBody"><a name="wp1045228"> </a>
CORBA objects can affect transaction outcome during two stages of transaction processing:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1045229"> </a>During transactional work</li>
<p class="pBodyRelative"><a name="wp1045230"> </a>
The <code class="cCode">Current.rollback_only</code> method can be used to ensure that the only possible outcome is to roll back the current transaction. <code class="cCode">Current.rollback_only()</code> can be invoked from any CORBA object method.
</p>
<li><a name="wp1045231"> </a>After completion of transactional work</li>
<p class="pBodyRelative"><a name="wp1066201"> </a>
CORBA objects that have the transaction activation policy are given a chance to vote whether the transaction should commit or roll back after transactional work is completed. These objects are notified of the completion of transactional work prior to the start of the two-phase commit algorithm when the TP Framework invokes their <code class="cCode">deactivate_object</code> method. 
</p>
<p class="pBodyRelative"><a name="wp1066202"> </a>
Note that this behavior does not apply to objects with <code class="cCode">process</code> or <code class="cCode">method</code> activation policies. If the CORBA object wants to roll back the transaction, it can call <code class="cCode">Current::rollback_only</code>. If it wants to vote to commit the transaction, it does not make that call. Note, however, that a vote to commit does not guarantee that the transaction is committed, since other objects may subsequently vote to roll back the transaction.
</p>
</ul></div>
<a name="wp1065145"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Users of SQL cursors must be careful when using an object with the <code class="cCode">method</code> or <code class="cCode">process</code> activation policy. A process opens an SQL cursor within a client-initiated transaction. For typical SQL database products, once the client commits the transaction, all cursors that were opened within that transaction are automatically closed; however, the object will not receive any notification that its cursor has been closed.</td>
</tr>
</table>

<h3 class="pHeading2"><a name="wp1045904"> </a>
Transaction Timeouts
</h3>
<p class="pBody"><a name="wp1099877"> </a>
When a transaction timeout occurs, the transaction is marked so that the only possible outcome is to roll back the transaction, and the <code class="cCode">CORBA::TRANSACTION_ROLLEDBACK</code> standard exception is returned to the client. Any attempts to send new requests will also fail with the <code class="cCode">CORBA::TRANSACTION_ROLLEDBACK</code> exception until the transaction has been aborted.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1155499"> </a>
IIOP Client Failover
</h2><p class="pBody"><a name="wp1155500"> </a>
It is not always possible to determine when a server instance failed with respect to the work it was doing at the time of failure. For example, if a server instance fails after handling a client request but before returning the response, there is no way to tell that the request was handled. A user that does not get a response will most likely retry, resulting in an additional request. 
</p>
<p class="pBody"><a name="wp1155504"> </a>
Support for IIOP client failover has been added to Oracle Tuxedo CORBA as an availability enhancement. IIOP client failover provides a transparent mechanism for a CORBA remote client to automatically connect to an alternative ISL and then retry the request in case of failure.
</p>
<p class="pBody"><a name="wp1156280"> </a>
IIOP client failover marks an interface implementation as <span style="font-style: italic">idempotent</span>. An idempotent implementation is one that can be repeated without any negative side-effects. For example, <code class="cCode">SET</code> <code class="cCode">BALANCE</code>.
</p>
<h3 class="pHeading2"><a name="wp1163083"> </a>
Setting The Retry Policy
</h3>
<p class="pBody"><a name="wp1162733"> </a>
In order to mark an interface implementation as idempotent, you must set the retry policy in the <code class="cCode">implementation configuration</code> file (ICF) using the <code class="cCode">retry_policy</code> option. For a description of the ICF, refer to the <a href="imp_cnfg.html">Implementation Configuration File (ICF)</a> section.
</p>
<p class="pBody"><a name="wp1162737"> </a>
The <code class="cCode">retry_policy</code> option has two settings:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1162738"> </a><code class="cCode">never: </code>The default setting. It indicates that the interface implementation is not idempotent and that requests should never be automatically retried.</li>
<li><a name="wp1162739"> </a><code class="cCode">always:</code> Indicates that the interface implementation is idempotent and that requests should always be retried in case of failure.</li>
</ul></div>
<h4 class="pHeading3"><a name="wp1162740"> </a>
MIB Support
</h4>
<p class="pBody"><a name="wp1163078"> </a>
You can also check the retry policy using the <code class="cCode">TA_RTPOLICY</code> attribute added to the <code class="cCode">MIB(5)</code> <code class="cCode">T_IFQUEUE</code> and <code class="cCode">T_INTERFACE</code> classes. The <code class="cCode">TA_RTPOLICY</code> attribute value is either <code class="cCode">never</code> or <code class="cCode">always</code>.
</p>
<h3 class="pHeading2"><a name="wp1163080"> </a>
Initiating IIOP Client Failover
</h3>
<p class="pBody"><a name="wp1160887"> </a>
To initiate IIOP client failover support, ISL servers must be specified using the -<code class="cCode">C warn|none</code> option in the <code class="cCode">*SERVERS</code> section of the <code class="cCode">UBBCONFIG</code> file
</p>
<p class="pBody"><a name="wp1164142"> </a>
This option allows ISL to accept unofficial connection directly from the client orb. ISL servers that are not specified using the -<code class="cCode">C warn|none</code> option will not be placed in candidate IIOP gateway pools. Consequently, the client will not failover to those ISL servers.
</p>
<p class="pBody"><a name="wp1164143"> </a>
In the following <code class="cCode">UBBCONFIG</code> file example shown in <a href="tpfw.html#wp1160890">Listing&#160;3-1</a>, the ISL servers specified in lines 1 and 2 will support client failover. The ISL server in line 3 will not.
</p>
<div class="pCodeTitle"><a name="wp1160890"> </a>
Listing&#160;3-1	   Example UBBCONFIG File IIOP Client Failover Entry
</div> <a name="wp1161232"> </a><div class="pPreformatted"><pre><code class="cCode">*SERVERS</code></pre></div><a name="wp1161233"> </a><div class="pPreformatted"><pre><code class="cCode">	ISL SRVGRP=SYS_GRP1 SRVID=10 CLOPT=&quot;-A -- -C warn -n //myhost1:2468&quot;</code></pre></div><a name="wp1161234"> </a><div class="pPreformatted"><pre><code class="cCode">	ISL SRVGRP=SYS_GRP2 SRVID=20 CLOPT=&quot;-A -- -C none -n //myhost2:2469&quot;</code></pre></div><a name="wp1160894"> </a><div class="pPreformatted"><pre><code class="cCode">	ISL SRVGRP=SYS_GRP3 SRVID=30 CLOPT=&quot;-A -- -n //myhost3:2470&quot;</code></pre></div><h4 class="pHeading3"><a name="wp1166466"> </a>
IIOP Client Failover Limitations
</h4>
<p class="pBody"><a name="wp1166470"> </a>
IIOP Client Failover is not supported under the following three instances:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1166491"> </a>Tuxedo <span style="font-style: italic">system-supplied</span> object failover<br />Only <span style="font-style: italic">application-supplied</span> object failover is supported.</li>
<li><a name="wp1166508"> </a>Transaction mode</li>
<li><a name="wp1166509"> </a>SSL link or authentication is required</li>
</ul></div>
<h3 class="pHeading2"><a name="wp1155518"> </a>
See Also
</h3>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1155522"> </a><span class="cHyperlink">
Steps for Creating an Oracle </span><a href="../cservers/maksrv.html"></a>Tuxedo CORBA Server Application in Creating CORBA Server Applications</li>
<li><a name="wp1161293"> </a><a href="../rf5/rf5.html">UBBCONFIG(5)</a><code class="cCode"><a href="http://e-docs.bea.com/wls/docs90/cluster/load_balancing.html#1044135"></a></code></li>
<li><a name="wp1164241"> </a><span class="cHyperlink">
MIB</span><a href="../rf5/rf5.html"></a>(5)</li>
<li><a name="wp1161533"> </a><span class="cHyperlink">
T_IFQUEU</span><a href="../rf5/rf5.html"></a>E Class</li>
<li><a name="wp1164237"> </a><span class="cHyperlink">
T_INTERFACE </span><a href="../rf5/rf5.html"></a>Class</li>
</ul></div>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1168162"> </a>
WebLogic CORBA Clustering and Load Balancing Support
</h2><p class="pBody"><a name="wp1170249"> </a>
Tuxedo CORBA C++ client supports failover to WebLogic clustering servers and also supports load balancing. For more information, see WebLogic 10.0 documentation - <a href="http://e-docs.bea.com/wls/docs91/cluster/failover.html#1008850"><span style="font-style: italic">Failover and Replication in a Cluster</a></span> and<span style="font-style: italic"> <a href="http://e-docs.bea.com/wls/docs90/cluster/load_balancing.html#1044135">Load Balancing in a Cluster</a></span>.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1170256"> </a>
Parallel Objects
</h2><p class="pBody"><a name="wp1170260"> </a>
Support for parallel objects was added to Oracle Tuxedo CORBA in release 8.0 as a performance enhancement. The parallel objects feature enables you to designate all business objects in a particular application as stateless objects. The effect is that, unlike stateful business objects, which can only run on one server in a single domain, stateless business objects can run on all servers in a single domain. Thus, the benefits of parallel objects are as follows:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1105688"> </a>Parallel objects can run on multiple servers in the same domain at the same time. Thus, utilization of all servers to service concurrent multiple requests improves performance.</li>
<li><a name="wp1105692"> </a>When the Oracle Tuxedo system services requests to parallel business objects, it always looks for an available server to the local machine first. If all servers on the local machine are busy processing the requested business object, the Oracle Tuxedo system looks for an available server on other machines in the local domain. Thus, if there are multiple servers on the local machine, network traffic is reduced and performance is improved.</li>
</ul></div>
<p class="pBody"><a name="wp1104678"> </a>
For more information on parallel objects, see <a href="../tuning_scaling/index.html">Scaling, Distributing, and Tuning CORBA Applications</a>.
</p>
<p class="pBody"><a name="wp1107565"> </a>
To implement parallel objects, the concurrency policy option has been added to the ICF file. To select parallel objects for a particular application, you set the concurrency policy option to user-controlled. When you select user-controlled concurrency, the business object are not registered with the Active Object Map (AOM) and, therefore, are stateless and can be active on more than one server at a time. Thus, these objects are referred to as parallel objects.
</p>
<p class="pBody"><a name="wp1105676"> </a>
If user-controlled concurrency is selected, the servant implementation must comply with one of the following statements:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1104581"> </a>The servant implementation must have no requirements for concurrent access to a shared resource </li>
<li><a name="wp1104584"> </a>Or the servant implementation must utilize some other tool (for example, a database and locking) to ensure the correct behavior during concurrent access to resources.</li>
</ul></div>
<p class="pBody"><a name="wp1099923"> </a>
In release 8.0 of the Oracle Tuxedo software, the Implementation Configuration File (ICF) was modified to support user-controlled concurrency. In <a href="tpfw.html#wp1100737">Listing&#160;3-2</a>, the changes to add this support are highlighted in <span style="font-weight: bold">bold</span> type. For a description of the ICF syntax, see <a href="imp_cnfg.html#wp1011789">ICF Syntax</a>.
</p>
<div class="pCodeTitle"><a name="wp1100737"> </a>
Listing&#160;3-2	   ICF Syntax
</div> <a name="wp1100367"> </a><div class="pPreformatted"><pre><code class="cCode">[#pragma activation_policy method|transaction|process]<br />[#pragma transaction_policy never|ignore|optional|always]<br /></code><code class="cCodeBold">[#pragma concurrency_policy user_controlled|system_controlled]<br /></code><code class="cCode">[Module module-name {]<br />   implementation [implementation-name]<br />     {<br />     implements (module-name::interface-name);<br />     [activation_policy (method|transaction|process);]<br />     [transaction_policy (never|ignore|optional|always);]<br />     </code><code class="cCodeBold">[concurrency_policy (user_controlled|system_controlled);]<br /></code><code class="cCode">     };<br />  [};]</code></pre></div><p class="pBody"><a name="wp1100291"> </a>
User-controlled concurrency can be used with factory-based routing, all activation policies, and all transaction policies. The interaction with these features is as follows:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1100292"> </a>Factory-based routing</li>
<p class="pBodyRelative"><a name="wp1100310"> </a>
If the user specifies factory-based routing when creating the object, then the object will route to a server in that group. The object key contains the group selected during factory-based routing, but the client routing code will recognize that the interface has user-controlled concurrency and specify the desired group. This is accomplished using normal Oracle Tuxedo routing. 
</p>
<li><a name="wp1100293"> </a>Activation policy</li>
<p class="pBodyRelative"><a name="wp1100311"> </a>
The TP Framework handles active user-controlled concurrency objects in the same manner as system-controlled concurrency objects. The TP Framework stores information about objects in the local AOM, and calls the <code class="cCode">activate_object</code> and <code class="cCode">deactivate_object</code> methods at the appropriate times. However, the object will not have an entry in the AOM and the TP Framework will not call any AOM routines. For example, on shutdown, since an active object will not have an AOM handle, calls to remove the entry from the AOM will not be invoked.
</p>
<li><a name="wp1100294"> </a>Transaction policy </li>
<p class="pBodyRelative"><a name="wp1100312"> </a>
The TP Framework handles active user-controlled concurrency objects in the same manner as system-controlled concurrency objects. The TP Framework is called back for transaction events and the TP Framework stores information about transactional user-controlled objects in the local AOM. The main differences when using parallel objects in transactions as opposed to stateful objects are that the AOM is not used for GTRID information and the AOM routines are not called to update or retrieve transactional information.
</p>
</ul></div>
<a name="wp1100295"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>There is one restriction with user-controlled concurrency. <code class="cCode">TP::create_active_object_reference</code> throws a <code class="cCode">TobjS::IllegalOperation</code> exception if it is passed an interface with user-controlled concurrency set. Since the AOM is not used when user-controlled concurrency is set, there is no way for the TP Framework to connect an active object to this server.</td>
</tr>
</table>

<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1099879"> </a>
TP Framework API
</h2><p class="pBody"><a name="wp1099880"> </a>
This section describes the TP Framework API. Additional information about how to use this API can be found in <a href="../cservers/index.html">Creating CORBA Server Applications</a>.
</p>
<p class="pBody"><a name="wp1026122"> </a>
The TP Framework comprises the following components:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1029257"> </a>The <code class="cCode">Server</code> C++ class, which has virtual methods for application-specific server initialization and termination logic</li>
<li><a name="wp1139029"> </a>The <code class="cCode">ServerBase</code> C++ class, which has virtual methods for multithreaded server applications.</li>
<li><a name="wp1026123"> </a>The <code class="cCode">Tobj_ServantBase</code> C++ class, which has virtual methods for object state management</li>
<li><a name="wp1026125"> </a>The <code class="cCode">TP</code> C++ class, which provides methods to:</li>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1026127"> </a>Create object references for CORBA objects</li>
<li><a name="wp1026128"> </a>Register (and unregister) factories with the FactoryFinder object</li>
<li><a name="wp1026626"> </a>Initiate user-controlled preactivation and deactivation of objects</li>
<li><a name="wp1026129"> </a>Initiate user-controlled deactivation of the CORBA object currently being invoked</li>
<li><a name="wp1026130"> </a>Obtain an object reference to the CORBA object currently being invoked</li>
<li><a name="wp1026131"> </a>Open and close XA resource managers</li>
<li><a name="wp1026132"> </a>Log messages to a user log (<code class="cCode">ULOG</code>) file</li>
<li><a name="wp1026133"> </a>Obtain object references to the ORB and to Bootstrap objects (if not using the CORBA Interoperable Naming Service (INS))</li>
</ul></div>
<li><a name="wp1026134"> </a>Header files for these classes</li>
<li><a name="wp1026135"> </a>Libraries that are used by server applications</li>
</ul></div>
<p class="pBody"><a name="wp1067971"> </a>
The visible part of the TP Framework consists of two categories of operations:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1067977"> </a>Service methods that can be called by user code. These are in the TP interface.</li>
<li><a name="wp1067978"> </a>Callback methods that are written by the user and that are invoked by the TP Framework. This includes methods in the <code class="cCode">Tobj_ServantBase</code> and <code class="cCode">Server</code> classes. These operations are intended to be called by TP Framework code only. The application code should never call the methods of these classes. If it does, unpredictable results may occur.</li>
</ul></div>
<h3 class="pHeading2"><a name="wp1028814"> </a>
Server Interface
</h3>
<p class="pBody"><a name="wp1045935"> </a>
The Server interface provides callback methods that can be used for application-specific server initialization and termination logic. This interface also provides a callback method that is used to create servants when servants are required for object activation. 
</p>
<p class="pBody"><a name="wp1069007"> </a>
The Server interface has the following characteristics:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1028816"> </a>The Server class inherits from the ServerBase class.</li>
<li><a name="wp1128188"> </a>The <code class="cCode">Server</code> class is a C++ native class. </li>
<li><a name="wp1028817"> </a>The <code class="cCode">Server.h</code> file contains the declarations and definitions for the Server class.</li>
</ul></div>
<p class="pBody"><a name="wp1136467"> </a>
For a description of the Server interface methods, see <a href="tpfw.html#wp1142859">ServerBase Interface</a>. 
</p>
<h5 class="pHeading4"><a name="wp1028818"> </a>
C++ Declarations
</h5>
<p class="pBody"><a name="wp1028819"> </a>
For the C++ mappings, see<a href="tpfw.html#wp1142859">ServerBase Interface</a>.
</p>
<h3 class="pHeading2"><a name="wp1142859"> </a>
ServerBase Interface
</h3>
<p class="pBody"><a name="wp1142868"> </a>
The serverBase interface allows you to take full advantage of multithreading capabilities. You can create your own <code class="cCode">Server</code> classes that inherit from the <code class="cCode">ServerBase</code> class. This provides you with the following: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1102063"> </a>The <code class="cCode">create_servant_with_id()</code> method to support implementations requiring knowledge of the target object during the creation of a servant</li>
<li><a name="wp1102065"> </a>Support for user-supplied thread initialization and release handlers</li>
</ul></div>
<p class="pBody"><a name="wp1102067"> </a>
The <code class="cCode">ServerBase</code> class provides the same operations that were available in the <code class="cCode">Server</code> class in earlier releases. The Server class inherits from the ServerBase class. 
</p>
<p class="pBody"><a name="wp1131735"> </a>
These methods can be used with single-threaded and multithreaded applications:
</p>
<div class="pSmartList1Bullet"><ul>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1131744"> </a><code class="cCode">Server::create_servant()</code></li>
<li><a name="wp1131745"> </a><code class="cCode">Server::initialize()</code></li>
<li><a name="wp1131746"> </a><code class="cCode">Server::release()</code></li>
<li><a name="wp1143617"> </a><code class="cCode">ServerBase::create_servant_with_id()</code></li>
</ul></div>
</ul></div>
<p class="pBody"><a name="wp1131739"> </a>
These methods can be used with multithreaded server applications only:
</p>
<div class="pSmartList1Bullet"><ul>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1102071"> </a><code class="cCode">ServerBase::</code> <code class="cCode">thread_initialize()</code></li>
<li><a name="wp1129975"> </a> <code class="cCode">ServerBase::thread_release()</code></li>
</ul></div>
</ul></div>
<a name="wp1136515"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Programmers must provide definitions of the Server class methods. The ServerBase class methods have default implementations.</td>
</tr>
</table>

<h5 class="pHeading4"><a name="wp1136524"> </a>
C++ Declarations (in Server.h)
</h5>
<p class="pBody"><a name="wp1138337"> </a>
The C++ mapping is as follows:
</p>
<a name="wp1136530"> </a><div class="pPreformatted"><pre><code class="cCode">class OBBEXPDLLUSER ServerBase {<br />public:</code></pre></div><a name="wp1136533"> </a><div class="pPreformatted"><pre><code class="cCode">    virtual CORBA::Boolean<br />        initialize(int argc, char** argv) = 0;</code></pre></div><a name="wp1136536"> </a><div class="pPreformatted"><pre><code class="cCode">    virtual void<br />        release() = 0;</code></pre></div><a name="wp1136539"> </a><div class="pPreformatted"><pre><code class="cCode">    virtual Tobj_Servant<br />        create_servant(const char* interfaceName) = 0;</code></pre></div><a name="wp1136543"> </a><div class="pPreformatted"><pre><code class="cCode">       // Default Implementations Supplied<br />       virtual Tobj_Servant<br />           create_servant_with_id(const char* interfaceName,<br />                                   const char* stroid);</code></pre></div><a name="wp1136548"> </a><div class="pPreformatted"><pre><code class="cCode">       virtual CORBA::Boolean<br />           thread_initialize(int argc, char** argv);</code></pre></div><a name="wp1136551"> </a><div class="pPreformatted"><pre><code class="cCode">       virtual void<br />           thread_release();</code></pre></div><a name="wp1136553"> </a><div class="pPreformatted"><pre><code class="cCode">};</code></pre></div><a name="wp1136555"> </a><div class="pPreformatted"><pre><code class="cCode">class Server : public ServerBase {<br />public:</code></pre></div><a name="wp1136558"> </a><div class="pPreformatted"><pre><code class="cCode">    CORBA::Boolean initialize(int argc, char** argv);<br />    void release();<br />    Tobj_Servant create_servant(const char* interfaceName);<br />};</code></pre></div><p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1131189"> </a>
Server::create_servant()
</h3>
<h4 class="pHeading3"><a name="wp1131190"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1131191"> </a>
Creates a servant to instantiate a C++ object.
</p>
<h4 class="pHeading3"><a name="wp1131192"> </a>
C++ Binding
</h4>
<a name="wp1131193"> </a><div class="pPreformatted"><pre><code class="cCode">class Server {<br />public:<br />      Tobj_Servant     create_servant(const char* interfaceName);<br />};</code></pre></div><h4 class="pHeading3"><a name="wp1131194"> </a>
Argument
</h4>
<h4 class="pDefTerm"><a name="wp1131195"> </a>
<code class="cCode">interfaceName</code>
</h4><div class="pDefPara"><a name="wp1131196"> </a>
Specifies a character string that contains the fully qualified interface name for the object. This will be the same interface name that was supplied when the object reference was created (<code class="cCode">TP::create_object_reference()</code> or <code class="cCode">TP::create_active_object_reference()</code>) for the object reference used for this invocation. This name can be used to determine which servant needs to be constructed.
</div>
<h4 class="pHeading3"><a name="wp1131197"> </a>
Exception
</h4>
<p class="pBody"><a name="wp1131198"> </a>
If an exception is thrown in <code class="cCode">Server::create_servant()</code>, the TP Framework catches the exception. Activation fails. A <code class="cCode">CORBA::OBJECT_NOT_EXIST()</code> exception is raised back to the client. In addition, an error message is written to the user log (<code class="cCode">ULOG</code>) file, as follows, for each exception type:
</p>
<h4 class="pDefTerm"><a name="wp1131200"> </a>
<code class="cCode">TobjS::CreateServantFailed</code>
</h4><div class="pDefPara"><a name="wp1131202"> </a>
<code class="cCode">&quot;TPFW_CAT:23: ERROR: Activating object - application raised TobjS::CreateServantFailed. Reason = reason. Interface = </code>interfaceName<code class="cCode">, OID = </code><code class="cCodeEmphasis">oid</code><code class="cCode">&quot;</code>
</div>
<div class="pDefParaCont"><a name="wp1139680"> </a>
Where <code class="cCodeEmphasis">reason</code> is a user-supplied reason, and <code class="cCodeEmphasis">interfaceName</code> and <code class="cCodeEmphasis">oid</code> are the interface ID and object ID, respectively, of the invoked CORBA object.
</div>
<h4 class="pDefTerm"><a name="wp1131206"> </a>
<code class="cCode">TobjS::OutOfMemory </code>
</h4><div class="pDefPara"><a name="wp1139690"> </a>
<code class="cCode">&quot;TPFW_CAT:22: ERROR: Activating object - application raised TobjS::OutOfMemory. Reason = reason. Interface = </code><code class="cCodeEmphasis">interfaceName</code><code class="cCode">, OID = </code><code class="cCodeEmphasis">oid</code><code class="cCode">&quot;</code>
</div>
<div class="pDefParaCont"><a name="wp1139695"> </a>
Where <code class="cCodeEmphasis">reason</code> is a user-supplied reason, and <code class="cCodeEmphasis">interfaceName</code> and <code class="cCodeEmphasis">oid</code> are the interface ID and object ID, respectively, of the invoked CORBA object.
</div>
<h4 class="pDefTerm"><a name="wp1131212"> </a>
<code class="cCode">CORBA::Exception</code>
</h4><div class="pDefPara"><a name="wp1139705"> </a>
<code class="cCode">&quot;TPFW_CAT:28: ERROR: Activating object - CORBA Exception not handled by application. Exception ID = exceptionID. Interface = </code><code class="cCodeEmphasis">interfaceName</code><code class="cCode">, OID = </code><code class="cCodeEmphasis">oid</code><code class="cCode">&quot;</code>
</div>
<div class="pDefParaCont"><a name="wp1139710"> </a>
Where <code class="cCodeEmphasis">exceptionID</code> is the interface ID of the exception, and <code class="cCodeEmphasis">interfaceName</code> and <code class="cCodeEmphasis">oid</code> are the interface ID and object ID, respectively, of the invoked CORBA object.
</div>
<h4 class="pDefTerm"><a name="wp1141009"> </a>
<code class="cCode">Other Exception</code>
</h4><div class="pDefPara"><a name="wp1142676"> </a>
<code class="cCode">&quot;TPFW_CAT:29: ERROR: Activating object - Unknown Exception not handled by application. Exception ID = exceptionID. Interface = </code><code class="cCodeEmphasis">interfaceName</code><code class="cCode">, OID = </code><code class="cCodeEmphasis">oid</code><code class="cCode">&quot;</code>
</div>
<div class="pDefParaCont"><a name="wp1131222"> </a>
Where <code class="cCodeEmphasis">exceptionID</code> is the interface ID of the exception, and <code class="cCodeEmphasis">interfaceName</code> and <code class="cCodeEmphasis">oid</code> are the interface ID and object ID, respectively, of the invoked CORBA object. 
</div>
<h4 class="pHeading3"><a name="wp1131223"> </a>
Description
</h4>
<p class="pBody"><a name="wp1131224"> </a>
The <code class="cCode">create_servant</code> method is invoked by the TP Framework when a request arrives at the server and there is no available servant to satisfy the request. The TP Framework calls the <code class="cCode">create_servant </code>method with the interface name for the servant to be created. The server application instantiates an appropriate C++ object and returns a pointer to it. Typically, the method contains a switch statement on the interface name and creates a new object, depending on the interface name.
</p>
<a name="wp1131225"> </a>
<table class="Note">
<tr>
<td valign="top"><strong>Caution:</strong></td>
<td>The server application must not depend on this method being invoked for every activation of a CORBA object. The server application must not do any handling of CORBA object state in the constructors or destructors of any servant classes for CORBA objects. This is because the TP Framework may possibly reuse servants on activation and may possibly not destroy servants on deactivation.</td>
</tr>
</table>
<h4 class="pHeading3"><a name="wp1131226"> </a>
Return Value
</h4>
<h4 class="pDefTerm"><a name="wp1131227"> </a>
<code class="cCode">Tobj_Servant</code>
</h4><div class="pDefPara"><a name="wp1131228"> </a>
The pointer to the newly created servant (instance) for the specified interface. A NULL value should be returned if <code class="cCode">create_servant()</code> is invoked with an interface name that it does not recognize or if the servant cannot be created for some reason.
<a name="wp1131229"> </a>
If the <code class="cCode">create_servant</code> method returns a NULL pointer, activation fails. A <code class="cCode">CORBA::OBJECT_NOT_EXIST() </code>exception is raised back to the client. Also, the following message is written to the user log (<code class="cCode">ULOG</code>):
<a name="wp1131231"> </a>
<code class="cCode">&quot;TPFW_CAT:23: ERROR: Activating object - application raised TobjS::CreateServantFailed. Reason = Application&#39;s Server::create_servant returned NULL. Interface = </code><code class="cCodeEmphasis">interfaceName</code><code class="cCode">, OID = </code><code class="cCodeEmphasis">oid</code><code class="cCode">&quot;</code>
<a name="wp1131233"> </a>
Where <code class="cCodeEmphasis">interfaceName</code> is the interface ID of the invoked interface and <code class="cCodeEmphasis">oid</code> is the corresponding object ID.
<a name="wp1131234"> </a><table class="ListNote">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The restriction on the length of the <code class="cCode">ObjectId</code> has been removed in this release.</td>
</tr>
</table>

</div>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1132913"> </a>
ServerBase::create_servant_with_id()
</h3>
<h4 class="pHeading3"><a name="wp1132914"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1132915"> </a>
Creates a servant for this target object. This method supports the development of single-headed and multithreaded server applications.
</p>
<h4 class="pHeading3"><a name="wp1132916"> </a>
C++ Binding
</h4>
<a name="wp1132917"> </a><div class="pPreformatted"><pre><code class="cCode">Tobj_Servant</code> create_servant_with_id (const char* <code class="cCodeEmphasis">interfaceName</code>,<br />                                     const char* <code class="cCodeEmphasis">stroid</code>);</pre></div><h4 class="pHeading3"><a name="wp1132918"> </a>
Arguments
</h4>
<h4 class="pDefTerm"><a name="wp1132919"> </a>
<code class="cCodeEmphasis">interfaceName</code><code class="cCode"> </code>
</h4><div class="pDefPara"><a name="wp1132920"> </a>
Specifies a character string containing the fully qualified interface name for the object. This must be the same interface name that was supplied when the object reference was created. 
</div>
<h4 class="pDefTerm"><a name="wp1132921"> </a>
<code class="cCodeEmphasis">stroid</code><code class="cCode"> </code>
</h4><div class="pDefPara"><a name="wp1132922"> </a>
Specifies an object ID in string format. The object ID uniquely identifies the object associated with the request to be processed. This is the same object ID that was specified when the object reference was created.
</div>
<h4 class="pHeading3"><a name="wp1132923"> </a>
Description
</h4>
<p class="pBody"><a name="wp1132925"> </a>
The TP Framework invokes the <code class="cCode">create_servant_with_id</code> method when a request arrives at the server and there no servant is available to satisfy the request. The TP Framework passes in the interface name for the servant to be created and the object ID associated with the object with which the servant will be associated. The server application instantiates an appropriate C++ object and returns a pointer to it. Typically, the method contains a <code class="cCode">switch</code> statement on the interface name and creates a new object, depending on the interface name. Providing the object ID allows a servant implementation to make decisions during the creation of the servant instance that require knowledge of the target object. Reentrancy support is one example of how a servant implementation might employ knowledge of the target object.
</p>
<p class="pBody"><a name="wp1132926"> </a>
The <code class="cCode">ServerBase</code> class provides a default implementation of <code class="cCode">create_servant_with_id</code> which calls the standard <code class="cCode">create_servant</code> method passing the interface name. This default implementation ignores the target object ID parameter.
</p>
<a name="wp1132927"> </a>
<table class="Note">
<tr>
<td valign="top"><strong>Caution:</strong></td>
<td>The server application must not depend on the invocation of this method for every activation of a CORBA object. The server application must not handle the CORBA object state in the constructors or destructors of any servant classes for CORBA objects. This is because the TP Framework might reuse servants on activation and might not destroy servants on deactivation. </td>
</tr>
</table>
<h4 class="pHeading3"><a name="wp1132928"> </a>
Return Value
</h4>
<h4 class="pDefTerm"><a name="wp1132929"> </a>
<code class="cCode">Tobj_Servant</code>
</h4><div class="pDefPara"><a name="wp1132930"> </a>
A pointer to the newly created servant (instance) for the specified interface. Returns <code class="cCode">NULL</code> if either of these conditions is true:
<div class="pSmartList1NoteBullet"><ul>
<li><a name="wp1132931"> </a>Interface name not recognized</li>
<li><a name="wp1132932"> </a>Unable to create a servant</li>
</ul></div>
</div>
<h4 class="pHeading3"><a name="wp1132933"> </a>
Example
</h4>
<p class="pBody"><a name="wp1132934"> </a>
<code class="cCode">Tobj_Servant simple_per_request_server::create_servant_with_id(<br />        const char* intf_repos_id, const char* stroid)<br />{<br />        TP::userlog(&quot;create_servant_with_id called in thread %ld&quot;,<br />                      (unsigned long)SIMPTHR_GETCURRENTTHREADID);<br />	        <br />	        // Perform any necessary initialization based on<br />        // this object ID<br /> <br />        return create_servant(intf_repos_id);<br />}</code>
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1131235"> </a>
Server::initialize()
</h3>
<h4 class="pHeading3"><a name="wp1131236"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1131237"> </a>
Allows the application to perform application-specific initialization procedures, such as logging into a database, creating and registering well-known object factories, initializing global variables, and so forth.
</p>
<h4 class="pHeading3"><a name="wp1131238"> </a>
C++ Binding
</h4>
<a name="wp1131239"> </a><div class="pPreformatted"><pre><code class="cCode">class Server {<br />public:</code></pre></div><a name="wp1131240"> </a><div class="pPreformatted"><pre><code class="cCode">        CORBA::Boolean  initialize(int argc, char** argv);</code></pre></div><a name="wp1131241"> </a><div class="pPreformatted"><pre><code class="cCode">};</code></pre></div><h4 class="pHeading3"><a name="wp1131242"> </a>
Arguments
</h4>
<p class="pBody"><a name="wp1131243"> </a>
The<code class="cCode"> argc</code> and <code class="cCode">argv</code> arguments are passed from the command line. The <code class="cCode">argc</code> argument contains the name of the server. The <code class="cCode">argv</code> argument contains the first command-line option that is specific to the application, if there are any. 
</p>
<p class="pBody"><a name="wp1131244"> </a>
Command-line options are specified in the <code class="cCode">UBBCONFIG</code> file using the <code class="cCode">CLOPT</code> parameter in the entry for the server in the <code class="cCode">SERVERS</code> section. System-recognized options come first in the <code class="cCode">CLOPT</code> parameter, followed by a double-hyphen (<code class="cCode">--</code>), followed by the application-specific options. The value of <code class="cCode">argc</code> is one greater than the number of application-specific options. For details, see <code class="cCode">ubbconfig(5)</code> in the <a href="../rf5/rf5.html"><span style="font-style: italic">File Formats, Data Descriptions, MIBs, and System Processes Reference</span><span style="font-style: italic"></a></span>.
</p>
<h4 class="pHeading3"><a name="wp1131250"> </a>
Exceptions
</h4>
<p class="pBody"><a name="wp1131251"> </a>
If an exception is raised in <code class="cCode">Server::initialize()</code>, the TP Framework catches the exception. The TP Framework behavior is the same as if <code class="cCode">initialize()</code> returned FALSE (that is, an exception is considered to be a failure). In addition, an error message is written to the user log (<code class="cCode">ULOG</code>) file, as follows, for each exception type:
</p>
<h4 class="pDefTerm"><a name="wp1131253"> </a>
<code class="cCode">TobjS::InitializeFailed </code>
</h4><div class="pDefPara"><a name="wp1142690"> </a>
<code class="cCode">&quot;TPFW_CAT:1: ERROR: Exception in Server::initialize():IDL:beasys.com/TobjS/InitializeFailed:1.0. Reason = </code>reason<code class="cCode">&quot;</code>
</div>
<div class="pDefParaCont"><a name="wp1142711"> </a>
Where <code class="cCodeEmphasis">reason</code> is a string supplied by application code. For example:
</div>
<div class="pDefPara2"><a name="wp1131258"> </a>
<code class="cCode">Throw TobjS::InitializeFailed(<br />                  &quot;Couldn&#39;t register factory&quot;);</code>
</div><h4 class="pDefTerm"><a name="wp1131259"> </a>
 <code class="cCode">CORBA::Exception</code>
</h4><div class="pDefPara"><a name="wp1142744"> </a>
<code class="cCode">&quot;TPFW_CAT:1: ERROR: Exception in Server::initialize(): </code>exception<code class="cCode">. Reason = unknown&quot;</code>
</div>
<div class="pDefParaCont"><a name="wp1142773"> </a>
Where <code class="cCodeEmphasis">exception</code> is the interface ID of the CORBA exception that was raised.
</div>
<h4 class="pDefTerm"><a name="wp1131265"> </a>
<code class="cCode">Other Exceptions</code>
</h4><div class="pDefPara"><a name="wp1142820"> </a>
<code class="cCode">TPFW_CAT:1: ERROR: Exception in Server::initialize(): unknown exception. Reason = unknown&quot;</code> 
</div>
<h4 class="pHeading3"><a name="wp1131268"> </a>
Description
</h4>
<p class="pBody"><a name="wp1131269"> </a>
The <code class="cCode">initialize</code> callback method, which is invoked as the last step in server initialization, allows the application to perform application-specific initialization.
</p>
<p class="pBody"><a name="wp1131270"> </a>
Typically, a server application does the following tasks in <code class="cCode">Server::initialize</code>:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1131271"> </a>Creates references for CORBA object factories implemented in the server application and registers them with the FactoryFinder using the <code class="cCode">TP::register_factory()</code> operation.</li>
<li><a name="wp1131272"> </a>Initializes global variables, if any are used.</li>
<li><a name="wp1131273"> </a>Opens XA resource managers if any are used by the server application.</li>
</ul></div>
<p class="pBody"><a name="wp1131274"> </a>
It is the responsibility of the server application to open any required XA resource managers. This is done by invoking either of the following methods:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1131275"> </a><code class="cCode">TP::open_xa_rm()<br /></code>This is the preferred technique for server applications, since it can be done on a static function, without the need to obtain an object reference. </li>
</ul></div>
<a name="wp1131276"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>You must use the <code class="cCode">TP::open_xa_rm()</code> method if you use the INS bootstrap mechanism to obtain initial object references.</td>
</tr>
</table>

<div class="pSmartList1Bullet"><ul>
<li><a name="wp1131277"> </a><code class="cCode">Tobj::TransactionCurrent::open_xa_rm()<br /></code>A reference to the TransactionCurrent object can be obtained from the Bootstrap object. For an explanation of how to obtain a reference to the Bootstrap object, see the section <a href="tpfw.html#wp1071439">TP::bootstrap()</a>. For more information about the TransactionCurrent object, see the <a href="boot.html">CORBA Bootstrapping Programming Reference</a> section and <a href="../trans/index.html">Using CORBA Transactions</a>. </li>
<li><a name="wp1131289"> </a>Transactions may be started in the <code class="cCode">initialize</code> method after invoking the <code class="cCode">Tobj::TransactionCurrent::open_xa_rm()</code> or <code class="cCode">TP::open_xa_rm</code> method. However, any transactions that are started in <code class="cCode">initialize()</code> must be terminated by the server application before <code class="cCode">initialize()</code> returns. If the transactions are still active when control is returned, the server application fails to boot, and it exits gracefully. This happens because the server application has no logical way of either committing or rolling back the transaction after <code class="cCode">Server::initialize()</code> returns. This condition is an error.</li>
</ul></div>
<h4 class="pHeading3"><a name="wp1131290"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1131291"> </a>
Boolean <code class="cCode">TRUE</code> or <code class="cCode">FALSE</code>. <code class="cCode">TRUE</code> indicates success. <code class="cCode">FALSE</code> indicates failure. If an error occurs in <code class="cCode">initialize()</code>, the application code should return <code class="cCode">FALSE</code>. The application code should not call the system call<code class="cCode"> exit()</code>. Calling <code class="cCode">exit()</code> does not give the TP Framework a chance to release resources allocated during startup and may cause unpredictable results.
</p>
<p class="pBody"><a name="wp1131292"> </a>
If the return value is <code class="cCode">FALSE</code>: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1131293"> </a><code class="cCode">Server::release()</code> is not invoked.</li>
<li><a name="wp1131294"> </a>Any transactions that are started in the <code class="cCode">initialize()</code> method and are not terminated will eventually time out; they are not automatically rolled back.</li>
</ul></div>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1134413"> </a>
ServerBase::thread_initialize()
</h3>
<h4 class="pHeading3"><a name="wp1134414"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1134415"> </a>
Performs any necessary application-specific initialization for a thread created using the Oracle Tuxedo software. This method supports the development of a multithreaded server application.
</p>
<h4 class="pHeading3"><a name="wp1134419"> </a>
C++ Binding
</h4>
<a name="wp1134420"> </a><div class="pPreformatted"><pre><code class="cCode">CORBA::Boolean</code> thread_initialize(int argc, char** argv)</pre></div><h4 class="pHeading3"><a name="wp1134421"> </a>
Arguments
</h4>
<h4 class="pDefTerm"><a name="wp1134422"> </a>
<code class="cCode">argc</code>
</h4><div class="pDefPara"><a name="wp1134423"> </a>
The number of arguments provided to the application. Initially, this count is passed to the <code class="cCode">main</code> function<code class="cCode">.</code>
</div>
<h4 class="pDefTerm"><a name="wp1134424"> </a>
<code class="cCode">argv</code>
</h4><div class="pDefPara"><a name="wp1134425"> </a>
The arguments provided to the application. Initially, these arguments are passed to the <code class="cCode">main</code> function. 
</div>
<h4 class="pHeading3"><a name="wp1134426"> </a>
Description
</h4>
<p class="pBody"><a name="wp1134430"> </a>
In managing the thread pool, the Oracle Tuxedo software creates and releases threads using the operating system thread library services. Depending on application requirements, these threads might need to be initialized before they are used to process requests.
</p>
<p class="pBody"><a name="wp1144965"> </a>
The <code class="cCode">thread_initialize</code> callback method is invoked each time a thread is created, to initialize the thread. Note that the Oracle Tuxedo software manages a number of system-owned threads that are used for dispatching requests; these system-owned threads are in addition to those threads in the thread pool. Under some circumstances the servant methods you implement are also executed in these system-owned threads; for this reason the Oracle Tuxedo software invokes the <code class="cCode">thread_initialize</code> method to initialize the system-owned threads.
</p>
<p class="pBody"><a name="wp1134439"> </a>
The <code class="cCode">ServerBase</code> class provides a default implementation of the <code class="cCode">thread_initialize</code> method that opens the XA resource manager in the initialized thread.
</p>
<h4 class="pHeading3"><a name="wp1134440"> </a>
Return Value
</h4>
<h4 class="pDefTerm"><a name="wp1134441"> </a>
<code class="cCode">CORBA::Boolean</code>
</h4><div class="pDefPara"><a name="wp1134442"> </a>
<code class="cCode">True</code> if the initialization of the thread was successful.
</div>
<h4 class="pHeading3"><a name="wp1134443"> </a>
Example
</h4>
<p class="pBody"><a name="wp1134444"> </a>
<code class="cCode">CORBA::Boolean simple_per_request_server::thread_initialize(<br />                       int argc, char** argv)<br />{<br />        TP::userlog(&quot;thread_initialize called in thread %ld&quot;,<br />                      (unsigned long)SIMPTHR_GETCURRENTTHREADID);<br />        return CORBA_TRUE;<br />}</code>
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1131295"> </a>
Server::release()
</h3>
<h4 class="pHeading3"><a name="wp1131296"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1131297"> </a>
Allows the application to perform any application-specific cleanup, such as logging off a database, unregistering well-known factories, or deallocating resources.
</p>
<h4 class="pHeading3"><a name="wp1131298"> </a>
C++ Binding
</h4>
<a name="wp1131299"> </a><div class="pPreformatted"><pre><code class="cCode">typedef Tobj_ServantBase* Tobj_Servant;</code></pre></div><a name="wp1131300"> </a><div class="pPreformatted"><pre><code class="cCode">class Server {<br />public:<br />        void      release();<br />};</code></pre></div><h4 class="pHeading3"><a name="wp1131301"> </a>
Arguments
</h4>
<p class="pBody"><a name="wp1131302"> </a>
	None.
</p>
<h4 class="pHeading3"><a name="wp1131303"> </a>
Exceptions
</h4>
<p class="pBody"><a name="wp1131304"> </a>
If an exception is raised in <code class="cCode">release()</code>, the TP Framework catches the exception. Each exception causes an error message to be written to the user log (<code class="cCode">ULOG</code>) file, as follows:
</p>
<h4 class="pDefTerm"><a name="wp1131306"> </a>
<code class="cCode">TobjS::ReleaseFailed </code>
</h4><div class="pDefPara"><a name="wp1142835"> </a>
<code class="cCode">&quot;TPFW_CAT:2: WARN: Exception in Server::release(): IDL:beasys.com/TobjS/ReleaseFailed:1.0. Reason = </code><code class="cCodeEmphasis">reason</code><code class="cCode">&quot;</code>
</div>
<div class="pDefParaCont"><a name="wp1142840"> </a>
Where <code class="cCodeEmphasis">reason</code> is a string supplied by application code. For example:
</div>
<div class="pDefPara2"><a name="wp1131311"> </a>
<code class="cCode">Throw TobjS::ReleaseFailed(<br />           &quot;Couldn&#39;t unregister factory&quot;);</code>
</div><h4 class="pDefTerm"><a name="wp1131312"> </a>
<code class="cCode">CORBA::Exception</code>
</h4><div class="pDefPara"><a name="wp1142843"> </a>
<code class="cCode">&quot;TPFW_CAT:2: WARN: Exception in Server::release(): </code><code class="cCodeEmphasis">exception</code><code class="cCode">. Reason = unknown&quot;</code>
</div>
<div class="pDefParaCont"><a name="wp1142848"> </a>
Where <code class="cCode">exception</code> is the interface ID of the CORBA exception that was raised.
</div>
<h4 class="pDefTerm"><a name="wp1131317"> </a>
Other Exceptions
</h4><div class="pDefPara"><a name="wp1142853"> </a>
<code class="cCode">&quot;TPFW_CAT:2: WARN: Exception in Server::release(): unknown exception. Reason = unknown&quot;</code>
</div>
<p class="pBody"><a name="wp1131319"> </a>
In all cases, the server continues to exit.
</p>
<h4 class="pHeading3"><a name="wp1131320"> </a>
Description
</h4>
<p class="pBody"><a name="wp1131321"> </a>
The<code class="cCode"> release </code>callback method, which is invoked as the first step in server shutdown, allows the server application to perform any application-specific cleanup. The user must override the virtual function definition.
</p>
<p class="pBody"><a name="wp1131322"> </a>
Typical tasks performed by the application in this method are as follows:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1131323"> </a>Close XA resource managers.</li>
<li><a name="wp1131324"> </a>Unregister CORBA object factories that were registered with the FactoryFinder in <code class="cCode">Server::initialize()</code>.</li>
<li><a name="wp1131325"> </a>Deallocate any server resources not yet released.</li>
</ul></div>
<p class="pBody"><a name="wp1131326"> </a>
This method is normally called in response to a <code class="cCode">tmshutdown</code> command from the administrator or operator.
</p>
<p class="pBody"><a name="wp1131327"> </a>
The TP Framework provides a default implementation of <code class="cCode">Server::release()</code>. The default implementation closes XA resource managers for the server. The implementation does this by issuing a <code class="cCode">tx_close()</code> invocation, which uses the default <code class="cCode">CLOSEINFO</code> configured for the server&#39;s group in the <code class="cCode">UBBCONFIG</code> file.
</p>
<p class="pBody"><a name="wp1131328"> </a>
It is the responsibility of the application to close any open XA resource managers. This is done by issuing either of the following calls:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1131329"> </a><code class="cCode">TP::close_xa_rm()</code></li>
</ul></div>
<a name="wp1131330"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>You must use the <code class="cCode">TP::close_xa_rm()</code> method if you use the INS bootstrap mechanism to obtain initial object references.</td>
</tr>
</table>

<div class="pSmartList1Bullet"><ul>
<li><a name="wp1131331"> </a><code class="cCode">Tobj::TransactionCurrent::close_xa_rm()</code>. A reference to the TransactionCurrent object can be obtained from the Bootstrap object. For an explanation of how to obtain a reference to the Bootstrap object, see the section <a href="tpfw.html#wp1071439">TP::bootstrap()</a>. For more information about the TransactionCurrent object, see <a href="boot.html">CORBA Bootstrapping Programming Reference</a> and <a href="../trans/index.html">Using CORBA Transactions</a>. </li>
</ul></div>
<a name="wp1131343"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Once a server receives a request from the <code class="cCode">tmshutdown(1)</code> command to shut down, it can no longer receive requests from other remote objects. This may require servers to be shut down in a specific order. For example, if the <code class="cCode">Server::release()</code> method in Server 1 needs to access a method of an object that resides in Server 2, Server 2 should be shut down after Sever 1 is shut down. In particular, the <code class="cCode">TP::unregister_factory()</code> method accesses the FactoryFinder Registrar object that resides in a separate server. The <code class="cCode">TP::unregister_factory()</code> method is typically invoked from the <code class="cCode">release()</code> method; therefore, the FactoryFinder server should be shut down after all servers that call <code class="cCode">TP::unregister_factory()</code> in their <code class="cCode">Server::release()</code> method.</td>
</tr>
</table>

<h4 class="pHeading3"><a name="wp1131344"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1131345"> </a>
None.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1101781"> </a>
ServerBase::thread_release()
</h3>
<h4 class="pHeading3"><a name="wp1101782"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1101785"> </a>
Performs application-specific cleanup when a thread that was created by the Oracle Tuxedo software is released. This method supports the development of a multithreaded server application.
</p>
<h4 class="pHeading3"><a name="wp1101787"> </a>
C++ Binding
</h4>
<a name="wp1101788"> </a><div class="pPreformatted"><pre>void thread_release()</pre></div><h4 class="pHeading3"><a name="wp1101789"> </a>
Arguments
</h4>
<p class="pBody"><a name="wp1101790"> </a>
None.
</p>
<h4 class="pHeading3"><a name="wp1101793"> </a>
Description
</h4>
<p class="pBody"><a name="wp1101794"> </a>
The <code class="cCode">thread_release</code> callback method is invoked each time a thread is released. Implement the <code class="cCode">thread_release</code> method as necessary to perform application-specific resource cleanup.
</p>
<p class="pBody"><a name="wp1101796"> </a>
The <code class="cCode">ServerBase</code> class provides a default implementation of the <code class="cCode">thread_release</code> method that closes the XA resource manager in the released thread.
</p>
<h4 class="pHeading3"><a name="wp1118658"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1118659"> </a>
None.
</p>
<h4 class="pHeading3"><a name="wp1101797"> </a>
Example
</h4>
<p class="pBody"><a name="wp1101798"> </a>
<code class="cCode">void simple_per_request_server::thread_release()<br />{<br />        TP::userlog(&quot;thread_release called in thread %ld&quot;,<br />                    (unsigned long)SIMPTHR_GETCURRENTTHREADID);<br />}</code>
</p>
<h3 class="pHeading2"><a name="wp1028801"> </a>
Tobj_ServantBase Interface
</h3>
<p class="pBody"><a name="wp1017351"> </a>
The <code class="cCode">Tobj_ServantBase</code> interface inherits from the <code class="cCode">PortableServer::RefCountServantBase</code> class and defines operations that allow a CORBA object to assist in the management of its state in a thread-safe manner. Every implementation skeleton generated by the IDL compiler automatically inherits from the <code class="cCode">Tobj_ServantBase</code> class. The <code class="cCode">Tobj_ServantBase</code> class contains two virtual methods, <code class="cCode">activate_object()</code> and <code class="cCode">deactivate_object()</code>, that may be optionally implemented by the programmer.
</p>
<p class="pBody"><a name="wp1017352"> </a>
Whenever a request comes in for an inactive CORBA object, the object is activated and the <code class="cCode">activate_object()</code> method is invoked on the servant. When the CORBA object is deactivated, the <code class="cCode">deactivate_object()</code> method is invoked on the servant. The timing of deactivation is driven by the implementation&#8217;s activation policy. When the <code class="cCode">deactivate_object()</code> method is invoked, the TP Framework passes in a reason code to indicate why the call was made.
</p>
<p class="pBody"><a name="wp1103513"> </a>
These methods support the development of a multithreaded server application:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1103514"> </a><code class="cCode">TobjServantBase::_add_ref()</code></li>
<li><a name="wp1103515"> </a><code class="cCode">TobjServantBase::_is_reentrant()</code></li>
<li><a name="wp1103516"> </a><code class="cCode">TobjServantBase::_remove_ref()</code></li>
</ul></div>
<a name="wp1017353"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td><code class="cCode">Tobj_ServantBase::activate_object()</code> and <code class="cCode">Tobj_ServantBase::deactivate_object()</code> are the only methods that the TP Framework guarantees will be invoked for CORBA object activation and deactivation. The servant class constructor and destructor may or may not be invoked at activation or deactivation time (through the <code class="cCode">Server::create_servant</code> call for C++). Therefore, the server application code must not do any state handling for CORBA objects in either the constructor or destructor of the servant class.</td>
</tr>
</table>

<a name="wp1103508"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The programmer does not need to use a cast or reference to <code class="cCode">Tobj_ServantBase</code> directly. The <code class="cCode">Tobj_ServantBase</code> methods show up as part of the skeleton and, therefore, in the implementation class for a servant. The programmer may provide definitions for the <code class="cCode">activate_object</code> and <code class="cCode">deactivate_object</code> methods, but the programmer should never make direct invocations on those methods; only the TP Framework should call those methods.</td>
</tr>
</table>

<h5 class="pHeading4"><a name="wp1103510"> </a>
C++ Declaration (in Tobj_ServantBase.h)
</h5>
<p class="pBody"><a name="wp1017355"> </a>
The C++ mapping for the <code class="cCode">Tobj_servantBase</code> interface is as follows:
</p>
<a name="wp1135083"> </a><div class="pPreformatted"><pre>class Tobj_ServantBase : public PortableServer::RefCountServantBase {<br />public:</pre></div><a name="wp1135086"> </a><div class="pPreformatted"><pre>    Tobj_ServantBase&amp; operator=(const Tobj_ServantBase&amp;);<br />    Tobj_ServantBase() {}<br />    Tobj_ServantBase(const Tobj_ServantBase&amp; s) :<br />        PortableServer::RefCountServantBase(s) {}</pre></div><a name="wp1135091"> </a><div class="pPreformatted"><pre>    virtual void activate_object(const char *) {}</pre></div><a name="wp1135093"> </a><div class="pPreformatted"><pre>    virtual void deactivate_object(const char*, <br />        TobjS::DeactivateReasonValue) {}</pre></div><a name="wp1135428"> </a><div class="pPreformatted"><pre>    virtual CORBA::Boolean _is_reentrant() { return CORBA_FALSE; }<br />};</pre></div><a name="wp1135099"> </a><div class="pPreformatted"><pre>typedef Tobj_ServantBase * Tobj_Servant;</pre></div><p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1017358"> </a>
Tobj_ServantBase:: activate_object()
</h3>
<h4 class="pHeading3"><a name="wp1017359"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1017360"> </a>
Associates an object ID with a servant. This method gives the application an opportunity to restore the object&#8217;s state when the object is activated. The state may be restored from shared memory, from an ordinary flat file, or from a database file.
</p>
<h4 class="pHeading3"><a name="wp1017361"> </a>
C++ Binding
</h4>
<a name="wp1017362"> </a><div class="pPreformatted"><pre><code class="cCode">class Tobj_ServantBase : public PortableServer::ServantBase {<br />public:	<br />        virtual void activate_object(const char * stroid) {}<br />};</code></pre></div><h4 class="pHeading3"><a name="wp1017363"> </a>
Argument
</h4>
<h4 class="pDefTerm"><a name="wp1017364"> </a>
<code class="cCode">stroid</code>
</h4><div class="pDefPara"><a name="wp1017365"> </a>
Specifies<span style="font-style: italic"> </span>the object ID in string format. The object ID uniquely identifies this instance of the class. This is the same object ID that was specified when the object reference was created (using <code class="cCode">TP:create_object_reference()</code>) or in the <code class="cCode">TP::create_active_object_reference()</code> for the object reference used for this invocation.
<a name="wp1060434"> </a><table class="ListNote">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The restriction on the length of the object ID has been removed in this release.</td>
</tr>
</table>

</div>
<h4 class="pHeading3"><a name="wp1017370"> </a>
Description
</h4>
<p class="pBody"><a name="wp1017371"> </a>
Object activation is triggered by a client invoking a method on an inactive CORBA object. This causes the Portable Object Adapter (POA) to assign a servant to the CORBA object. The <code class="cCode">activate_object()</code> method is invoked before the method invoked by the client is invoked. If <code class="cCode">activate_object()</code> returns successfully, that is, without raising an exception, the requested method is executed on the servant. 
</p>
<p class="pBody"><a name="wp1017372"> </a>
The <code class="cCode">activate_object() </code>and <code class="cCode">deactivate_object()</code> methods and the method invoked by the client can be used by the programmer to manage object state. The particular way these methods are used to manage object state may vary according to the needs of the application. For a discussion of how these methods might be used, see <a href="../cservers/index.html">Creating CORBA Server Applications</a>. 
</p>
<p class="pBody"><a name="wp1017376"> </a>
If the object is currently infected with a global transaction, <code class="cCode">activate_object()</code> executes within the scope of that same global transaction.
</p>
<p class="pBody"><a name="wp1017377"> </a>
It is the responsibility of the programmer of the object to check that the stored state of the object is consistent. In other words, it is up to the application code to save a persistent flag that indicates whether or not <code class="cCode">deactivate_object()</code> successfully saved the state of the object. That flag should be checked in <code class="cCode">activate_object()</code>.
</p>
<h4 class="pHeading3"><a name="wp1118677"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1118678"> </a>
None. 
</p>
<h4 class="pHeading3"><a name="wp1017378"> </a>
Exceptions
</h4>
<p class="pBody"><a name="wp1017379"> </a>
If an error occurs while executing <code class="cCode">activate_object()</code>, the application code should raise either a CORBA standard exception or a <code class="cCode">TobjS::ActivateObjectFailed</code> exception. When an exception is raised, the TP Framework catches the exception, and the following events occur:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1017380"> </a>The activation fails. </li>
<li><a name="wp1017381"> </a>The method invoked by the client is not executed. </li>
<li><a name="wp1017382"> </a>If <code class="cCode">activate_object()</code> is executing within a transaction and the client initiated the transaction, the transaction is <em class="cEmphasis">not</em> rolled back. </li>
<li><a name="wp1017383"> </a>A <code class="cCode">CORBA::OBJECT_NOT_EXIST</code> exception is raised back to the client.</li>
</ul></div>
<a name="wp1017384"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>For each CORBA interface, set <code class="cCode">AUTOTRAN</code> to <code class="cCode">Yes</code> if you want a transaction to start automatically when an operation invocation is received. Setting <code class="cCode">AUTOTRAN</code> to <code class="cCode">Yes</code> has no effect if the interface is already in transaction mode. For more information about <code class="cCode">AUTOTRAN</code>, see <a href="../trans/index.html">Using CORBA Transactions</a>.</td>
</tr>
</table>

<div class="pSmartList1Bullet"><ul>
<li><a name="wp1017388"> </a>Based on the exception is raised, a message is written to the user log (<code class="cCode">ULOG</code>) file, as follows:</li>
</ul></div>
<h4 class="pDefTerm"><a name="wp1017390"> </a>
<code class="cCode">TobjS::ActivateObjectFailed </code>
</h4><div class="pDefPara"><a name="wp1142879"> </a>
<code class="cCode">&quot;TPFW_CAT:24: ERROR: Activating object - application raised TobjS::ActivateObjectFailed. Reason = </code><code class="cCodeEmphasis">reason</code><code class="cCode">. Interface = </code><code class="cCodeEmphasis">interfaceName</code><code class="cCode">, OID = </code><code class="cCodeEmphasis">oid</code><code class="cCode">&quot;</code>
</div>
<div class="pDefParaCont"><a name="wp1142884"> </a>
Where <code class="cCodeEmphasis">reason</code> is a user-supplied reason, and <code class="cCodeEmphasis">interfaceName</code> and <code class="cCodeEmphasis">oid</code> are the interface ID and object ID, respectively, of the invoked CORBA object.
</div>
<h4 class="pDefTerm"><a name="wp1017396"> </a>
<code class="cCode">TobjS::OutOfMemory </code>
</h4><div class="pDefPara"><a name="wp1142891"> </a>
<code class="cCode">&quot;TPFW_CAT:22: ERROR: Activating object - application raised TobjS::OutOfMemory. Reason = reason. Interface = </code><code class="cCodeEmphasis">interfaceName</code><code class="cCode">, OID = </code><code class="cCodeEmphasis">oid</code><code class="cCode">&quot;</code>
</div>
<div class="pDefParaCont"><a name="wp1142896"> </a>
Where <code class="cCodeEmphasis">reason</code> is a user-supplied reason, and <code class="cCodeEmphasis">interfaceName</code> and <code class="cCodeEmphasis">oid</code> are the interface ID and object ID, respectively, of the invoked CORBA object.
</div>
<h4 class="pDefTerm"><a name="wp1017402"> </a>
<code class="cCode">CORBA::Exception</code>
</h4><div class="pDefPara"><a name="wp1142903"> </a>
<code class="cCode">&quot;TPFW_CAT:25: ERROR: Activating object - CORBA Exception not handled by application. Exception ID = exceptionID. Interface = </code><code class="cCodeEmphasis">interfaceName</code><code class="cCode">, OID = </code><code class="cCodeEmphasis">oid</code><code class="cCode">&quot;</code>
</div>
<div class="pDefParaCont"><a name="wp1142908"> </a>
Where <code class="cCodeEmphasis">exceptionID</code> is the interface ID of the exception, and <code class="cCodeEmphasis">interfaceName</code> and <code class="cCodeEmphasis">oid</code> are the interface ID and object ID, respectively, of the invoked CORBA object.
</div>
<h4 class="pDefTerm"><a name="wp1017408"> </a>
<code class="cCode">Other exception</code>
</h4><div class="pDefPara"><a name="wp1142915"> </a>
<code class="cCode">&quot;TPFW_CAT:26: ERROR: Activating object - Unknown Exception not handled by application. Exception ID = exceptionID. Interface = </code>interfaceName<code class="cCode">, OID = </code>oid<code class="cCode">&quot;</code>
</div>
<div class="pDefParaCont"><a name="wp1142920"> </a>
Where <code class="cCodeEmphasis">exceptionID</code> is the interface ID of the exception, and <code class="cCodeEmphasis">interfaceName</code> and <code class="cCodeEmphasis">oid</code> are the interface ID and object ID, respectively, of the invoked CORBA object.
</div>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1103525"> </a>
Tobj_ServantBase::_add_ref()
</h3>
<h4 class="pHeading3"><a name="wp1103526"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1103527"> </a>
Adds a reference to a servant. This method supports the development of a multithreaded server application.
</p>
<a name="wp1134966"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>In applications written using Oracle Tuxedo release 8.0 or later, use this method instead of the <code class="cCode">TP::application_responsibility()</code> method.</td>
</tr>
</table>

<h4 class="pHeading3"><a name="wp1103528"> </a>
C++ Binding
</h4>
<a name="wp1103530"> </a><div class="pPreformatted"><pre>void _add_ref()</pre></div><h4 class="pHeading3"><a name="wp1103531"> </a>
Arguments
</h4>
<p class="pBody"><a name="wp1103532"> </a>
None.
</p>
<h4 class="pHeading3"><a name="wp1103535"> </a>
Description
</h4>
<p class="pBody"><a name="wp1103536"> </a>
Invoke this method when a reference to a servant is needed. Invoking this method causes the reference count for the servant to increment by one.
</p>
<h4 class="pHeading3"><a name="wp1118694"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1118695"> </a>
None.
</p>
<h4 class="pHeading3"><a name="wp1103537"> </a>
Example
</h4>
<a name="wp1103538"> </a><div class="pPreformatted"><pre><code class="cCode">myServant * servant = new intf_i();<br /></code>if(servant != NULL)<br />   servant-&gt;_add_ref();</pre></div><p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1017415"> </a>
Tobj_ServantBase::deactivate_object()
</h3>
<h4 class="pHeading3"><a name="wp1017416"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1017417"> </a>
Removes the association of an object ID with its servant. This method gives the application an opportunity to save all or part of the object&#8217;s state before the object is deactivated. The state may be saved in shared memory, in an ordinary flat file, or in a database file.
</p>
<h4 class="pHeading3"><a name="wp1017418"> </a>
C++ Binding
</h4>
<a name="wp1017419"> </a><div class="pPreformatted"><pre><code class="cCode">class Tobj_ServantBase : public PortableServer::ServantBase {<br />public:	<br />        virtual void deactivate_object(const char* stroid,<br />                       TobjS::DeactivateReasonValue  reason) {}<br />};</code></pre></div><h4 class="pHeading3"><a name="wp1017420"> </a>
Arguments
</h4>
<h4 class="pDefTerm"><a name="wp1017421"> </a>
<code class="cCode">stroid</code>
</h4><div class="pDefPara"><a name="wp1017422"> </a>
Specifies<span style="font-style: italic"> </span>the object ID in string format. The object ID uniquely identifies this instance of the class.
<a name="wp1060447"> </a><table class="ListNote">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The restriction on the length of the object ID has been removed in this release.</td>
</tr>
</table>

</div>
<h4 class="pDefTerm"><a name="wp1017424"> </a>
<code class="cCode">reason</code>
</h4><div class="pDefPara"><a name="wp1017425"> </a>
Indicates the event that caused this method to be invoked. The <code class="cCode">reason</code> code can be one of the following:
</div>
<div class="pDefTerm2"><h4 class="pDefTerm2"><a name="wp1017426"> </a>
<code class="cCode">DR_METHOD_END</code>
</h4></div>
<div class="pDefPara2"><a name="wp1017427"> </a>
Indicates that the object is being deactivated after the completion of a method. It is used if the object&#8217;s deactivation policy is:
</div><div class="pDefPara2"><a name="wp1017428"> </a>
<code class="cCode">- method</code>
</div><div class="pDefPara2"><a name="wp1017429"> </a>
<code class="cCode">- transaction</code> (only if there is no transaction in effect)
</div><div class="pDefPara2"><a name="wp1142931"> </a>
<code class="cCode">- process</code> (if <code class="cCode">TP::deactivateEnable()</code> called)
</div><div class="pDefTerm2"><h4 class="pDefTerm2"><a name="wp1017431"> </a>
<code class="cCode">DR_SERVER_SHUTDOWN</code>
</h4></div>
<div class="pDefPara2"><a name="wp1017432"> </a>
Indicates that the object is being deactivated because the server is being shut down in an orderly fashion. It is used if the object&#8217;s deactivation policy is:
</div><div class="pDefPara2"><a name="wp1017433"> </a>
<code class="cCode">- transaction</code> (only if transaction is active)
</div><div class="pDefPara2"><a name="wp1017434"> </a>
<code class="cCode">- process</code>
</div><div class="pDefPara2"><a name="wp1017435"> </a>
Note that when a server is shut down in an orderly fashion, all transactions that the server is involved in are marked for rollback. 
</div><div class="pDefTerm2"><h4 class="pDefTerm2"><a name="wp1017439"> </a>
<code class="cCode">DR_TRANS_ABORTED</code>
</h4></div>
<div class="pDefPara2"><a name="wp1017440"> </a>
This <code class="cCode">reason</code> code is used only for objects that have the <code class="cCode">transaction</code> activation policy. It can occur when the transaction is started by either the client or automatically by the system. When the<code class="cCode"> deactivate_object()</code> method is invoked with this reason code, the transaction is marked for rollback only. 
</div><div class="pDefPara"><a name="wp1017445"> </a>
<code class="cCode">DR_TRANS_COMMITTING</code>
</div>
<div class="pDefPara2"><a name="wp1017446"> </a>
This <code class="cCode">reason</code> code is used only for objects that have the <code class="cCode">transaction</code> activation policy. It can occur when the transaction is started by either the client or the TP Framework. It indicates that a <code class="cCode">Current.commit()</code> operation was invoked for the transaction in which the object is involved. The <code class="cCode">deactivate_object()</code> method is invoked just before the transaction manager&#8217;s two-phase commit algorithm begins; that is, before <code class="cCode">prepare</code> is sent to the resource managers. 
</div><div class="pDefPara2"><a name="wp1017450"> </a>
The CORBA object is allowed to vote on the outcome of the transaction when the <code class="cCode">deactivate_object()</code> method is invoked with the <code class="cCode">DR_TRANS_COMMITTING</code> <code class="cCode">reason</code> code. By invoking <code class="cCode">Current.rollback_only()</code>, the method can force the transaction to be rolled back; otherwise, the two-phase commit algorithm continues. The transaction is not necessarily committed just because the <code class="cCode">Current.rollback_only()</code> is not invoked in this method. Any other CORBA object or resource manager involved in the transaction could also vote to roll back the transaction.
</div><div class="pDefPara"><a name="wp1029414"> </a>
<code class="cCode">DR_EXPLICIT_DEACTIVATE</code>
</div>
<div class="pDefPara2"><a name="wp1069991"> </a>
Indicates that the object is being deactivated because the application executed a <code class="cCode">TP::deactivateEnable(-,-,-)</code> on this object. This can happen only for objects that have the <code class="cCode">process</code> activation policy.
</div><h4 class="pHeading3"><a name="wp1017454"> </a>
 Description
</h4>
<p class="pBody"><a name="wp1017455"> </a>
Object deactivation is initiated either by the system or by the application, depending on the activation policy of the implementation for the CORBA object. The <code class="cCode">deactivate_object() </code>method is invoked before the CORBA object is deactivated. For details of these policies and their use, see the section <a href="imp_cnfg.html#wp1011789">ICF Syntax</a>. 
</p>
<p class="pBody"><a name="wp1017459"> </a>
Deactivation may occur after an execution of a method invoked by a client if the activation policy for the CORBA object implementation is <code class="cCode">method</code>, or as a result of the end of transactional work if the activation policy is <code class="cCode">transaction.</code> It may also occur as the result of server shutdown if the activation policy is <code class="cCode">transaction</code> or <code class="cCode">process</code>. 
</p>
<p class="pBody"><a name="wp1050099"> </a>
In addition, the Oracle Tuxedo software supports the use of user-controlled deactivation of CORBA objects having an activation policy of <code class="cCode">process</code> or <code class="cCode">method</code> via the use of the <code class="cCode">TP::deactivateEnable()</code> and <code class="cCode">TP::deactivateEnable(-,-,-)</code> methods. <code class="cCode">TP::deactivateEnable</code> can be called inside a method of an object to cause the object to be deactivated at the end of the method. If <code class="cCode">TP::deactivateEnable</code> is called in an object with the <code class="cCode">transaction</code> activation policy, an exception is raised (<code class="cCode">TobjS::IllegalOperation</code>) and the TP Framework takes no action. <code class="cCode">TP::deactivateEnable(-,-,-)</code> can be called to deactivate any object that has a <code class="cCode">process</code> activation policy. For more information, see the section <a href="tpfw.html#wp1017782">TP::deactivateEnable()</a>.
</p>
<a name="wp1051929"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The <code class="cCode">deactivate_object</code> method will be called at server shutdown time for every object remaining in the Active Object Map, whether it was entered there implicitly by the TP Framework (the activation-on-demand technique: <code class="cCode">TP::create_servant</code> and the servant&#8217;s <code class="cCode">activate_object</code> method) or explicitly by the user with <code class="cCode">TP::create_active_object_reference</code>.</td>
</tr>
</table>

<p class="pBody"><a name="wp1051927"> </a>
The <code class="cCode">activate_object()</code> and <code class="cCode">deactivate_object()</code> methods and explicit methods invoked by the client can be used by the programmer to manage object state. The manner in which these methods are used to manage object state may vary according to the needs of the application. For a discussion of how these methods might be used, see <a href="../cservers/index.html">Creating CORBA Server Applications</a>. 
</p>
<p class="pBody"><a name="wp1053037"> </a>
The CORBA object with <code class="cCode">transaction</code> activation policy gets to vote on the outcome of the transaction when the <code class="cCode">deactivate_object() </code>method is invoked with the <code class="cCode">DR_TRANS_COMMITTING</code> reason code. By calling <code class="cCode">Current.rollback_only()</code> the method can force the transaction to be rolled back; otherwise, the two-phase commit algorithm continues. The transaction will not necessarily be committed just because <code class="cCode">Current.rollback_only()</code> is not called in this method. Any other CORBA object or resource manager involved in the transaction could also vote to roll back the transaction.
</p>
<h4 class="pHeading3"><a name="wp1017469"> </a>
<b class="cBold">Restriction</b>
</h4>
<p class="pBody"><a name="wp1017470"> </a>
Note that if the object is involved in a transaction when this method is invoked, there are restrictions on what type of processing can be done based on the reason the object is invoked. If the object was involved in a transaction, the activation policy is <code class="cCode">transaction</code> and the <code class="cCode">reason</code> code for the call is:
</p>
<h4 class="pDefTerm"><a name="wp1017471"> </a>
<code class="cCode">DR_TRANS_ABORTED</code> 
</h4><div class="pDefPara"><a name="wp1017472"> </a>
No invocations on any CORBA objects are allowed in the method. No <code class="cCode">tpcall()</code> is allowed. Transactions cannot be suspended or begun.
</div>
<h4 class="pDefTerm"><a name="wp1017473"> </a>
<code class="cCode">DR_TRANS_COMMITTING</code>
</h4><div class="pDefPara"><a name="wp1017474"> </a>
No invocations on any CORBA objects are allowed in the method. No <code class="cCode">tpcall()</code> is allowed. Transactions cannot be suspended or begun.
</div>
<p class="pBody"><a name="wp1053781"> </a>
The reason for these restrictions is that the deactivation of objects with activation policy transaction is controlled by a call to the TP Framework from the transaction manager for the transaction. When the call with <code class="cCode">reason</code> code <code class="cCode">DR_TRANS_COMMITTING</code> is made, the transaction manager is executing phase 1 (prepare) of the two-phase commit. At this stage, it is not possible to issue a call to suspend a transaction nor to initiate a new transaction. Since a call to a CORBA object that was in another process would require that process to join the transaction, and the transaction manager is already executing the prepare phase, this would cause an error<a href="#wp1054892" title="Footnote 1"><sup class="Footnote">1</sup></a>. Since a call to a CORBA object that had no transactional properties would require that the current transaction be suspended, this would also cause an error. The same is true of a <code class="cCode">tpcall()</code>.
</p>
<p class="pBody"><a name="wp1054702"> </a>
Similarly, when the invocation with <code class="cCode">reason</code> code <code class="cCode">DR_TRANS_ABORTED</code> is made, the transaction manager is already aborting. While the transaction manager is aborting, it is not possible to either suspend a transaction or initiate a new transaction. The same restrictions apply as for <code class="cCode">DR_TRANS_COMMITTING</code>.
</p>
<h4 class="pHeading3"><a name="wp1118709"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1118710"> </a>
None. 
</p>
<h4 class="pHeading3"><a name="wp1055823"> </a>
Exceptions
</h4>
<p class="pBody"><a name="wp1056694"> </a>
If the CORBA object method that is invoked by the client raises an exception, that exception is caught by the TP Framework and is eventually returned to the client. This is true even if <code class="cCode">deactivate_object()</code> is invoked and raises an exception. 
</p>
<p class="pBody"><a name="wp1056715"> </a>
The client will never be notified about exceptions that are raised in <code class="cCode">deactivate_object()</code>. It is the responsibility of the application code to check that the stored state of the CORBA object is consistent. For example, the application code could save a persistent flag that indicates whether or not <code class="cCode">deactivate_object()</code> successfully saved the state. That flag can then be checked in <code class="cCode">activate_object()</code>.
</p>
<p class="pBody"><a name="wp1056502"> </a>
If an error occurs while executing <code class="cCode">deactivate_object()</code>, the application code should raise either a CORBA standard exception or a <code class="cCode">DeactivateObjectFailed</code> exception<span style="font-style: italic">.</span> If <code class="cCode">deactivate_object()</code> was invoked by the TP Framework, the TP Framework catches the exception and the following events occur:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1017480"> </a>The object is deactivated.</li>
<li><a name="wp1017481"> </a>If the client initiated a transaction, the transaction is not rolled back.</li>
<li><a name="wp1017482"> </a>The client is not notified of the exception that is raised in <code class="cCode">deactivate_object()</code>.</li>
<li><a name="wp1017483"> </a>Based on which exception is raised, a message is logged to the user log (<code class="cCode">ULOG</code>) file, as follows:</li>
</ul></div>
<h4 class="pDefTerm"><a name="wp1017485"> </a>
<code class="cCode">TobjS::DeactivateObjectFailed </code>
</h4><div class="pDefPara"><a name="wp1142938"> </a>
<code class="cCode">&quot;TPFW_CAT:27: ERROR: De-activating object - application raised TobjS::DeactivateObjectFailed. Reason = </code><code class="cCodeEmphasis">reason</code><code class="cCode">. Interface = </code>interfaceName<code class="cCode">, OID = </code>oid<code class="cCode">&quot;</code>
</div>
<div class="pDefParaCont"><a name="wp1142943"> </a>
Where <code class="cCodeEmphasis">reason</code> is a user-supplied reason, and <code class="cCodeEmphasis">interfaceName</code> and <code class="cCodeEmphasis">oid</code> are the interface ID and object ID, respectively, of the invoked CORBA object.
</div>
<h4 class="pDefTerm"><a name="wp1017491"> </a>
<code class="cCode">CORBA::Exception</code>
</h4><div class="pDefPara"><a name="wp1142950"> </a>
<code class="cCode">&quot;TPFW_CAT:28: ERROR: De-activating object - CORBA Exception not handled by application. Exception ID = </code><code class="cCodeEmphasis">exceptionID</code><code class="cCode">. Interface = </code><code class="cCodeEmphasis">interfaceName</code><code class="cCode">, OID = </code><code class="cCodeEmphasis">oid</code><code class="cCode">&quot;</code>
</div>
<div class="pDefParaCont"><a name="wp1142958"> </a>
Where <code class="cCodeEmphasis">exceptionID</code> is the interface ID of the exception, and <code class="cCodeEmphasis">interfaceName</code> and <code class="cCodeEmphasis">oid</code> are the interface ID and object ID, respectively, of the invoked CORBA object.
</div>
<h4 class="pDefTerm"><a name="wp1017497"> </a>
<code class="cCode">Other exception</code>
</h4><div class="pDefPara"><a name="wp1142965"> </a>
<code class="cCode">&quot;TPFW_CAT:29: ERROR: De-activating object - Unknown Exception not handled by application. Exception ID = </code><code class="cCodeEmphasis">exceptionID</code><code class="cCode">. Interface = </code><code class="cCodeEmphasis">interfaceName</code><code class="cCode">, OID = </code><code class="cCodeEmphasis">oid</code><code class="cCode">&quot;</code>
</div>
<div class="pDefParaCont"><a name="wp1142970"> </a>
Where <code class="cCodeEmphasis">exceptionID</code> is the interface ID of the exception, and <code class="cCodeEmphasis">interfaceName</code> and <code class="cCodeEmphasis">oid</code> are the interface ID and object ID, respectively, of the invoked CORBA object.
</div>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1103793"> </a>
Tobj_ServantBase::_is_reentrant()
</h3>
<h4 class="pHeading3"><a name="wp1103794"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1103795"> </a>
Indicates that the object supports concurrent, reentrant invocations. This method supports the development of a multithreaded server application.
</p>
<h4 class="pHeading3"><a name="wp1103796"> </a>
C++ Binding
</h4>
<a name="wp1103798"> </a><div class="pPreformatted"><pre><code class="cCode">CORBA::Boolean</code> _<code style="font-style: normal" class="cCode">is</code><span style="font-style: italic">_</span>reentrant()</pre></div><h4 class="pHeading3"><a name="wp1103799"> </a>
Arguments
</h4>
<p class="pBody"><a name="wp1103800"> </a>
None.
</p>
<h4 class="pHeading3"><a name="wp1103804"> </a>
Description
</h4>
<p class="pBody"><a name="wp1103808"> </a>
The Oracle Tuxedo server infrastructure calls this method to determine whether the servant implementation supports a reentrant invocation. To support reentrancy, a servant must include the necessary code to protect the integrity of its state while multiple threads interact with the object. 
</p>
<p class="pBody"><a name="wp1103810"> </a>
The <code class="cCode">Tobj_ServantBase</code> class provides a default implementation of the<code class="cCode"> _is_reentrant</code> method that returns <code class="cCode">FALSE</code>.
</p>
<h4 class="pHeading3"><a name="wp1118722"> </a>
Return Value
</h4>
<h4 class="pDefTerm"><a name="wp1118723"> </a>
<code class="cCode">CORBA::Boolean</code>
</h4><div class="pDefPara"><a name="wp1118724"> </a>
Returns <code class="cCode">TRUE</code> if the servant can support reentrancy.
</div>
<h4 class="pHeading3"><a name="wp1103811"> </a>
Example
</h4>
<p class="pBody"><a name="wp1103812"> </a>
<code class="cCode">CORBA::Boolean Simple_i::_is_reentrant()<br />{       TP::userlog(&quot;_is_reentrant called in thread %ld&quot;,<br />                       (unsigned long)SIMPTHR_GETCURRENTTHREADID);<br />        return CORBA_TRUE;<br />}</code>
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1103813"> </a>
Tobj_ServantBase::_remove_ref()
</h3>
<h4 class="pHeading3"><a name="wp1103814"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1103815"> </a>
Releases a reference to a servant. This method supports the development of a multithreaded server application.
</p>
<a name="wp1134992"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>In applications written using Oracle Tuxedo release 8.0 or later, use this method instead of the C++ &#8220;delete&#8221; statement that you used previously with the <code class="cCode">TP::application_responsibility()</code> method.</td>
</tr>
</table>

<h4 class="pHeading3"><a name="wp1103816"> </a>
C++ Binding
</h4>
<a name="wp1103818"> </a><div class="pPreformatted"><pre>void _remove_ref()</pre></div><h4 class="pHeading3"><a name="wp1103819"> </a>
Parameters
</h4>
<p class="pBody"><a name="wp1103820"> </a>
None.
</p>
<h4 class="pHeading3"><a name="wp1103823"> </a>
Description
</h4>
<p class="pBody"><a name="wp1103824"> </a>
Invoke this method when a reference to a servant is no longer needed. Invoking this method causes the reference count for the servant to be decremented by one. If the <code class="cCode">_remove_ref()</code> method brings the reference count to zero, it also calls the C++ &#8220;delete&#8221; statement on its own <code class="cCode">this</code> pointer and deletes the servant.
</p>
<h4 class="pHeading3"><a name="wp1118734"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1118735"> </a>
None.
</p>
<h4 class="pHeading3"><a name="wp1103825"> </a>
Example
</h4>
<a name="wp1103826"> </a><div class="pPreformatted"><pre>if(servant != NULL)<br />   servant-&gt;_remove_ref();</pre></div><h3 class="pHeading2"><a name="wp1054951"> </a>
TP Interface
</h3>
<p class="pBody"><a name="wp1017659"> </a>
The TP interface supplies a set of service methods that can be invoked by application code. This is the <span style="font-style: italic">only</span> interface in the TP Framework that can safely be invoked by application code. All other interfaces have callback methods that are intended to be invoked only by system code.
</p>
<p class="pBody"><a name="wp1017660"> </a>
The purpose of this interface is to provide high-level calls that application code can call, instead of calls to underlying APIs provided by the Portable Object Adapter (POA), the CORBA Naming Service, and the Oracle Tuxedo system. By using these calls, programmers can learn a simpler API and are spared the complexity of the underlying APIs. The TP interface implicitly uses two features of the Oracle Tuxedo software that extend the CORBA APIs:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1017665"> </a>Factories and the FactoryFinder object</li>
<li><a name="wp1017666"> </a>Factory-based routing</li>
</ul></div>
<p class="pBody"><a name="wp1056716"> </a>
For information about the FactoryFinder object, see the section <a href="factory.html">FactoryFinder Interface</a>. For more information about factory-based routing, see <a href="../ads/index.html">Setting Up a Oracle Tuxedo Application</a>.
</p>
<h5 class="pHeading4"><a name="wp1017667"> </a>
Usage Notes
</h5>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1017668"> </a>During server application initialization, the application constructs the object reference for an application factory. It then invokes the <code class="cCode">register_factory()</code> method, passing in the factory&#39;s object reference together with a factory <code class="cCode">id</code> field. On server release (shutdown), the application uses the <code class="cCode">unregister_factory()</code> method to unregister the factory.</li>
<li><a name="wp1017669"> </a>The <code class="cCode">TP</code> class is a C++ native class.</li>
<li><a name="wp1017670"> </a>The <code class="cCode">TP.h</code> file contains the declarations and definitions for the <code class="cCode">TP</code> class.</li>
</ul></div>
<p class="pBody"><a name="wp1017671"> </a>
C++ Declarations (in<code class="cCode"> TP.h</code>)
</p>
<p class="pBody"><a name="wp1017672"> </a>
The C++ mapping is as follows:
</p>
<a name="wp1070932"> </a><div class="pPreformatted"><pre><code class="cCode">class TP {<br />public:<br />   static CORBA::Object_ptr  create_object_reference(<br />                                  </code>const char*    interfaceName, <br />                                  const char*   stroid,<br />                                  CORBA::NVList_ptr criteria);<br />   static CORBA::Object_ptr  create_active_object_reference(	<br />                                  const char*  interfaceName, <br />                                  const char* stroid,<br />                                  Tobj_Servant servant);<br />   static CORBA::Object_ptr  get_object_reference();	<br />   static void               register_factory(<br />                                  CORBA::Object_ptr factory_or, <br />                                  const char*       factory_id);<br />   static void               unregister_factory(<br />                                  CORBA::Object_ptr factory_or,<br />                                  const char*       factory_id);<br />   static void               deactivateEnable()<br />   static void               deactivateEnable(<br />                                  const char*  interfaceName,<br />                                  const char* stroid,<br />                                  Tobj_Servant servant);<br />   static CORBA::ORB_ptr     orb();<br />   static Tobj_Bootstrap*    bootstrap();<br />   static void               open_xa_rm();<br />   static void               close_xa_rm();<br />   static int                userlog(char*, ... );<br />   static char*                 get_object_id(CORBA::Object_ptr obj);<br />   static void               application_responsibility(<br />                                 Tobj_Servant servant);<br />};</pre></div><p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1071637"> </a>
TP::application_responsibility()
</h3>
<h4 class="pHeading3"><a name="wp1071638"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1073325"> </a>
Tells the TP Framework that the application is taking responsibility for the servant&#8217;s lifetime.
</p>
<a name="wp1134941"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Do not use this method in applications written using Oracle Tuxedo release 8.0 or later; instead, use the Tobj_<code class="cCode">ServantBase::_add_ref()</code> method.</td>
</tr>
</table>

<h4 class="pHeading3"><a name="wp1073324"> </a>
C++ Binding
</h4>
<a name="wp1071639"> </a><div class="pPreformatted"><pre><code class="cCode">static void application_responsibility(Tobj_Servant servant);</code></pre></div><h4 class="pHeading3"><a name="wp1071640"> </a>
Arguments
</h4>
<h4 class="pDefTerm"><a name="wp1071641"> </a>
<code class="cCode">servant</code>
</h4><div class="pDefPara"><a name="wp1073323"> </a>
A pointer to a servant that is already known to the TP Framework.
</div>
<h4 class="pHeading3"><a name="wp1118772"> </a>
Exceptions
</h4>
<h4 class="pDefTerm"><a name="wp1118773"> </a>
<code class="cCode">TobjS::InvalidServant</code>
</h4><div class="pDefPara"><a name="wp1118779"> </a>
Indicates that the specified servant is NULL.
</div>
<h4 class="pHeading3"><a name="wp1073312"> </a>
Description
</h4>
<p class="pBody"><a name="wp1071645"> </a>
This method tells the TP Framework that the application is taking responsibility for the servant&#8217;s lifetime. As a result of this call, when the TP Framework has completed deactivating the object (that is, after invoking the servant&#8217;s <code class="cCode">deactivate_object</code> method), the TP Framework does nothing more with the object.
</p>
<p class="pBody"><a name="wp1071646"> </a>
Once an application has taken responsibility for a servant, the application must take care to delete servant when it is no longer needed, the same as for any other C++ instance.
</p>
<p class="pBody"><a name="wp1071647"> </a>
If the servant is not known to the TP Framework (that is, it is not active), this call has no effect.
</p>
<h4 class="pHeading3"><a name="wp1118745"> </a>
Return Values
</h4>
<p class="pBody"><a name="wp1118746"> </a>
None.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1071439"> </a>
TP::bootstrap()
</h3>
<h4 class="pHeading3"><a name="wp1017676"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1017677"> </a>
Returns a pointer to a <code class="cCode">Tobj::Tobj_Bootstrap</code> object. The Bootstrap object is used to access initial object references for the FactoryFinder object, the Interface Repository, the TransactionCurrent, and the SecurityCurrent objects. 
</p>
<h4 class="pHeading3"><a name="wp1017678"> </a>
C++ Binding
</h4>
<a name="wp1017679"> </a><div class="pPreformatted"><pre><code class="cCode">static Tobj_Bootstrap* TP::bootstrap</code><code class="cCodeBold">();</code></pre></div><h4 class="pHeading3"><a name="wp1017680"> </a>
Arguments
</h4>
<p class="pBody"><a name="wp1017681"> </a>
None.
</p>
<h4 class="pHeading3"><a name="wp1017682"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1017683"> </a>
Upon successful completion, <code class="cCode">bootstrap()</code> returns a pointer to the <code class="cCode">Tobj::Tobj_Bootstrap</code> object that is created by the TP Framework when the server application is started.
</p>
<h4 class="pHeading3"><a name="wp1118768"> </a>
Exceptions
</h4>
<p class="pBody"><a name="wp1118769"> </a>
None.
</p>
<h4 class="pHeading3"><a name="wp1017684"> </a>
Description
</h4>
<p class="pBody"><a name="wp1017685"> </a>
The TP Framework creates a <code class="cCode">Tobj::Tobj_Bootstrap</code> object as part of initialization; it is not necessary for the application code to create any other <code class="cCode">Tobj::Tobj_Bootstrap</code> objects in the server.
</p>
<a name="wp1017686"> </a>
<table class="Note">
<tr>
<td valign="top"><strong>Caution:</strong></td>
<td>Because the TP Framework owns the <code class="cCode">Tobj::Tobj_Bootstrap </code>object, server application code must not dispose of the Bootstrap object.</td>
</tr>
</table>
<a name="wp1109787"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>If you are using the CORBA INS bootstrap mechanism and you are not using the <code class="cCode">SecurityCurrent</code> for security or <code class="cCode">TransactionCurrent</code> for transactions, you do not need to use the Bootstrap object.</td>
</tr>
</table>

<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1017690"> </a>
TP::close_xa_rm()
</h3>
<h4 class="pHeading3"><a name="wp1017691"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1017692"> </a>
Closes the XA resource manager to which the invoking process is linked.
</p>
<h4 class="pHeading3"><a name="wp1017693"> </a>
C++ Binding
</h4>
<a name="wp1017694"> </a><div class="pPreformatted"><pre><code class="cCode">static void TP::close_xa_rm ();</code></pre></div><h4 class="pHeading3"><a name="wp1017695"> </a>
Arguments
</h4>
<p class="pBody"><a name="wp1017696"> </a>
None.
</p>
<h4 class="pHeading3"><a name="wp1017699"> </a>
Description
</h4>
<p class="pBody"><a name="wp1017700"> </a>
The <code class="cCode">close_xa_rm()</code> method closes the XA resource manager to which the invoking process is linked. XA resource managers are provided by database vendors, such as Oracle and Informix.
</p>
<a name="wp1017701"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The functionality of this call is also provided by <code class="cCode">Tobj::TransactionCurrent::close_xa_rm()</code>. The <code class="cCode">TP::close_xa_rm() </code>method provides a more convenient way for a server application to close a resource manager because there is no need to obtain an object reference to the TransactionCurrent object. A reference to the TransactionCurrent object can be obtained from the Bootstrap object. See <a href="tpfw.html#wp1071439">TP::bootstrap()</a> for an explanation of how to obtain a reference to the Bootstrap object. For more information about the TransactionCurrent object, see the <a href="boot.html">CORBA Bootstrapping Programming Reference</a> section and <a href="../trans/index.html">Using CORBA Transactions</a>.</td>
</tr>
</table>

<p class="pBody"><a name="wp1017711"> </a>
This method should be invoked once from the <code class="cCode">Server::release()</code> method for each server that is involved in global transactions. This includes servers that are linked with an XA resource manager, as well as servers that are involved in global transactions, but are not actually linked with an XA-compliant resource manager.
</p>
<p class="pBody"><a name="wp1017712"> </a>
The <code class="cCode">close_xa_rm()</code> method should be invoked in place of a close invocation that is specific to the resource manager. Because resource managers differ in their initialization semantics, the specific information needed to close a particular resource manager is placed in the <code class="cCode">CLOSEINFO</code> parameter in the <code class="cCode">GROUPS</code> section of the Oracle Tuxedo system <code class="cCode">UBBCONFIG</code> file.
</p>
<p class="pBody"><a name="wp1017716"> </a>
The format of the <code class="cCode">CLOSEINFO</code> string is dependent on the requirements of the database vendor providing the underlying resource manager. For more information about the <code class="cCode">CLOSEINFO</code> parameter, see <a href="../ads/index.html">Setting Up a Oracle Tuxedo Application</a> and the <code class="cCode">ubbconfig(5)</code> reference page in the <a href="../rf5/rf5.html">File Formats, Data Descriptions, MIBs, and System Processes Reference</a>. Also, refer to database vendor documentation for information about how to develop and install applications that use the XA libraries.
</p>
<h4 class="pHeading3"><a name="wp1118791"> </a>
Return Values
</h4>
<p class="pBody"><a name="wp1118792"> </a>
None.
</p>
<h4 class="pHeading3"><a name="wp1017723"> </a>
Exceptions
</h4>
<h4 class="pDefTerm"><a name="wp1017724"> </a>
<code class="cCode">CORBA::BAD_INV_ORDER</code>
</h4><div class="pDefPara"><a name="wp1017725"> </a>
There is an active transaction. The resource manager cannot be closed while a transaction is active.
</div>
<h4 class="pDefTerm"><a name="wp1017726"> </a>
<code class="cCode">Tobj::RMFailed</code>
</h4><div class="pDefPara"><a name="wp1017727"> </a>
The <code class="cCode">tx_close()</code> call returned an error return code.
</div>
<a name="wp1017728"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Unlike other exceptions returned by the TP Framework, the <code class="cCode">Tobj::RMFailed</code> exception is defined in <code class="cCode">tobj_c.h</code> (which is derived from <code class="cCode">tobj.idl</code>), not <code class="cCode">TobjS_c.h</code> (which is derived from <code class="cCode">TobjS.idl</code>). This is because native clients can also open XA resource managers. Therefore, the exception returned is consistent with the exception expected by native client code and by <code class="cCode">Server::release()</code> if it uses the alternate mechanism, <code class="cCode">TransactionCurrent::close_xa_rm</code>, which is shared with native clients. </td>
</tr>
</table>

<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1074107"> </a>
TP::create_active_object_reference()
</h3>
<h4 class="pHeading3"><a name="wp1074108"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1075053"> </a>
Creates an object reference and preactivates an object.
</p>
<h4 class="pHeading3"><a name="wp1075052"> </a>
C++ Binding
</h4>
<a name="wp1074109"> </a><div class="pPreformatted"><pre><code class="cCode">static CORBA::Object_ptr<br />    create_active_object_reference(<br />           const char*       interfaceName, <br />           const char*      stroid,<br />           Tobj_Servant     servant);</code></pre></div><h4 class="pHeading3"><a name="wp1074113"> </a>
Arguments
</h4>
<h4 class="pDefTerm"><a name="wp1074114"> </a>
<code class="cCode">interfaceName</code>
</h4><div class="pDefPara"><a name="wp1075099"> </a>
Specifies a character string that contains the fully qualified interface name for the object. 
</div>
<h4 class="pDefTerm"><a name="wp1074116"> </a>
<code class="cCode">stroid</code>
</h4><div class="pDefPara"><a name="wp1075102"> </a>
Specifies the <code class="cCode">ObjectId</code> in string format. The <code class="cCode">ObjectId</code> uniquely identifies this instance of the class. The programmer decides what information to place in the <code class="cCode">ObjectId</code>. One possibility would be to use it to hold a database key. Choosing the value of an object identifier, and the degree of uniqueness, is part of the application design. The Oracle Tuxedo software cannot guarantee any uniqueness in object references, since these may be legitimately copied and shared outside the Oracle Tuxedo environment, for example by stringifying the object reference.
</div>
<h4 class="pDefTerm"><a name="wp1074118"> </a>
<code class="cCode">servant</code>
</h4><div class="pDefPara"><a name="wp1075111"> </a>
A pointer to a servant that the application has already created and initialized.
</div>
<h4 class="pHeading3"><a name="wp1119362"> </a>
Exceptions:
</h4>
<h4 class="pDefTerm"><a name="wp1119363"> </a>
<code class="cCode">TobjS::InvalidInterface</code>
</h4><div class="pDefPara"><a name="wp1119364"> </a>
Indicates that the specified interfaceName is NULL.
</div>
<h4 class="pDefTerm"><a name="wp1119365"> </a>
<code class="cCode">TobjS::InvalidObjectId</code>
</h4><div class="pDefPara"><a name="wp1119366"> </a>
Indicates the specified stroid is NULL.
</div>
<h4 class="pDefTerm"><a name="wp1119367"> </a>
<code class="cCode">TobjS::ServantAlreadyActive</code>
</h4><div class="pDefPara"><a name="wp1119368"> </a>
The object could not be activated explicitly because the servant is already being used with another <code class="cCode">ObjectId</code>. A servant can be used only with a single <code class="cCode">ObjectId</code>. To preactivate objects containing different <code class="cCode">ObjectId</code>s, the application must create multiple servants and preactivate them separately, one per <code class="cCode">ObjectId</code>. 
</div>
<h4 class="pDefTerm"><a name="wp1119369"> </a>
<code class="cCode">TobjS::ObjectAlreadyActive</code>
</h4><div class="pDefPara"><a name="wp1119370"> </a>
The object could not be activated explicitly because the <code class="cCode">ObjectId</code> is already being used in the Active Object Map. A given <code class="cCode">ObjectId</code> can have only one servant associated with it. To change to a different servant, the application must first deactivate the object and activate it again.
</div>
<h4 class="pDefTerm"><a name="wp1119371"> </a>
<code class="cCode">TobjS::IllegalOperation</code>
</h4><div class="pDefPara"><a name="wp1119372"> </a>
The object could not be activated explicitly because it does not have the process activation policy.
</div>
<h4 class="pHeading3"><a name="wp1074122"> </a>
Description
</h4>
<p class="pBody"><a name="wp1074123"> </a>
This method creates an object reference and preactivates an object. The resulting object reference may be passed to clients who will use it to access the object.
</p>
<p class="pBody"><a name="wp1074124"> </a>
Ordinarily, the application will call this method in two places:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1082868"> </a>In <code class="cCode">Server::initialize()</code> to preactivate process objects so that they do not need activation on the first invocation.</li>
<li><a name="wp1074126"> </a>In any method that creates object references to be returned to clients.</li>
</ul></div>
<p class="pBody"><a name="wp1074127"> </a>
This method allows an application to activate an object explicitly before its first invocation. (For reasons you might want to do this, refer to the section <a href="tpfw.html#wp1032097">Explicit Activation</a>.) The user first creates a servant and sets its state before calling <code class="cCode">create_active_object_reference</code>. The TP Framework then enters the servant and string <code class="cCode">ObjectId</code> in the Active Object Map. The result is exactly the same as if the TP Framework had previously invoked <code class="cCode">Server::create_servant</code>, received back the servant pointer, and then had invoked <code class="cCode">servant::activate_object</code>. 
</p>
<p class="pBody"><a name="wp1074128"> </a>
The object so activated must be for an interface that was declared with the process activation policy; otherwise, an exception is raised. 
</p>
<p class="pBody"><a name="wp1074129"> </a>
If the object is deactivated, an object reference held by a client might cause the object to be activated again in some other process. For a discussion about situations in which this might be a problem, refer to the section <a href="tpfw.html#wp1032097">Explicit Activation</a>.
</p>
<a name="wp1123455"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>There is one restriction on this method when the user-controlled concurrency policy option is set in the ICF file (See <a href="tpfw.html#wp1170256">Parallel Objects</a>.). The <code class="cCode">TP::create_active_object_reference</code> method throws a <code class="cCode">TobjS::IllegalOperation</code> exception if it is passed an interface with user-controlled concurrency set. Since the AOM is not used when user-controlled concurrency is set, there is no way for the TP Framework to connect an active object to this server.</td>
</tr>
</table>

<h4 class="pHeading3"><a name="wp1082276"> </a>
Caution
</h4>
<p class="pBody"><a name="wp1118812"> </a>
When you preactivate objects in an interface, you must specify an activation policy of <code class="cCode">process</code> in the ICF file for that interface. However, when you specify the <code class="cCode">process</code> activation policy for an interface in the ICF file, this can lead to the following problem.
</p>
<h5 class="pHeading4"><a name="wp1118813"> </a>
Problem Statement
</h5>
<div class="pSmartList1"><ol type="1" class="pSmartList1">
<li><a name="wp1118814"> </a>You write SERVER1 such that all objects on interface A are preactivated. To prevent the object from being activated on demand by the TP Framework, you write the interface&#39;s <code class="cCode">activate_object</code> method to always throw the <code class="cCode">ActivateObjectFailed</code> exception.</li>
<li><a name="wp1092511"> </a>SERVER2 also implements objects of interface A. However, instead of preactivating the objects, SERVER2 lets the TP Framework activate them on demand.</li>
<li><a name="wp1092518"> </a>If the administrator configures SERVER1 and SERVER2 in the same group, then a client can get an interface A object reference from SERVER2 and invoke on it. Then, due to load balancing, SERVER1 could be asked to activate an object on interface A. However, SERVER1 is not able to activate an object on interface A on demand because its <code class="cCode">activate_object</code> method throws the <code class="cCode">ActivateObjectFailed</code> exception. </li>
</ol></div>
<h5 class="pHeading4"><a name="wp1082282"> </a>
Workaround
</h5>
<p class="pBody"><a name="wp1082283"> </a>
You can avoid this problem by having the administrator configure SERVER1 and SERVER2 in different groups. The administrator uses the <code class="cCode">SERVERS</code> section of the <code class="cCode">UBBCONFIG</code> file to define groups.
</p>
<h4 class="pHeading3"><a name="wp1118830"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1118831"> </a>
The newly created object reference.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1081586"> </a>
TP::create_object_reference()
</h3>
<h4 class="pHeading3"><a name="wp1081587"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1017731"> </a>
Creates an object reference. The resulting object reference may be passed to clients who use it to access the object.
</p>
<h4 class="pHeading3"><a name="wp1017732"> </a>
C++ Binding
</h4>
<a name="wp1075149"> </a><div class="pPreformatted"><pre><code class="cCode">static CORBA::Object_ptr    TP::create_object_reference (<br />                               const char* interfaceName,<br />                               const </code>char*<code class="cCode"> stroid,<br />                               CORBA::NVList_ptr criteria);</code></pre></div><h4 class="pHeading3"><a name="wp1017734"> </a>
Arguments
</h4>
<h4 class="pDefTerm"><a name="wp1017735"> </a>
<code class="cCode">interfaceName</code>
</h4><div class="pDefPara"><a name="wp1017736"> </a>
Specifies a character string that contains the fully qualified interface name for the object.
<a name="wp1017737"> </a>
The interface name can be retrieved by making a call on the following interface typecode ID function:
</div>
<div class="pDefParaCont"><a name="wp1017738"> </a>
<code class="cCode">const char* _tc_&lt;</code><code class="cCodeEmphasis">CORBA interface name</code><code class="cCode">&gt;::id();</code>
<a name="wp1017739"> </a>
where <code class="cCodeEmphasis">&lt;CORBA interface name&gt;</code> is any object class name. For example:
<a name="wp1017740"> </a>
<code class="cCode">char* idlname = _tc_Simple-&gt;id();</code>
</div>
<h4 class="pDefTerm"><a name="wp1017741"> </a>
<code class="cCode">stroid</code>
</h4><div class="pDefPara"><a name="wp1017742"> </a>
Specifies<span style="font-style: italic"> </span>the <code class="cCode">ObjectId</code> in string format. The <code class="cCode">ObjectId</code> <span style="font-style: italic">uniquely</span> identifies this instance of the class. It is up to the programmer to decide what information to place in the <code class="cCode">ObjectId</code>. One possibility would be to use the <code class="cCode">ObjectId</code> to hold a database key. Choosing the value of an object identifier, and the degree of uniqueness, is part of the application design. The Oracle Tuxedo software cannot guarantee any uniqueness in object references, since object references may be legitimately copied and shared outside the Oracle Tuxedo domain (for example, by passing the object reference as a string). It is strongly recommended the you choose a unique <code class="cCode">ObjectId</code> in order to allow parallel execution of invokes on object references. 
<a name="wp1060460"> </a><table class="ListNote">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The restriction on the length of the <code class="cCode">ObjectId</code> has been removed in this release.</td>
</tr>
</table>

</div>
<h4 class="pDefTerm"><a name="wp1017750"> </a>
<code class="cCode">criteria</code>
</h4><div class="pDefPara"><a name="wp1017751"> </a>
Specifies a list of named values that can be used to provide factory-based routing for the object reference. The list is optional and is of type <code class="cCode">CORBA::NVList</code>. The use of factory-based routing is optional and is dependent on the use of this argument. If you do not want to use factory-based routing, you can pass a value of 0 (zero) for this argument. 
<a name="wp1017752"> </a>
The Oracle Tuxedo system administrator configures factory-based routing by specifying routing rules in the <code class="cCode">UBBCONFIG</code> file. See <a href="../ads/index.html">Setting Up a Oracle Tuxedo Application</a> online document for details on this facility.
</div>
<h4 class="pHeading3"><a name="wp1120612"> </a>
Exceptions
</h4>
<p class="pBody"><a name="wp1120613"> </a>
The following exceptions can be raised by the <code class="cCode">create_object_reference()</code> method:
</p>
<h4 class="pDefTerm"><a name="wp1120614"> </a>
<code class="cCode">InvalidInterface</code>
</h4><div class="pDefPara"><a name="wp1120615"> </a>
Indicates that the specified <code class="cCode">interfaceName</code> is NULL.
</div>
<h4 class="pDefTerm"><a name="wp1120616"> </a>
<code class="cCode">InvalidObjectId</code>
</h4><div class="pDefPara"><a name="wp1120617"> </a>
Indicates that the specified <code class="cCode">stroid</code> is NULL.
</div>
<h4 class="pHeading3"><a name="wp1082494"> </a>
Description
</h4>
<p class="pBody"><a name="wp1082495"> </a>
The server application is responsible for invoking the <code class="cCode">create_object_reference() </code>method. This method creates an object reference. The resulting object reference may be passed to clients who will use it to access the object.
</p>
<p class="pBody"><a name="wp1017761"> </a>
Ordinarily, the server application calls this method in two places:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1017762"> </a>In <code class="cCode">Server::initialize()</code> to create factories for the server.</li>
<li><a name="wp1017763"> </a>In factory methods to create object references to be returned to clients.</li>
</ul></div>
<p class="pBody"><a name="wp1017764"> </a>
For examples of how and when to call the <code class="cCode">create_object_reference()</code> method, see <a href="../cservers/index.html">Creating CORBA Server Applications</a>.
</p>
<h4 class="pHeading3"><a name="wp1120004"> </a>
Return Value
</h4>
<h4 class="pDefTerm"><a name="wp1120005"> </a>
<code class="cCode">Object</code>
</h4><div class="pDefPara"><a name="wp1120006"> </a>
The newly created object reference. 
</div>
<h4 class="pHeading3"><a name="wp1017774"> </a>
Example	
</h4>
<p class="pBody"><a name="wp1017775"> </a>
The following example shows how to use the criteria argument:
</p>
<a name="wp1017776"> </a><div class="pPreformatted"><pre><code class="cCode">CORBA::NVList_ptr criteria;<br />CORBA::Long branch_id = 7;<br />CORBA::Long account_id = 10001;<br />CORBA::Any any_val;</code></pre></div><a name="wp1017777"> </a><div class="pPreformatted"><pre><code class="cCode">// Create the list and assign to _var to cleanup on exit<br />CORBA::ORB::create_list (2, criteria);<br />CORBA::NVList_var criteria_var(criteria);</code></pre></div><a name="wp1017778"> </a><div class="pPreformatted"><pre><code class="cCode">// Add the BRANCH_ID<br />any_val &lt;&lt;= branch_id;<br />criteria-&gt;add_value(&quot;BRANCH_ID&quot;, any_val, 0);</code></pre></div><a name="wp1017779"> </a><div class="pPreformatted"><pre><code class="cCode">// Add the ACCOUNT_ID<br />any_val &lt;&lt;= account_id;<br />criteria-&gt;add_value(&quot;ACCOUNT_ID&quot;, any_val, 0);</code></pre></div><a name="wp1017780"> </a><div class="pPreformatted"><pre><code class="cCode">// Create the object reference.<br />TP::create_object_reference (&quot;IDL:BankApp/Teller:1.0&quot;,<br />&quot;Teller_01&quot;, criteria);</code></pre></div><p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1017782"> </a>
TP::deactivateEnable()
</h3>
<h4 class="pHeading3"><a name="wp1017783"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1017784"> </a>
Enables application-controlled deactivation of CORBA objects. 
</p>
<h4 class="pHeading3"><a name="wp1017785"> </a>
C++ Binding
</h4>
<p class="pBody"><a name="wp1075158"> </a>
Current-object format:
</p>
<a name="wp1075321"> </a><div class="pPreformatted"><pre><code class="cCode">static void           TP::deactivateEnable();</code></pre></div><p class="pBody"><a name="wp1075802"> </a>
Any-object format:
</p>
<a name="wp1075803"> </a><div class="pPreformatted"><pre>static void        TP::deactivateEnable(<br />                           const char*  interfaceName,<br />                           const char* stroid,<br />                            Tobj_Servant servant);</pre></div><h4 class="pHeading3"><a name="wp1079811"> </a>
Arguments
</h4>
<h4 class="pDefTerm"><a name="wp1079812"> </a>
<code class="cCode">interfaceName</code>
</h4><div class="pDefPara"><a name="wp1079813"> </a>
Specifies a character string that contains the fully qualified interface name for the object.
</div>
<h4 class="pDefTerm"><a name="wp1079814"> </a>
<code class="cCode">stroid</code>
</h4><div class="pDefPara"><a name="wp1079815"> </a>
Specifies the <code class="cCode">ObjectId</code> in string format for the object to be deactivated.
</div>
<h4 class="pDefTerm"><a name="wp1079816"> </a>
<code class="cCode">servant</code>
</h4><div class="pDefPara"><a name="wp1079817"> </a>
A pointer to the servant associated with the stroid.
</div>
<h4 class="pHeading3"><a name="wp1120782"> </a>
Exceptions
</h4>
<p class="pBody"><a name="wp1120783"> </a>
The following exceptions can be raised by the <code class="cCode">deactivateEnable()</code> method:
</p>
<h4 class="pDefTerm"><a name="wp1120784"> </a>
<code class="cCode">IllegalOperation </code>
</h4><div class="pDefPara"><a name="wp1120785"> </a>
Indicates that the <code class="cCode">TP::deactivateEnable</code> method was invoked by an object with the activation policy set to <code class="cCode">transaction</code>.
</div>
<h4 class="pDefTerm"><a name="wp1120786"> </a>
<code class="cCode">TobjS::ObjectNotActive</code>
</h4><div class="pDefPara"><a name="wp1120787"> </a>
In the Any-object format, the object specified could not be deactivated because it was not active (the <code class="cCode">stroid</code> and <code class="cCode">servant</code> parameters did not identify an object that was in the Active Object Map).
</div>
<h4 class="pHeading3"><a name="wp1075804"> </a>
Description
</h4>
<p class="pBody"><a name="wp1082877"> </a>
This method can be used to cause deactivation of an object, either the object currently executing (upon completion of the method in which it is called) or another object. It can only be used for objects with the process activation policy. It provides additional flexibility for objects with the <code class="cCode">process</code> activation policy.
</p>
<a name="wp1098317"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>For single-threaded servers, the <code class="cCode">TP::deactivateEnable(interface, object id, servant)</code> <code class="cCode">method</code> can be used to deactivate an object. However, if that object is currently in a transaction, the object will be deactivated when the transaction commits or rolls back. If an invoke occurs on the object before the transaction is committed or rolled back, the object will not be deactivated.</td>
</tr>
</table>

<a name="wp1127928"> </a><table class="Note">
<tr>
<td valign="top"><b class="texthide">Note:</b></td>
<td>To ensure the desired behavior, make sure that the object is not in a transaction or ensure that no invokes occur on the object after the <code class="cCode">TP::deactivateEnable()</code> call until the transaction is complete.</td>
</tr>
</table>
<a name="wp1127404"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>For multithreaded servers, use of the <code class="cCode">TP::deactivateEnable(interface, object id, servant)</code> <code class="cCode">method</code> is not supported for deactivation of objects in per-object servers. This method is supported for deactivation objects in per-request servers, however, the deactivation may be delayed because others threads are acting on the object. </td>
</tr>
</table>

<p class="pBody"><a name="wp1076060"> </a>
 Depending on which of the overloaded functions are called, the actions are as follows.
</p>
<h4 class="pDefTerm"><a name="wp1076040"> </a>
Current-object format
</h4><div class="pDefPara"><a name="wp1076041"> </a>
When called from within a method of an object with process activation policy, the object currently executing will be deactivated after completing the method being executed. 
<a name="wp1076042"> </a>
When called from within a method of an object with method activation, the effect is the same as the normal behavior of such objects (effectively, a NOOP). 
<a name="wp1076043"> </a>
When the object is deactivated, the TP Framework first removes the object from the Active Object Map. It then calls the associated servant&#8217;s <code class="cCode">deactivate_object</code> method with a reason of <code class="cCode">DR_METHOD_END</code>. 
</div>
<h4 class="pDefTerm"><a name="wp1076044"> </a>
Any-object format
</h4><div class="pDefPara"><a name="wp1076045"> </a>
The application can request deactivation of an object by specifying its <code class="cCode">ObjectId</code> and the associated servant. 
<a name="wp1082887"> </a>
If the object is currently executing, the TP Framework marks it for deactivation and waits until the object&#8217;s method completes before deactivating the object (as with the &#8220;current-object format&#8221;). If the object is not currently executing, the TP Framework may deactivate it immediately. No indication is given to the caller as to the status of the deactivation. When the object is deactivated, the TP Framework first removes the object from the Active Object Map. It then calls the associated servant&#8217;s <code class="cCode">deactivate_object</code> method with a reason of <code class="cCode">DR_EXPLICIT_DEACTIVATE</code>.
</div>
<p class="pBody"><a name="wp1082901"> </a>
If the object for which the deactivate is requested has a <code class="cCode">transaction</code> activation policy, an <code class="cCode">IllegalOperation</code> exception is raised. This is because deactivation of such objects may interfere with their correct notification of transaction completion by the Oracle Tuxedo transaction manager.
</p>
<h4 class="pHeading3"><a name="wp1120771"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1120772"> </a>
None.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1076686"> </a>
TP::get_object_id ()
</h3>
<h4 class="pHeading3"><a name="wp1076687"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1076869"> </a>
Allows a server to retrieve the string <code class="cCode">ObjectId</code> contained in an object reference that was created in the TP Framework.
</p>
<h4 class="pHeading3"><a name="wp1076868"> </a>
C++ Binding
</h4>
<a name="wp1076688"> </a><div class="pPreformatted"><pre><code class="cCode">char* TP::get_object_id(Corba::Object_ptr obj);</code></pre></div><h4 class="pHeading3"><a name="wp1076689"> </a>
Arguments
</h4>
<p class="pBody"><a name="wp1076690"> </a>
<code class="cCode">obj</code>
</p>
<p class="pBody"><a name="wp1076691"> </a>
The object reference from which to get the <code class="cCode">ObjectId</code>. 
</p>
<h4 class="pHeading3"><a name="wp1120808"> </a>
Exception
</h4>
<h4 class="pDefTerm"><a name="wp1120809"> </a>
<code class="cCode">TobjS::InvalidObject</code>
</h4><div class="pDefPara"><a name="wp1120810"> </a>
The object is nil or was not created by the TP Framework
</div>
<h4 class="pHeading3"><a name="wp1076694"> </a>
Description
</h4>
<p class="pBody"><a name="wp1076695"> </a>
This method allows a server to retrieve the string <code class="cCode">ObjectId</code> contained in an object reference that was created in the TP Framework. If the object reference was not created in the TP Framework (for example, it was created by a client ORB), an exception is raised.
</p>
<p class="pBody"><a name="wp1076696"> </a>
The caller must call <code class="cCode">CORBA::string_free</code> on the returned value when the object reference is no longer needed.
</p>
<h4 class="pHeading3"><a name="wp1120797"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1120798"> </a>
The string <code class="cCode">ObjectId</code> passed to <code class="cCode">TP::create_object_reference</code> or <code class="cCode">TP::create_active_object_reference</code> when the object reference was created.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1076084"> </a>
TP::get_object_reference()
</h3>
<h4 class="pHeading3"><a name="wp1017806"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1017807"> </a>
Returns a pointer to the current object. 
</p>
<h4 class="pHeading3"><a name="wp1017808"> </a>
C++ Binding
</h4>
<a name="wp1017809"> </a><div class="pPreformatted"><pre>static CORBA::Object_ptr <span style="font-weight: bold"> </span><code style="font-weight: normal" class="cCode">TP::get_object_reference</code><span style="font-weight: bold"> </span>();</pre></div><h4 class="pHeading3"><a name="wp1017810"> </a>
Arguments
</h4>
<p class="pBody"><a name="wp1017811"> </a>
None.
</p>
<p class="pBody"><a name="wp1017814"> </a>
Note that if <code class="cCode">get_object_reference()</code> is invoked from within either <code class="cCode">Server::initialize()</code> or <code class="cCode">Server::release()</code>, it is considered to be invoked outside the scope of an application&#8217;s TP object execution; therefore, the <code class="cCode">TobjS::NilObject</code> exception is raised.
</p>
<h4 class="pHeading3"><a name="wp1120833"> </a>
Exceptions
</h4>
<p class="pBody"><a name="wp1120834"> </a>
The following exception can be raised by the <code class="cCode">get_object_reference()</code> method:
</p>
<h4 class="pDefTerm"><a name="wp1120835"> </a>
<code class="cCode">NilObject</code>
</h4><div class="pDefPara"><a name="wp1120836"> </a>
Indicates that the method was invoked outside the scope of an application&#8217;s CORBA object execution. The <code class="cCode">reason</code> string contains <code class="cCode">OutOfScope</code>. 
</div>
<h4 class="pHeading3"><a name="wp1017815"> </a>
Description
</h4>
<p class="pBody"><a name="wp1017816"> </a>
This method returns a pointer to the current object. The <code class="cCode">CORBA::Object_ptr</code> pointer that is returned can be passed to a client.
</p>
<h4 class="pHeading3"><a name="wp1120822"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1120823"> </a>
The <code class="cCode">get_object_reference()</code> method returns a <code class="cCode">CORBA::Object_ptr</code> for the current object when invoked within the scope of a CORBA object execution. Otherwise, the <code class="cCode">TobjS::NilObject</code> exception is raised. 
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1017822"> </a>
TP::open_xa_rm()
</h3>
<h4 class="pHeading3"><a name="wp1017823"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1017824"> </a>
Opens the XA resource manager to which the invoking process is linked.
</p>
<h4 class="pHeading3"><a name="wp1017825"> </a>
C++ Binding
</h4>
<a name="wp1017826"> </a><div class="pPreformatted"><pre><code class="cCode">static void TP::open_xa_rm();</code></pre></div><h4 class="pHeading3"><a name="wp1017827"> </a>
Arguments
</h4>
<p class="pBody"><a name="wp1017828"> </a>
None.
</p>
<h4 class="pHeading3"><a name="wp1121120"> </a>
Exceptions
</h4>
<h4 class="pDefTerm"><a name="wp1121121"> </a>
<code class="cCode">Tobj::RMFailed</code>
</h4><div class="pDefPara"><a name="wp1121122"> </a>
The <code class="cCode">tx_open()</code> call returned an error return code.
<a name="wp1121123"> </a><table class="ListNote">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Unlike other exceptions returned by the TP Framework, this exception is defined in <code class="cCode">tobj_c.h</code> (which is derived from <code class="cCode">tobj.idl</code>), not in <code class="cCode">TobjS_c.h</code> (which is derived from <code class="cCode">TobjS.idl</code>). This is because native clients can also open XA resource managers. Therefore, the exception returned is consistent with the exception expected by native client code and by <code class="cCode">Server::release()</code> if it uses the alternate mechanism, <code class="cCode">TransactionCurrent::close_xa_rm</code>, which is shared with native clients.</td>
</tr>
</table>

</div>
<h4 class="pHeading3"><a name="wp1017837"> </a>
Description
</h4>
<p class="pBody"><a name="wp1017838"> </a>
The <code class="cCode">open_xa_rm()</code> method opens the XA resource manager to which the invoking process is linked. XA resource managers are provided by database vendors, such as Oracle and Informix.
</p>
<a name="wp1017839"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The functionality of this method is also provided by <code class="cCode">Tobj::TransactionCurrent::close_xa_rm().</code> However, <code class="cCode">TP::open_xa_rm()</code> provides a more convenient way for a server application to close a resource manager because there is no need to obtain an object reference to the TransactionCurrent object. A reference to the TransactionCurrent object can be obtained from the Bootstrap object. See <a href="tpfw.html#wp1071439">TP::bootstrap()</a> for an explanation of how to obtain a reference to the Bootstrap object. For more information about the TransactionCurrent object, see the <a href="boot.html">CORBA Bootstrapping Programming Reference</a> section and <a href="../trans/index.html">Using CORBA Transactions</a>.</td>
</tr>
</table>

<p class="pBody"><a name="wp1017849"> </a>
This method should be invoked once from the <code class="cCode">Server::initialize()</code> method for each server that participates in a global transaction. This includes servers that are linked with an XA resource manager, as well as servers that participate in a global transaction, but are not actually linked with an XA-compliant resource manager. 
</p>
<p class="pBody"><a name="wp1017850"> </a>
The <code class="cCode">open_xa_rm()</code> method should be invoked in place of an open invocation that is specific to a resource manager. Because resource managers differ in their initialization semantics, the specific information needed to open a particular resource manager is placed in the <code class="cCode">OPENINFO</code> parameter in the <code class="cCode">GROUPS</code> section of the <code class="cCode">UBBCONFIG</code> file. 
</p>
<p class="pBody"><a name="wp1097275"> </a>
The format of the <code class="cCode">OPENINFO</code> string is dependent on the requirements of the database vendor providing the underlying resource manager. For more information about the <code class="cCode">CLOSEINFO</code> parameter, see <a href="../ads/index.html">Setting Up a Oracle Tuxedo Application</a> and the <code class="cCode">ubbconfig(5) </code>reference page in the <a href="../rf5/rf5.html">File Formats, Data Descriptions, MIBs, and System Processes Reference</a>. Also, refer to database vendor documentation for information about how to develop and install applications that use the XA libraries.
</p>
<a name="wp1017858"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Only one resource manager can be linked to the invoking process. </td>
</tr>
</table>

<h4 class="pHeading3"><a name="wp1120852"> </a>
Return Values
</h4>
<p class="pBody"><a name="wp1120853"> </a>
None.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1017863"> </a>
TP::orb()
</h3>
<h4 class="pHeading3"><a name="wp1017864"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1017865"> </a>
Returns a pointer to an <code class="cCode">ORB</code> object.
</p>
<h4 class="pHeading3"><a name="wp1017866"> </a>
C++ Binding
</h4>
<a name="wp1017867"> </a><div class="pPreformatted"><pre>static CORBA::ORB_ptr <code class="cCode">TP::orb</code>();</pre></div><h4 class="pHeading3"><a name="wp1017868"> </a>
Arguments
</h4>
<p class="pBody"><a name="wp1017869"> </a>
None.
</p>
<h4 class="pHeading3"><a name="wp1121236"> </a>
Exceptions
</h4>
<p class="pBody"><a name="wp1121237"> </a>
None.
</p>
<h4 class="pHeading3"><a name="wp1017870"> </a>
Description
</h4>
<p class="pBody"><a name="wp1017871"> </a>
Access to the <code class="cCode">ORB</code> object allows the application to invoke ORB operations, such as <code class="cCode">string_to_object()</code> and <code class="cCode">object_to_string()</code>.
</p>
<a name="wp1060372"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Because the TP Framework owns the <code class="cCode">ORB</code> object, the application must not delete it.</td>
</tr>
</table>

<h4 class="pHeading3"><a name="wp1121225"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1121226"> </a>
Upon successful completion, <code class="cCode">orb()</code> returns a pointer to the <code class="cCode">ORB</code> object that is created by the TP Framework when the server program is started.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1058612"> </a>
TP::register_factory()
</h3>
<h4 class="pHeading3"><a name="wp1017878"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1017885"> </a>
Locates the Oracle Tuxedo FactoryFinder object and registers an Oracle Tuxedo factory.
</p>
<h4 class="pHeading3"><a name="wp1017886"> </a>
C++ Binding
</h4>
<a name="wp1017887"> </a><div class="pPreformatted"><pre>static void <code class="cCode">TP::register_factory</code>(<br />              CORBA::Object_ptr factory_or, const char* factory_id);</pre></div><h4 class="pHeading3"><a name="wp1017888"> </a>
Arguments
</h4>
<h4 class="pDefTerm"><a name="wp1017889"> </a>
<code class="cCode">factory_or</code>
</h4><div class="pDefPara"><a name="wp1017890"> </a>
Specifies the object reference that was created for an application factory using the <code class="cCode">TP::create_object_reference()</code> method. 
</div>
<h4 class="pDefTerm"><a name="wp1017891"> </a>
<code class="cCode">factory_id</code>
</h4><div class="pDefPara"><a name="wp1017892"> </a>
Specifies a string identifier that is used to identify the application factory. For some suggestions as to the composition of this string, see <a href="../cservers/index.html">Creating CORBA Server Applications</a>.
</div>
<h4 class="pHeading3"><a name="wp1121414"> </a>
Exceptions
</h4>
<p class="pBody"><a name="wp1121415"> </a>
The following exceptions can be raised by the <code class="cCode">register_factory()</code> method:
</p>
<h4 class="pDefTerm"><a name="wp1121416"> </a>
<code class="cCode">TobjS::CannotProceed</code>
</h4><div class="pDefPara"><a name="wp1121417"> </a>
Indicates that the FactoryFinder encountered an internal error during the search, with the error being written to the user log (<code class="cCode">ULOG</code>). Notify the operations staff immediately if this exception is raised. Depending on the severity of the internal error, the server running the FactoryFinder or the NameManager may have terminated. If a FactoryFinder service has terminated, start a new FactoryFinder service. If the NameManager has terminated, and there is another NameManager running, start a new one. If no NameManagers are running, restart the application.
</div>
<h4 class="pDefTerm"><a name="wp1121418"> </a>
<code class="cCode">TobjS::InvalidName</code>
</h4><div class="pDefPara"><a name="wp1121419"> </a>
Indicates that the <code class="cCode">id</code> string is empty. It is also raised if the field contains blank spaces or control characters.
</div>
<h4 class="pDefTerm"><a name="wp1121420"> </a>
<code class="cCode">TobjS::InvalidObject</code>
</h4><div class="pDefPara"><a name="wp1121421"> </a>
Indicates that the <code class="cCode">factory</code> value is nil.
</div>
<h4 class="pDefTerm"><a name="wp1121719"> </a>
<code class="cCode">TobjS::RegistrarNotAvailable</code>
</h4><div class="pDefPara"><a name="wp1121720"> </a>
Indicates that the FactoryFinder object cannot locate the NameManager. Notify the operations staff immediately if this exception is raised. If no naming services servers are running, restart the application.
<a name="wp1121721"> </a><table class="ListNote">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Another possible reason that this exception might occur is that the FactoryFinder cannot participate in a transaction. Therefore, you may need to suspend the current transaction before issuing the <code class="cCode">TP::register_factory()</code> and <code class="cCode">TP::unregister_factory()</code> calls. For information on suspending and resuming transactions, see <a href="../trans/index.html">Using CORBA Transactions</a> in the online documentation.</td>
</tr>
</table>

</div>
<h4 class="pDefTerm"><a name="wp1121726"> </a>
<code class="cCode">TobjS::OverFlow</code>
</h4><div class="pDefPara"><a name="wp1121727"> </a>
Indicates that the <code class="cCode">id</code> string is longer than 128 bytes (currently the maximum allowable length). 
</div>
<h4 class="pHeading3"><a name="wp1017898"> </a>
Description
</h4>
<p class="pBody"><a name="wp1077176"> </a>
This method locates the Oracle Tuxedo FactoryFinder object and registers an Oracle Tuxedo factory. Typically, <code class="cCode">TP::register_factory()</code> is invoked from <code class="cCode">Server::initialize()</code> when the server creates its factories. The<code class="cCode"> register_factory()</code> method locates the Oracle Tuxedo FactoryFinder object and registers the Oracle Tuxedo factory. 
</p>
<a name="wp1077183"> </a>
<table class="Note">
<tr>
<td valign="top"><strong>Caution:</strong></td>
<td>Callback objects (that is, those created by a joint client/server directly through the POA) should not be registered with a FactoryFinder.</td>
</tr>
</table>
<h4 class="pHeading3"><a name="wp1121249"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1121250"> </a>
None.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1017919"> </a>
TP::unregister_factory()
</h3>
<h4 class="pHeading3"><a name="wp1017920"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1017927"> </a>
Locates the Oracle Tuxedo FactoryFinder object and removes a factory. 
</p>
<h4 class="pHeading3"><a name="wp1017928"> </a>
C++ Binding
</h4>
<a name="wp1017929"> </a><div class="pPreformatted"><pre>static void <code style="font-weight: normal" class="cCode">TP::unregister_factory</code><span style="font-weight: bold"> </span>(<br />               CORBA::Object_ptr factory_or, const char* factory_id);</pre></div><h4 class="pHeading3"><a name="wp1017930"> </a>
Arguments
</h4>
<h4 class="pDefTerm"><a name="wp1017931"> </a>
<code class="cCode">factory_or</code>
</h4><div class="pDefPara"><a name="wp1017932"> </a>
Specifies the object reference that was created for an application factory using the <code class="cCode">TP::create_object_reference()</code> method. 
</div>
<h4 class="pDefTerm"><a name="wp1017933"> </a>
<code class="cCode">factory_id</code>
</h4><div class="pDefPara"><a name="wp1121911"> </a>
Specifies a string identifier that is used to identify the application factory. For some suggestions as to the composition of this string, see <a href="../cservers/index.html">Creating CORBA Server Applications</a>.
</div>
<h4 class="pHeading3"><a name="wp1122032"> </a>
Exceptions
</h4>
<p class="pBody"><a name="wp1122033"> </a>
The following exceptions can be raised by the <code class="cCode">unregister_factory()</code> method:
</p>
<h4 class="pDefTerm"><a name="wp1122034"> </a>
<code class="cCode">CannotProceed</code>
</h4><div class="pDefPara"><a name="wp1122035"> </a>
Indicates that the FactoryFinder encountered an internal error during the search, with the error being written to the user log (<code class="cCode">ULOG</code>). Notify the operations staff immediately if this exception is raised. Depending on the severity of the internal error, the server running the FactoryFinder or the NameManager may have terminated. If a FactoryFinder service has terminated, start a new FactoryFinder service. If the NameManager has terminated, and there is another NameManager running, start a new one. If no NameManagers are running, restart the application.
</div>
<h4 class="pDefTerm"><a name="wp1122036"> </a>
<code class="cCode">InvalidName</code>
</h4><div class="pDefPara"><a name="wp1122037"> </a>
Indicates that the <code class="cCode">id</code> string is empty. It is also raised if the field contains blank spaces or control characters.
</div>
<h4 class="pDefTerm"><a name="wp1122038"> </a>
<code class="cCode">RegistrarNotAvailable</code>
</h4><div class="pDefPara"><a name="wp1122039"> </a>
Indicates that the FactoryFinder object cannot locate the NameManager. Notify the operations staff immediately if this exception is raised. If no naming services servers are running, restart the application.
<a name="wp1122040"> </a><table class="ListNote">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Another possible reason that this exception might occur is that the FactoryFinder cannot participate in a transaction. Therefore, you may need to suspend the current transaction before issuing the <code class="cCode">TP::register_factory()</code> and <code class="cCode">TP::unregister_factory()</code> calls. For information on suspending and resuming transactions, see <a href="../trans/index.html">Using CORBA Transactions</a> in the online documentation.</td>
</tr>
</table>

</div>
<h4 class="pDefTerm"><a name="wp1122046"> </a>
<code class="cCode">TobjS::OverFlow</code>
</h4><div class="pDefParaCont"><a name="wp1122030"> </a>
Indicates that the <code class="cCode">id</code> string is longer than 128 bytes (currently the maximum allowable length). 
</div>
<h4 class="pHeading3"><a name="wp1121917"> </a>
Description
</h4>
<p class="pBody"><a name="wp1121921"> </a>
This method locates the Oracle Tuxedo FactoryFinder object and removes a factory. Typically <code class="cCode">TP::unregister_factory()</code> is invoked from <code class="cCode">Server::release()</code> to unregister server factories.
</p>
<h4 class="pHeading3"><a name="wp1121746"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1121747"> </a>
None.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h3 class="pRefObject"><a name="wp1017958"> </a>
TP::userlog()
</h3>
<h4 class="pHeading3"><a name="wp1017959"> </a>
Synopsis
</h4>
<p class="pBody"><a name="wp1017960"> </a>
Writes a message to the user log (<code class="cCode">ULOG)</code> file. 
</p>
<h4 class="pHeading3"><a name="wp1017961"> </a>
C++ Binding
</h4>
<a name="wp1017962"> </a><div class="pPreformatted"><pre><code class="cCode">static int    TP::userlog(char*, ...);</code></pre></div><h4 class="pHeading3"><a name="wp1017963"> </a>
Arguments
</h4>
<p class="pBody"><a name="wp1017964"> </a>
The first argument is a <code class="cCode">printf(3S)</code> style format specification. The <code class="cCode">printf(3S)</code> argument is described in a C or C++ reference manual.
</p>
<h4 class="pHeading3"><a name="wp1122106"> </a>
Exceptions
</h4>
<p class="pBody"><a name="wp1122107"> </a>
None. 
</p>
<h4 class="pHeading3"><a name="wp1017967"> </a>
Description
</h4>
<p class="pBody"><a name="wp1017968"> </a>
The <code class="cCode">userlog()</code> method writes a message to the user log (<code class="cCode">ULOG)</code> file. Messages are appended to the <code class="cCode">ULOG</code> file with a tag made up of the time (hhmmss), system name, process name, and process-id of the invoking process. The tag is terminated with a colon. 
</p>
<p class="pBody"><a name="wp1017969"> </a>
We recommend that server applications limit their use of<code class="cCode"> userlog()</code> messages to messages that can be used to help debug application errors; flooding the <code class="cCode">ULOG</code> file with incidental information can make it difficult to spot actual errors.
</p>
<h4 class="pHeading3"><a name="wp1122095"> </a>
Return Value
</h4>
<p class="pBody"><a name="wp1122096"> </a>
The <code class="cCode">userlog()</code> method returns the number of characters that were output, or a negative value if an output error was encountered. Output errors include the inability to open or write to the current log file.
</p>
<h4 class="pHeading3"><a name="wp1017972"> </a>
Example
</h4>
<p class="pBody"><a name="wp1017973"> </a>
The following example shows how to use the <code class="cCode">TP::userlog()</code> method:
</p>
<p class="pBody"><a name="wp1017974"> </a>
<code class="cCode">userlog (&#8220;System exception caught: %s&#8221;, e.get_id());</code>
</p>
<h3 class="pHeading2"><a name="wp1017976"> </a>
CosTransactions::TransactionalObject Interface Not Enforced
</h3>
<p class="pBody"><a name="wp1017978"> </a>
Use of this interface is now deprecated. Therefore, the use of this interface is now optional and no enforcement of descent from this interface is done for objects infected with transactions. The programmer can specify that an object is not to be infected by transactions by specifying the <code class="cCode">never</code> or <code class="cCode">ignore</code> transaction policies. There is no interface enforcement for eligibility for transactions. The only indicator is the transaction policy.
</p>
<a name="wp1017979"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The CORBAservices Object Transaction Service does not require that all requests be performed within the scope of a transaction. It is up to each object to determine its behavior when invoked outside the scope of a transaction; an object that requires a transaction context can raise a standard exception.</td>
</tr>
</table>

<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1019900"> </a>
Error Conditions, Exceptions, and Error Messages
</h2><h3 class="pHeading2"><a name="wp1019902"> </a>
Exceptions Raised by the TP Framework
</h3>
<p class="pBody"><a name="wp1019903"> </a>
The following exceptions are raised by the TP Framework and are returned to clients when error conditions occur in, or are detected by, the TP Framework:
</p>
<a name="wp1019905"> </a><div class="pPreformatted"><pre><code class="cCode">CORBA::INTERNAL<br />CORBA::OBJECT_NOT_EXIST<br />CORBA::OBJ_ADAPTER<br />CORBA::INVALID_TRANSACTION<br />CORBA::TRANSACTION_ROLLEDBACK</code></pre></div><p class="pBody"><a name="wp1019910"> </a>
Since the reason for these exceptions may be ambiguous, each time one of these exceptions is raised, the TP Framework also writes a descriptive error message that explains the reason to the user log file.
</p>
<h3 class="pHeading2"><a name="wp1019913"> </a>
Exceptions in the Server Application Code
</h3>
<p class="pBody"><a name="wp1019914"> </a>
Exceptions raised within a method invoked by a client are always raised back to the client exactly as they were raised in the method invoked by the client.
</p>
<p class="pBody"><a name="wp1019916"> </a>
The following TP Framework callback methods are initiated by events other than client requests on the object:
</p>
<a name="wp1019918"> </a><div class="pPreformatted"><pre><code class="cCode">Tobj_ServantBase::activate_object()<br />Tobj_ServantBase::deactivate_object()<br />Server::create_servant()</code></pre></div><p class="pBody"><a name="wp1019921"> </a>
If exception conditions are raised in these methods, those exact exceptions are not reported back to the client. However, each of these methods is defined to raise an exception that includes a reason string. The TP Framework will catch the exception raised by the callback and log the reason string to the user log file. The TP Framework may raise an exception back to the client. Refer to the descriptions of the individual TP Framework callback methods for more information about these exceptions.
</p>
<h4 class="pHeading3"><a name="wp1019927"> </a>
Example
</h4>
<p class="pBody"><a name="wp1019928"> </a>
For <code class="cCode">Tobj_ServantBase::deactivate_object()</code>, the following line of code throws a <code class="cCode">DeactivateObjectFailed</code> exception:
</p>
<a name="wp1019930"> </a><div class="pPreformatted"><pre><code class="cCode">throw TobjS::DeactivateObjectFailed( &#8220;deactivate failed to save<br />                                       state!&#8221;);</code></pre></div><p class="pBody"><a name="wp1019931"> </a>
This message is appended to the user log file with a tag made up of the time (hhmmss), system name, process name, and process-id of the calling process. The tag is terminated with a colon. The preceding throw statement causes the following line to appear in the user log file:
</p>
<p class="pBody"><a name="wp1019934"> </a>
<code class="cCode">151104.T1!simpapps.247: APPEXC: deactivate failed to save state!</code>
</p>
<p class="pBody"><a name="wp1019935"> </a>
Where <code class="cCode">151104</code> is the time (3:11:04pm), <code class="cCode">T1</code> is the system name, <code class="cCode">simpapps</code> is the process name, <code class="cCode">247</code> is the process-id, and <code class="cCode">APPEXC</code> identifies the message as an application exception message.
</p>
<h3 class="pHeading2"><a name="wp1018026"> </a>
Exceptions and Transactions
</h3>
<p class="pBody"><a name="wp1020072"> </a>
Exceptions that are raised in either CORBA object methods or in TP Framework callback methods will not automatically cause a transaction to be rolled back unless the TP Framework started the transaction. It is up to the application code to call <code class="cCode">Current.rollback_only()</code> if the condition that caused the exception to be raised should also cause the transaction to be rolled back.
</p>
<h3 class="pHeading2"><a name="wp1020077"> </a>
Restriction of Nested Calls on CORBA Objects
</h3>
<p class="pBody"><a name="wp1020078"> </a>
The TP Framework restricts nested calls on CORBA objects. The restriction is as follows:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1020080"> </a>During a client invocation of a method of CORBA object A, CORBA object A cannot be invoked by another CORBA object B that is acting as a client of CORBA object A.</li>
</ul></div>
<p class="pBody"><a name="wp1020082"> </a>
The TP Framework will detect the fact that a second CORBA object is acting as a client to an object that is already processing a method invocation, and will return a <code class="cCode">CORBA::OBJ_ADAPTER </code>exception to the caller.
</p>
<a name="wp1020149"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Application code should not depend on this behavior; that is, users should not make any processing dependent on this behavior. This restriction may be lifted in a future release.</td>
</tr>
</table>


<p class="troubleshoot">
<a href="#wp1053781" title="Footnote 1"><sup class="Footnote">1</sup></a>In theory, this would mean that an invocation on a transactional CORBA object in the same process would be valid since it would not require a new process to be registered with the transaction manager. However, it is not possible for the programmer to guarantee that an invocation on a CORBA object will occur in-proc, therefore, this practice is discouraged.
</p>
 
<br/>
    <table id="SummaryNotReq2" width="100%" border="0" cellpadding="0" cellspacing="0">
      <tr> 
        <td>
&nbsp;
<a href="tpfw.html"><img id="LongDescNotReq7" src="/global_resources/images/backtop.gif" width="90" height="25" alt="Back to Top" title="Back to Top" border="0" /></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a accesskey="4" href="imp_cnfg.html"><img id="LongDescNotReq8" src="/global_resources/images/prevtop.gif" border="0" alt="Previous" /></a>&nbsp;
<a accesskey="5" href="boot.html"><img id="LongDescNotReq9" src="/global_resources/images/nexttop.gif" border="0" alt="Next" /></a>
<script language="Javascript1.1" type="text/javascript">
Copyright();
</script>
<noscript><a href="http://edocs.bea.com/copyright.html">&copy; BEA Systems</a></noscript>
        </td>
      </tr>
    </table>

<!-- WebAnalytics BEGIN -->

<!--#include virtual="/global_resources/edocs_wt.html"-->
      
<!-- WebAnalytics END -->

  </body>
</html>
