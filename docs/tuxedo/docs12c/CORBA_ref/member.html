<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>

<!-- LOCALIZATION RELATED INFORMATION -->
<meta name="LOC_PROJ_ID" content="WLPF8.1" />
<meta name="LOC_OWNER" content="BEAJ" />
<meta name="LOC_STATUS" content="READY!" />
<meta name="LOC_COMMENT" content="LOC_COMMENT" />
<meta name="LOC_US_REV" content="2" />
<meta name="LOC_US_CHANGE" content="41908" />
<meta name="LOC_US_SRCFILE" content="//depot/tuxedo/tux12c/CORBA_ref/fm/member.fm" />
<!-- LOCALIZATION RELATED INFORMATION -->

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="GENERATOR" content="Quadralay WebWorks AutoMap 2003 Platinum Edition for FrameMaker 8.6.6577.0" />
    <meta name="TEMPLATEBASE" content="BEA_WFP_Template_V1.04" />
    <meta name="LASTUPDATED" content="06/26/12 11:01:23" />
    <link rel="StyleSheet" href="/global_resources/edocs.css" type="text/css" media="all" />

<title>Mapping of OMG IDL Statements to C++</title>

<!-- BEA scripts begin -->

<script language="Javascript" src="/global_resources/js/banner.js" type="text/javascript"></script>
<!-- This script outputs the banner required for edocs documentation. -->

<script language="Javascript" src="floatwin.js" type="text/javascript"></script>
<!-- This script opens a new small floating window and puts TOC<i>&lt;name&gt;</i>.html and IX<i>&lt;name&gt;</i>.html files in it and sets a generic popup window code to enable the display of some viewlets in the WebLogic Platform Tour. -->

<script language="Javascript1.1" src="/global_resources/js/footer.js" type="text/javascript"></script>
<!-- This script outputs the footer with the correct copyright date and link to copyright page.-->

<script language="Javascript1.1" src="/global_resources/js/googlesearch4.js" type="text/javascript"></script>
<!-- This script outputs the google search form. -->

<script language="Javascript1.1" src="/global_resources/js/note.js" type="text/javascript"></script>
<!-- This script outputs a note such as a BETA note. -->

<script language="JavaScript1.1" src="/global_resources/js/search.js" type="text/javascript"></script>
<!-- This script is not for online documents. It is only used by the QuestAgent Java Applet for CD search indexes. -->

<!-- BEA scripts end -->

  </head>

  <body>


<script language="Javascript1.1" type="text/javascript">
GoogleURL();
</script><noscript>This script outputs the google search URL required for search on edocs documentation.</noscript>

<script language="Javascript1.1" type="text/javascript">
Banner();
</script><noscript>This script outputs the banner required for edocs documentation.</noscript>

<script language="Javascript1.1" type="text/javascript">
GoogleSearchCollection();
</script><noscript>This script outputs the google search parameters required for search on edocs documentation.</noscript>

<!-- page title -->
<h1 class="booktitle">CORBA Programming Reference
</h1>
<!-- page title end -->

    <table id="SummaryNotReq1" width="100%" border="0" align="left" cellpadding="2%" cellspacing="0">
      <tr> 
        <td>
&nbsp;&nbsp;&nbsp;&nbsp;
<a accesskey="4" href="command.html"><img id="LongDescNotReq1" src="/global_resources/images/doc_nav_prev.gif" border="0" alt="Previous" /></a>&nbsp;
<a accesskey="5" href="corba_api.html"><img id="LongDescNotReq2" src="/global_resources/images/doc_nav_next.gif" border="0" alt="Next" /></a>&nbsp;
<img id="LongDescNotReq3" src="/global_resources/images/doc_nav_dots.gif" border="0" alt="" />&nbsp;
<a accesskey="1" href="javascript:OpenWindowToc();" onmouseover="window.status='Table of Contents'; return true" onfocus="window.status='Table of Contents'; return true" onmouseout="window.status=''; return true" onblur="window.status=''; return true" title="Open TOC in new window">      <img id="LongDescNotReq4" src="/global_resources/images/doc_nav_contents.gif" alt="Open TOC in new window" border="0" /></a>&nbsp;
<a accesskey="2" href="javascript:OpenWindowIndex();" onmouseover="window.status='Index'; return true" onfocus="window.status='Index'; return true" onmouseout="window.status=''; return true" onblur="window.status=''; return true" title="Open Index in new window">     <img id="LongDescNotReq5" src="/global_resources//images/doc_nav_index.gif" border="0" alt="Open Index in new window" /></a>&nbsp;
<a href="../pdf/CORBA_ref.pdf" target="pdf"><img id="LongDescNotReq6" src="/global_resources/images/doc_nav_pdf.gif" width="59" height="44" alt="View as PDF - New Window" title="View as PDF - New Window" border="0" /></a>&nbsp;
<a href="http://www.adobe.com/products/acrobat/alternate.html" target="_blank"><img id="LongDescNotReq7" src="/global_resources/images/get_reader.gif" width="52" height="44" alt="Get Adobe Reader - New Window" title="Get Adobe Reader - New Window" border="0" /></a>
<a name="link_group_0"></a>
	</td>
      </tr>
    </table>

<a name="skipnav" title="Content starts here"><img src="/global_resources/images/_.gif" alt="Content starts here" border="0" height="1" width="1" /></a>



<h1 class="pChapHead"><a name="wp1174555"> </a>
Mapping of OMG IDL Statements to C++
</h1>
<p class="pBody"><a name="wp1119401"> </a>
This chapter discusses the mappings from OMG IDL statements to C++.
</p>
<a name="wp1136327"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td> Some of the information in this chapter is taken from the <span style="font-style: italic">Common Object Request Broker: C++ Language Mapping Specification,</span> June 1999, published by the Object Management Group (OMG). Used with permission of the OMG.</td>
</tr>
</table>

<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1122118"> </a>
Mappings
</h2><p class="pBody"><a name="wp1121847"> </a>
OMG IDL-to-C++ mappings are described for the following:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1121852"> </a><a href="member.html#wp1120423">Data Types</a></li>
<li><a name="wp1121857"> </a><a href="member.html#wp1081856">Strings</a></li>
<li><a name="wp1121862"> </a><a href="member.html#wp1158845">wchars</a></li>
<li><a name="wp1140533"> </a><a href="member.html#wp1160531">wstrings</a></li>
<li><a name="wp1145460"> </a><a href="member.html#wp1120905">Constants</a></li>
<li><a name="wp1145465"> </a><a href="member.html#wp1121608">Enums</a></li>
<li><a name="wp1145293"> </a><a href="member.html#wp1121618">Structs</a> </li>
<li><a name="wp1145295"> </a><a href="member.html#wp1121651">Unions</a></li>
<li><a name="wp1145446"> </a><a href="member.html#wp1121083">Sequences</a></li>
<li><a name="wp1140538"> </a><a href="member.html#wp1121164">Arrays</a></li>
<li><a name="wp1145294"> </a><a href="member.html#wp1121196">Exceptions</a></li>
<li><a name="wp1140543"> </a><a href="member.html#wp1148653">Mapping of Pseudo-objects to C++</a></li>
<li><a name="wp1121885"> </a><a href="member.html#wp1148057">Usage</a></li>
<li><a name="wp1121886"> </a><a href="member.html#wp1149078">Mapping Rules</a></li>
<li><a name="wp1121887"> </a><a href="member.html#wp1146619">Relation to the C PIDL Mapping</a></li>
<li><a name="wp1164701"> </a><a href="member.html#wp1121238">Typedefs</a></li>
<li><a name="wp1145470"> </a><a href="member.html#wp1147535">Implementing Interfaces</a></li>
<li><a name="wp1121947"> </a><a href="member.html#wp1146213">Implementing Operations</a></li>
<li><a name="wp1128559"> </a><a href="member.html#wp1147205">PortableServer Functions</a></li>
<li><a name="wp1162183"> </a><a href="member.html#wp1141571">Modules</a></li>
<li><a name="wp1162304"> </a><a href="member.html#wp1141585">Interfaces</a></li>
<li><a name="wp1162332"> </a><a href="member.html#wp1141602">Generated Static Member Functions</a></li>
<li><a name="wp1162353"> </a><a href="member.html#wp1141611">Object Reference Types</a></li>
<li><a name="wp1164715"> </a><a href="member.html#wp1170578">Attributes</a></li>
<li><a name="wp1164719"> </a><a href="member.html#wp1127028">Any Type</a></li>
<li><a name="wp1164730"> </a><a href="member.html#wp1165186">Value Type</a></li>
</ul></div>
<p class="pBody"><a name="wp1165799"> </a>
In addition, the following topics are discussed:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1165341"> </a><a href="member.html#wp1128492">Fixed-length Versus Variable-length User-defined Types</a></li>
<li><a name="wp1165453"> </a><a href="member.html#wp1009915">Using var Classes</a></li>
<li><a name="wp1165461"> </a><a href="member.html#wp1132019">Using out Classes</a></li>
<li><a name="wp1165469"> </a><a href="member.html#wp1125564">Argument Passing Considerations</a></li>
</ul></div>
<h3 class="pHeading2"><a name="wp1120423"> </a>
Data Types
</h3>
<p class="pBody"><a name="wp1120424"> </a>
Each OMG IDL data type is mapped to a C++ data type or class.
</p>
<h4 class="pHeading3"><a name="wp1120425"> </a>
Basic Data Types
</h4>
<p class="pBody"><a name="wp1120426"> </a>
The basic data types in OMG IDL statements are mapped to C++ typedefs in the CORBA module, as shown in <a href="member.html#wp1154188">Table&#160;13-1</a>.
</p>
<p class="pGraphic"><a name="wp1154169"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1154188table1154186"><caption><a name="wp1154188"> </a>
Table 13-1  Basic OMG IDL and C++ Data Types&#160;

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1154225"> </a>
OMG IDL
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1154227"> </a>
C++
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1154229"> </a>
C++ Out Type
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154231"> </a>
<code class="cCode">short</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154233"> </a>
<code class="cCode">CORBA::Short</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154235"> </a>
<code class="cCode">CORBA::Short_out</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154237"> </a>
<code class="cCode">long</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154239"> </a>
<code class="cCode">CORBA::Long</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154241"> </a>
<code class="cCode">CORBA::Long_out</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154243"> </a>
<code class="cCode">unsigned short</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154245"> </a>
<code class="cCode">CORBA::UShort</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154247"> </a>
<code class="cCode">CORBA::UShort_out</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154249"> </a>
<code class="cCode">unsigned long</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154251"> </a>
<code class="cCode">CORBA::ULong</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154253"> </a>
<code class="cCode">CORBA::ULong_out</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154255"> </a>
<code class="cCode">float</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154257"> </a>
<code class="cCode">CORBA::Float</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154259"> </a>
<code class="cCode">CORBA::Float_out</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154261"> </a>
<code class="cCode">double</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154263"> </a>
<code class="cCode">CORBA::Double</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154265"> </a>
<code class="cCode">CORBA::Double_out</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154267"> </a>
<code class="cCode">char</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154269"> </a>
<code class="cCode">CORBA::Char</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154271"> </a>
<code class="cCode">CORBA::Char_out</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154273"> </a>
<code class="cCode">boolean</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154275"> </a>
<code class="cCode">CORBA::Boolean</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154277"> </a>
<code class="cCode">CORBA::Boolean_out</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154279"> </a>
<code class="cCode">octet</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154281"> </a>
<code class="cCode">CORBA::Octet</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154283"> </a>
<code class="cCode">CORBA::Octet_out</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167765"> </a>
wchar
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167767"> </a>
CORBA::WChar
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167769"> </a>
CORBA::WChart_out
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<a name="wp1120477"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>On a 64-bit machine where a long integer is 64 bits, the definition of <code class="cCode">CORBA::Long</code> would still refer to a 32-bit integer.</td>
</tr>
</table>

<h4 class="pHeading3"><a name="wp1126855"> </a>
Complex Data Types
</h4>
<p class="pBody"><a name="wp1120481"> </a>
Object, pseudo-object, and user-defined types are mapped as shown in <a href="member.html#wp1154490">Table&#160;13-2</a>.
</p>
<p class="pGraphic"><a name="wp1154391"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1154490table1154430"><caption><a name="wp1154490"> </a>
Table 13-2  <span style="font-style: normal; font-weight: bold; text-decoration: none; vertical-align: baseline">Object, Pseudo-object, and User-defined OMG IDL and C++ Types</span>

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1154506"> </a>
OMG IDL
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1154508"> </a>
C++
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154510"> </a>
<code class="cCode">Object</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154512"> </a>
<code class="cCode">CORBA::Object_ptr</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154514"> </a>
<code class="cCode">struct</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154516"> </a>
<code class="cCode">C++ struct</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154518"> </a>
<code class="cCode">union</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154520"> </a>
<code class="cCode">C++ class</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154522"> </a>
<code class="cCode">enum</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154524"> </a>
<code class="cCode">C++ enum</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154526"> </a>
<code class="cCode">string</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154528"> </a>
<code class="cCode">char *</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1158839"> </a>
wstring
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1158841"> </a>
CORBA::WChar *
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154530"> </a>
<code class="cCode">sequence</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154532"> </a>
<code class="cCode">C++ class</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154534"> </a>
<code class="cCode">array</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154536"> </a>
<code class="cCode">C++ array</code>
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<p class="pBody"><a name="wp1120524"> </a>
The mapping for strings and UDTs is described in more detail in the following sections.
</p>
<h3 class="pHeading2"><a name="wp1081856"> </a>
Strings
</h3>
<p class="pBody"><a name="wp1009629"> </a>
A string in OMG IDL is mapped to<code class="cCode"> char * </code>in C++. Both bounded and unbounded strings are mapped to<code class="cCode"> char *</code>. CORBA strings in C++ are NULL-terminated and can be used wherever a char * type is used.
</p>
<p class="pBody"><a name="wp1009630"> </a>
If a string is contained within another user-defined type, such as a<code class="cCode"> struct</code>, it is mapped to a<code class="cCode"> CORBA::String_var </code>type. This ensures that each member in the struct manages its own memory.
</p>
<p class="pBody"><a name="wp1009631"> </a>
Strings must be allocated and deallocated using the following member functions in the CORBA class:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1009632"> </a><code class="cCode">string_alloc</code></li>
<li><a name="wp1085904"> </a>string_dup</li>
<li><a name="wp1009633"> </a><code class="cCode">string_free</code></li>
</ul></div>
<a name="wp1009636"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The <code class="cCode">string_alloc</code> function allocates <code class="cCode">len+1</code> characters so that the resulting string has enough space to hold a trailing NULL character.</td>
</tr>
</table>

<h3 class="pHeading2"><a name="wp1158845"> </a>
wchars
</h3>
<p class="pBody"><a name="wp1160529"> </a>
OMG IDL defines a <code class="cCode">wchar</code> data type that encodes wide characters from any character set. As with character data, an implementation is free to use any code set internally for encoding wide characters, though, again, conversion to another form may be required for transmission. The size of <code class="cCode">wchar</code> is implementation-dependent.
</p>
<p class="pBody"><a name="wp1161463"> </a>
The syntax for defining a <code class="cCode">wchar</code> is:
</p>
<a name="wp1161464"> </a><div class="pPreformattedRelative"><pre><code class="cCode">&lt;wide_char_type&gt; ::= &#8220;wchar&#8221;</code></pre></div><p class="pBody"><a name="wp1168245"> </a>
A code example for <code class="cCode">wchar</code> is:
</p>
<a name="wp1168246"> </a><div class="pPreformattedRelative"><pre><code class="cCode">wchar_t wmixed[256];</code></pre></div><a name="wp1161465"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The <code class="cCode">wchar</code> and <code class="cCode">wstring</code> data types enable users to interact with computers in their native written language. Some languages, such as Japanese and Chinese, have thousands of unique characters. These character sets do not fit within a byte. A number of schemes have been used to support multi-byte character sets, but they have proved to be unwieldy to use. Wide characters and wide strings make it easier to interact with this kind of complexity.</td>
</tr>
</table>

<h3 class="pHeading2"><a name="wp1160531"> </a>
wstrings
</h3>
<p class="pBody"><a name="wp1160532"> </a>
The <code class="cCode">wstring</code> data type represents a sequence of <code class="cCode">wchar</code>, except the wide character NULL. The type <code class="cCode">wstring</code> is similar to that of type string, except that its element type is <code class="cCode">wchar</code> instead of <code class="cCode">char</code>. The actual length of a <code class="cCode">wstring</code> is set at run time and, if the bounded form is used, must be less than or equal to the bound.
</p>
<p class="pBody"><a name="wp1159003"> </a>
The syntax for defining a <code class="cCode">wstring</code> is:
</p>
<a name="wp1158974"> </a><div class="pPreformattedRelative"><pre><code class="cCode">&lt;wide_string_type&gt; ::= &#8220;wstring&#8221; &#8220;&lt;&#8221; &lt;positive_int_const&gt; &#8220;&gt;&#8221;<br />                     | &#8220;wstring</code></pre></div><p class="pBody"><a name="wp1168347"> </a>
A code example for <code class="cCode">wstring</code> is:
</p>
<a name="wp1168348"> </a><div class="pPreformattedRelative"><pre><code class="cCode">CORBA::WString_var v_upper = CORBA::wstring_dup(wmixed);</code></pre></div><p class="pBody"><a name="wp1168251"> </a>
<code class="cCode">wstring</code> types are built in types just like unsigned long, char, string, double, etc. They can be used directly as parameters, typedef&#39;d, used to construct structs, sequences, unions, arrays, and so forth.
</p>
<a name="wp1160948"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The <code class="cCode">wchar</code> and <code class="cCode">wstring</code> data types enable users to interact with computers in their native written language. Some languages, such as Japanese and Chinese, have thousands of unique characters. These character sets do not fit within a byte. A number of schemes have been used to support multi-byte character sets, but they have proved to be unwieldy to use. Wide characters and wide strings make it easier to interact with this kind of complexity.</td>
</tr>
</table>

<h3 class="pHeading2"><a name="wp1120905"> </a>
Constants
</h3>
<p class="pBody"><a name="wp1120906"> </a>
A constant in OMG IDL is mapped to a C++ <code class="cCode">const</code> definition. For example, consider the following OMG IDL definition:
</p>
<a name="wp1120907"> </a><div class="pPreformatted"><pre>    // OMG IDL</pre></div><a name="wp1120908"> </a><div class="pPreformatted"><pre>    const string CompanyName = &#8220;BEA Systems Incorporated&#8221;;</pre></div><a name="wp1120909"> </a><div class="pPreformatted"><pre>    module INVENT<br />       {<br />        const string Name = &#8220;Inventory Modules&#8221;;</pre></div><a name="wp1120910"> </a><div class="pPreformatted"><pre>        interface Order<br />            {<br />            const long MAX_ORDER_NUM = 10000;<br />            };<br />        };</pre></div><p class="pBody"><a name="wp1120911"> </a>
This definition maps to C++ as follows:
</p>
<a name="wp1120912"> </a><div class="pPreformatted"><pre>    // C++</pre></div><a name="wp1120913"> </a><div class="pPreformatted"><pre>    const  char *const  <br />       CompanyName  = &#8220;BEA Systems Incorporated&#8221;;<br />    . . .<br />    class INVENT<br />        {<br />        static const  char *const  Name;<br />        . . .</pre></div><a name="wp1120914"> </a><div class="pPreformatted"><pre>        class Order : public virtual CORBA::Object<br />            {<br />            static const CORBA::Long MAX_ORDER_NUM;<br />            . . .<br />            };<br />         };</pre></div><p class="pBody"><a name="wp1120915"> </a>
Top-level constants are initialized in the generated<code class="cCode"> .h </code>include file, but module and interface constants are initialized in the generated client stub modules.
</p>
<p class="pBody"><a name="wp1120916"> </a>
The following is an example of a valid reference to the<code class="cCode"> MAX_ORDER_NUM </code>constant, as defined in the previous example:
</p>
<a name="wp1120917"> </a><div class="pPreformatted"><pre>CORBA::Long accnt_id = INVENT::Order::MAX_ORDER_NUM;</pre></div><h3 class="pHeading2"><a name="wp1121608"> </a>
Enums
</h3>
<p class="pBody"><a name="wp1121609"> </a>
An enum in OMG IDL is mapped to an enum in C++. For example, consider the following OMG IDL definition:
</p>
<a name="wp1121610"> </a><div class="pPreformatted"><pre>    // OMG IDL</pre></div><a name="wp1121611"> </a><div class="pPreformatted"><pre>    module INVENT<br />        {<br />        enum Reply {ACCEPT, REFUSE};<br />         }</pre></div><p class="pBody"><a name="wp1121612"> </a>
This definition maps to C++ as follows:
</p>
<a name="wp1121613"> </a><div class="pPreformatted"><pre>    // C++</pre></div><a name="wp1121614"> </a><div class="pPreformatted"><pre>    class INVENT<br />       {<br />       . . .</pre></div><a name="wp1121615"> </a><div class="pPreformatted"><pre>        enum  Reply {ACCEPT, REFUSE};<br />        };</pre></div><p class="pBody"><a name="wp1121616"> </a>
The following is an example of a valid reference to the enum defined in the previous example. You refer to enum as follows:
</p>
<a name="wp1149750"> </a><div class="pPreformatted"><pre>    INVENT::Reply accept_reply;<br />    accept_reply = INVENT::ACCEPT;</pre></div><h3 class="pHeading2"><a name="wp1121618"> </a>
Structs
</h3>
<p class="pBody"><a name="wp1121619"> </a>
A struct in OMG IDL is mapped to a C++ struct.
</p>
<p class="pBody"><a name="wp1121620"> </a>
The generated code for a struct depends upon whether it is fixed-length or variable-length. For more information about fixed-length versus variable-length types, see the section <a href="member.html#wp1128492">Fixed-length Versus Variable-length User-defined Types</a>.
</p>
<h4 class="pHeading3"><a name="wp1121624"> </a>
Fixed-length Versus Variable-length Structs
</h4>
<p class="pBody"><a name="wp1121625"> </a>
A variable-length struct contains an additional assignment operator member function to handle assignments between two variable-length structs.
</p>
<p class="pBody"><a name="wp1121626"> </a>
For example, consider the following OMG IDL definition:
</p>
<a name="wp1121627"> </a><div class="pPreformatted"><pre>    // OMG IDL</pre></div><a name="wp1121628"> </a><div class="pPreformatted"><pre>    module INVENT<br />       {<br />        // Fixed-length<br />        struct Date<br />            {<br />            long year;<br />            long month;<br />            long day;<br />            };<br /><br />        // Variable-length<br />        struct Address<br />            {<br />            string  aptNum;<br />            string  streetName;<br />            string  city;<br />            string  state;<br />            string  zipCode;<br />          };<br />         };</pre></div><p class="pBody"><a name="wp1121630"> </a>
This definition maps to C++ as follows:
</p>
<a name="wp1121631"> </a><div class="pPreformatted"><pre>    // C++</pre></div><a name="wp1121632"> </a><div class="pPreformatted"><pre>    class INVENT<br />         {<br />         struct  Date<br />            {<br />            CORBA::Long year;<br />            CORBA::Long month;<br />            CORBA::Long day;<br />             };</pre></div><a name="wp1121633"> </a><div class="pPreformatted"><pre>         struct  Address<br />            {<br />             CORBA::String_var aptNum;<br />             CORBA::String_var streetName;<br />             CORBA::String_var city;<br />             CORBA::String_var state;<br />             CORBA::String_var zipCode;<br />             Address &amp;operator=(const Address &amp;_obj);<br />             };<br /><br />          };</pre></div><h4 class="pHeading3"><a name="wp1121637"> </a>
Member Mapping
</h4>
<p class="pBody"><a name="wp1121638"> </a>
Members of a struct are mapped to the appropriate C++ data type. For basic data types (long, short, and so on), see <a href="member.html#wp1154188">Table&#160;13-1</a>. For object references, pseudo-object references, and strings, the member is mapped to the appropriate var class:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1121642"> </a><code class="cCode">CORBA::String_var</code></li>
<li><a name="wp1121643"> </a><code class="cCode">CORBA::Object_var</code></li>
</ul></div>
<p class="pBody"><a name="wp1121647"> </a>
All other data types are mapped as shown in <a href="member.html#wp1154490">Table&#160;13-2</a>.
</p>
<p class="pBody"><a name="wp1121648"> </a>
No constructor for a generated struct exists, so none of the members are initialized. Fixed-length structs can be initialized using aggregate initialization. For example:
</p>
<a name="wp1121649"> </a><div class="pPreformatted"><pre>INVENT::Date a_date = { 1995, 10, 12 };</pre></div><p class="pBody"><a name="wp1121650"> </a>
Variable-length members map to self-managing types; these types have constructors that initialize the member.
</p>
<h4 class="pHeading3"><a name="wp1136727"> </a>
Var
</h4>
<p class="pBody"><a name="wp1136756"> </a>
A var class is generated for structs. For more information, see the section <a href="member.html#wp1009915">Using var Classes</a>.
</p>
<h4 class="pHeading3"><a name="wp1136925"> </a>
Out
</h4>
<p class="pBody"><a name="wp1136780"> </a>
An out class is generated for structs. For more information, see the section <a href="member.html#wp1132019">Using out Classes</a>.
</p>
<h3 class="pHeading2"><a name="wp1121651"> </a>
Unions
</h3>
<p class="pBody"><a name="wp1121652"> </a>
A union in OMG IDL is mapped to a C++ class. The C++ class contains the following:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1121653"> </a>Constructors</li>
<li><a name="wp1121654"> </a>Destructors</li>
<li><a name="wp1121655"> </a>Assignment operators</li>
<li><a name="wp1121656"> </a>Modifiers for the union value</li>
<li><a name="wp1121657"> </a>Accessors for the union value</li>
<li><a name="wp1121658"> </a>Modifiers and accessors for the union discriminator</li>
</ul></div>
<p class="pBody"><a name="wp1121659"> </a>
For example, consider the following OMG IDL definition:
</p>
<a name="wp1121660"> </a><div class="pPreformatted"><pre>    // OMG IDL</pre></div><a name="wp1121661"> </a><div class="pPreformatted"><pre>    union OrderItem switch (long)<br />        {<br />        case 1: itemStruct itemInfo;<br />        case 2: orderStruct orderInfo;<br />        default: ID idInfo;<br />        };</pre></div><p class="pBody"><a name="wp1121662"> </a>
This definition maps to C++ as follows:
</p>
<a name="wp1121663"> </a><div class="pPreformatted"><pre>    // C++</pre></div><a name="wp1121664"> </a><div class="pPreformatted"><pre>   class OrderItem<br />       {<br />        public:<br />           OrderItem();<br />           OrderItem(const OrderItem &amp;);<br />           ~OrderItem();<br /><br />            OrderItem &amp;operator=(const OrderItem&amp;);</pre></div><a name="wp1121666"> </a><div class="pPreformatted"><pre>           void  _d  (CORBA::Long);<br />           CORBA::Long  _d  () const;<br /><br />           void itemInfo (const itemStruct &amp;);<br />           const itemStruct &amp; itemInfo () const;<br />           itemStruct &amp; itemInfo ();<br /><br />           void orderInfo (const orderStruct &amp;);<br />           const orderStruct &amp; orderInfo () const;<br />           orderStruct &amp; orderInfo ();<br /><br />           void idInfo (ID);<br />           ID idInfo () const;<br /><br />           . . .<br />         };</pre></div><p class="pBody"><a name="wp1121671"> </a>
The default union constructor does not set a default discriminator value for the union; therefore, you cannot call any union accessor member function until you have set the value of the union. The discriminator is an attribute that is mapped through the <code class="cCode">_d</code> member function.
</p>
<h4 class="pHeading3"><a name="wp1121673"> </a>
Union Member Accessor and Modifier Member Function Mapping
</h4>
<p class="pBody"><a name="wp1121674"> </a>
For each member in the union, accessor and modifier member functions are generated.
</p>
<p class="pBody"><a name="wp1121675"> </a>
In the following code, taken from the previous example, two member functions are generated for the ID member function:
</p>
<a name="wp1121676"> </a><div class="pPreformatted"><pre>     void idInfo (ID);<br />     ID idInfo () const;</pre></div><p class="pBody"><a name="wp1121677"> </a>
In this example, the first function (the modifier) sets the discriminator to the default value and sets the value of the union to the specified ID value. The second function, the accessor, returns the value of the union.
</p>
<p class="pBody"><a name="wp1121678"> </a>
Depending upon the data type of the union member, additional modifier functions are generated. The member functions generated for each data type are as follows:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1121679"> </a>Basic data types&#8212;short, long, unsigned short, unsigned long, float, double, char, boolean, and octet<br /><br />The following example generates two member functions for a basic data type with member name <code class="cCode">basictype</code>:<br /><br /><code class="cCode">void basictype (</code><code class="cCodeEmphasis">TYPE</code><code class="cCode">);      // modifier<br /></code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> basictype () const;    // accessor<br /></code><br />For the mapping from an OMG IDL data type to the C++ data type <span style="font-style: normal">TYPE</span>, see <a href="member.html#wp1154188">Table&#160;13-1</a>.</li>
<li><a name="wp1121686"> </a>Object and pseudo-object<br /><br />For object and Typecode types with member name <code class="cCode">objtype</code>, member functions are generated as follows:<br /><br /><code style="font-style: normal" class="cCode">void objtype (</code><span style="font-style: normal">TYPE</span><code class="cCode">);     // modifier<br /></code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> objtype () const;     // accessor<br /></code><br />For the mapping from an OMG IDL data type to the C++ data type <span style="font-style: normal">TYPE</span>, see <a href="member.html#wp1154188">Table&#160;13-1</a>.<br /><br />The modifier member function does not assume ownership of the specified object reference argument. Instead, the modifier duplicates the object reference or pseudo-object reference. You are responsible for releasing the reference when it is no longer required.</li>
<li><a name="wp1121694"> </a>Enum<br /><br />For an enum <span style="font-style: normal">TYPE</span> with member name<code class="cCode"> enumtype</code>, member functions are generated as follows:<br /><br /><code class="cCode">void enumtype (</code><code class="cCodeEmphasis">TYPE</code><code class="cCode">);    // modifier    <br /></code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> enumtype () const;  // accessor</code></li>
<li><a name="wp1122479"> </a>String<br /><br />For strings, one accessor and three modifier functions are generated, as follows:<br /><br /><code class="cCode">void stringInfo (char *);                      // modifier 1    <br />void stringInfo (const char *);                // modifier 2    <br />void stringInfo (const CORBA::String_var &amp;);  // modifier 3    <br />const char * stringInfo () const;             // accessor<br /></code><br />The first modifier assumes ownership of the <code class="cCode">char *</code> parameter passed to it and the union is responsible for calling the<code class="cCode"> CORBA::string_free </code>member function on this string when the union value changes or when the union is destroyed.<br /><br />The second and third modifiers make a copy of the specified string passed in the parameter or contained in the string var.<br /><br />The accessor function returns a pointer to internal memory of the union; do not attempt to free this memory, and do not access this memory after the union value has been changed or the union has been destroyed.</li>
<li><a name="wp1121703"> </a>Struct, union, sequence, and any<br /><br />For these data types, modifier and accessor functions are generated with references to the <code class="cCode">type</code>, as follows:<br /><br /><code class="cCode">void reftype (</code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> &amp;);         // modifier    <br />const </code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> &amp; reftype () const; // accessor    <br /></code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> &amp; reftype ();             // accessor<br /></code><br />The modifier function does not assume ownership of the input<code class="cCode"> type</code> parameter; instead, the function makes a copy of the data type.</li>
<li><a name="wp1121707"> </a>Array<br /><br />For an array, the modifier member function accepts an array pointer while the accessor returns a pointer to an array slice, as follows:<br /><br /><code class="cCode">void arraytype (</code><code class="cCodeEmphasis">TYPE</code><code class="cCode">);            // modifier    <br /></code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_slice * arraytype () const;  // accessor<br /></code><br />The modifier function does not assume ownership of the input<code class="cCode"> </code>type<code class="cCode"> </code>parameter; instead, the function makes a copy of the array.</li>
</ul></div>
<h4 class="pHeading3"><a name="wp1121711"> </a>
Var
</h4>
<p class="pBody"><a name="wp1121715"> </a>
A var class is generated for a union. For more information, see the section <a href="member.html#wp1009915">Using var Classes</a> .
</p>
<h4 class="pHeading3"><a name="wp1137949"> </a>
Out
</h4>
<p class="pBody"><a name="wp1137953"> </a>
An out class is generated for a union. For more information, see the section  <a href="member.html#wp1132019">Using out Classes</a>.
</p>
<h4 class="pHeading3"><a name="wp1121716"> </a>
Member Functions
</h4>
<p class="pBody"><a name="wp1121717"> </a>
In addition to the accessor and modifiers, the following member functions are generated for an OMG IDL union of type <span style="font-style: normal">TYPE</span> with switch (long) discriminator:
</p>
<h4 class="pDefTerm"><a name="wp1121718"> </a>
<code class="cCodeEmphasis">TYPE</code><code class="cCode">(); </code>
</h4><div class="pDefPara"><a name="wp1121719"> </a>
This is the default constructor for a union. No default discriminator is set by this function, so you cannot access the union until you set the value of the union.
</div>
<h4 class="pDefTerm"><a name="wp1121720"> </a>
<code class="cCodeEmphasis">TYPE</code><code class="cCode">( const </code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> &amp; From); </code>
</h4><div class="pDefPara"><a name="wp1121721"> </a>
This copy constructor deep copies the specified union. Any data in the union parameter is copied. The <code class="cCode">From</code> argument specifies the union to be copied.
</div>
<h4 class="pDefTerm"><a name="wp1121722"> </a>
<code class="cCode">~</code><code class="cCodeEmphasis">TYPE</code><code class="cCode">(); </code>
</h4><div class="pDefPara"><a name="wp1121723"> </a>
This destructor frees the data associated with the union.
</div>
<h4 class="pDefTerm"><a name="wp1121724"> </a>
<code class="cCodeEmphasis">TYPE</code><code class="cCode"> &amp;operator=(const </code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> &amp; From); </code>
</h4><div class="pDefPara"><a name="wp1121725"> </a>
This assignment operator copies the specified union. Any existing value in the current union is freed. The <code class="cCode">From</code> argument specifies the union to be copied.
</div>
<h4 class="pDefTerm"><a name="wp1121726"> </a>
<code class="cCode">void _d (CORBA::Long Discrim);</code> 
</h4><div class="pDefPara"><a name="wp1121727"> </a>
This modifier function sets the value of the union discriminant. The <code class="cCode">Discrim</code> argument specifies the new discriminant. The data type of the argument is determined by the OMG IDL data type specified in the switch statement of the union. For each OMG IDL data type, see <a href="member.html#wp1154188">Table&#160;13-1</a> for the C++ data type.
</div>
<div class="pDefParaCont"><a name="wp1174676"> </a>
Only use this function to set the discriminant to a value within the same union member. You cannot use this function to implicitly switch between different union members.
<a name="wp1174677"> </a>
These restrictions are illustrated by the following code:
<a name="wp1174695"> </a><div class="pPreformattedRelative"><pre>union U switch(long) {<br />	case 1: <br />	case 2: <br />		short s; <br />	case 3:<br />		int it;<br />}; <br /><br />short st;<br />U u; <br />u.s(1296);	 	 // member &quot;s&quot; selected <br />st = u.s(); // st == 1296 <br />u._d(2); 			 	// OK: member &quot;s&quot; still selected <br />st = u.s(); // st == 1296 <br />u._d(3);	 	 	 	// BAD_PARAM: selecting a different member </pre></div><a name="wp1174733"> </a>
When the <code class="cCode">_d()</code> modifier is invoked on a new instance of a union, Tuxedo C++ relaxes the &quot;implicit switching&quot; restriction. In this case, no exception is thrown, and the union is not affected. 
<a name="wp1174734"> </a><div class="pPreformattedRelative"><pre>U u2;<br />u2._d(1); 		 	 	 // no exception, union is unchanged <br />st = u2.s(); // error! accessing an uninitialized union <br />u2.it(1296); // OK: member &quot;it&quot; now selected </pre></div></div>
<h4 class="pDefTerm"><a name="wp1121731"> </a>
<code class="cCode">CORBA::Long _d () const; </code>
</h4><div class="pDefPara"><a name="wp1121732"> </a>
This function returns the current discriminant value. The data type of the return value is determined by the OMG IDL data type specified in the switch statement of the union. For each OMG IDL data type, see <a href="member.html#wp1154188">Table&#160;13-1</a> for the C++ data type.
</div>
<h3 class="pHeading2"><a name="wp1121083"> </a>
Sequences
</h3>
<p class="pBody"><a name="wp1121084"> </a>
A sequence in OMG IDL is mapped to a C++ class. The C++ class contains the following:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1121085"> </a>Constructors</li>
<p class="pBodyRelative"><a name="wp1121086"> </a>
Each sequence has the following:
</p>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1121087"> </a>A default constructor</li>
<li><a name="wp1121088"> </a>A constructor that initializes each element</li>
<li><a name="wp1121089"> </a>A copy constructor</li>
</ul></div>
<li><a name="wp1121090"> </a>Destructors</li>
<li><a name="wp1121091"> </a>Modifiers for current length (and for maximum, if the sequence is unbounded)</li>
<li><a name="wp1121092"> </a>Accessors for current length</li>
<li><a name="wp1121093"> </a>Operator[] functions to access or modify sequence elements</li>
<li><a name="wp1121094"> </a>Allocation and deallocation member functions</li>
</ul></div>
<p class="pBody"><a name="wp1121095"> </a>
You <em class="cEmphasis">must</em> set the length before accessing any elements.
</p>
<p class="pBody"><a name="wp1121096"> </a>
For example, consider the following OMG IDL definition:
</p>
<a name="wp1121097"> </a><div class="pPreformatted"><pre>// OMG IDL</pre></div><a name="wp1121098"> </a><div class="pPreformatted"><pre>module INVENT <br />    {<br />    . . .<br />    typedef sequence&lt;LogItem&gt;       LogList;<br />    }</pre></div><p class="pBody"><a name="wp1121099"> </a>
This definition maps to C++ as follows:
</p>
<a name="wp1121100"> </a><div class="pPreformatted"><pre>// C++</pre></div><a name="wp1121101"> </a><div class="pPreformatted"><pre>class LogList<br />    {<br />    public:<br />        // Default constructor<br />        LogList();</pre></div><a name="wp1121102"> </a><div class="pPreformatted"><pre>        // Maximum constructor<br />        LogList(CORBA::ULong _max);</pre></div><a name="wp1121103"> </a><div class="pPreformatted"><pre>       // TYPE * data constructor<br />        LogList<br />        (<br />            CORBA::ULong _max,<br />            CORBA::ULong _length,<br />            LogItem *_value,<br />            CORBA::Boolean _relse = CORBA_FALSE<br />        );</pre></div><a name="wp1121104"> </a><div class="pPreformatted"><pre>        // Copy constructor<br />         LogList(const LogList&amp;);</pre></div><a name="wp1121105"> </a><div class="pPreformatted"><pre>        // Destructor <br />        ~LogList();</pre></div><a name="wp1121106"> </a><div class="pPreformatted"><pre>        LogList &amp;operator=(const LogList&amp;);</pre></div><a name="wp1121107"> </a><div class="pPreformatted"><pre>        CORBA::ULong maximum() const;</pre></div><a name="wp1121108"> </a><div class="pPreformatted"><pre>        void length(CORBA::ULong);<br />        CORBA::ULong length() const;</pre></div><a name="wp1121109"> </a><div class="pPreformatted"><pre>        LogItem &amp;operator[](CORBA::ULong _index);<br />        const LogItem &amp;operator[](CORBA::ULong _index) const;</pre></div><a name="wp1121110"> </a><div class="pPreformatted"><pre>        static LogItem *allocbuf(CORBA::ULong _nelems);<br />        static void freebuf(LogItem *);<br />        };</pre></div><a name="wp1121111"> </a><div class="pPreformatted"><pre>    };</pre></div><h4 class="pHeading3"><a name="wp1121112"> </a>
Sequence Element Mapping
</h4>
<p class="pBody"><a name="wp1121113"> </a>
The<code class="cCode"> operator[] </code>functions are used to access or modify the sequence element. These operators return a reference to the sequence element. The OMG IDL sequence base type is mapped to the appropriate C++ data type.
</p>
<p class="pBody"><a name="wp1121117"> </a>
For basic data types, see <a href="member.html#wp1154188">Table&#160;13-1</a>. For object references, TypeCode references, and strings, the base type is mapped to a generated <code class="cCode">_ForSeq_var</code> class. The <code class="cCode">_ForSeq_var</code> class provides the capability to update a string or an object that is stored within the sequence. This generated class has the same member functions and signatures as the corresponding var class. However, this <code class="cCode">_ForSeq_var</code> class honors the setting of the release parameter in the sequence constructor. The distinction is that the <code class="cCode">_ForSeq_var</code> class lets users specify the <code class="cCode">Release</code> flag, thereby allowing users to control the freeing of memory.
</p>
<p class="pBody"><a name="wp1121121"> </a>
All other data types are mapped as shown in <a href="member.html#wp1154490">Table&#160;13-2</a>.
</p>
<h4 class="pHeading3"><a name="wp1121122"> </a>
Vars
</h4>
<p class="pBody"><a name="wp1121125"> </a>
A var class is generated for a sequence. For more information, see the section <a href="member.html#wp1009915">Using var Classes</a>.
</p>
<h4 class="pHeading3"><a name="wp1138001"> </a>
Out
</h4>
<p class="pBody"><a name="wp1138005"> </a>
An out class is generated for a sequence. For more information, see the section <a href="member.html#wp1132019">Using out Classes</a>.
</p>
<h4 class="pHeading3"><a name="wp1121127"> </a>
Member Functions
</h4>
<p class="pBody"><a name="wp1121128"> </a>
For a given OMG IDL sequence <em class="cEmphasis">SEQ</em> with base type <span style="font-style: normal">TYPE</span>, the member functions for the generated sequence class are described as follows:
</p>
<h4 class="pDefTerm"><a name="wp1121129"> </a>
<code class="cCode">SEQ (); </code>
</h4><div class="pDefPara"><a name="wp1121130"> </a>
This is the default constructor for a sequence. The length is set to 0 (zero). If the sequence is unbounded, the maximum is also set to 0 (zero). If the sequence is bounded, the maximum is specified by the OMG IDL type and cannot be changed.
</div>
<h4 class="pDefTerm"><a name="wp1121131"> </a>
<code class="cCode">SEQ (CORBA::ULong Max); </code>
</h4><div class="pDefPara"><a name="wp1121132"> </a>
This constructor is present only if the sequence is unbounded. This function sets the length of the sequence to 0 (zero) and sets the maximum of the buffer to the specified value. The <code class="cCode">Max</code> argument specifies the maximum length of the sequence.
</div>
<h4 class="pDefTerm"><a name="wp1121133"> </a>
<code class="cCode">SEQ (CORBA::ULong Max, CORBA::ULong Length, </code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> * Value,<br />      CORBA::Boolean Release); </code>
</h4><div class="pDefPara"><a name="wp1121134"> </a>
This constructor sets the maximum, length, and elements of the sequence. The <code class="cCode">Release</code> flag determines whether elements are released when the sequence is destroyed. Explanations of the arguments are as follows:
</div>
<div class="pDefTerm2"><h4 class="pDefTerm2"><a name="wp1121135"> </a>
<code class="cCode">Max</code>
</h4></div>
<div class="pDefPara2"><a name="wp1121136"> </a>
The maximum value of the sequence. This argument is not present in bounded sequences.
</div><div class="pDefTerm2"><h4 class="pDefTerm2"><a name="wp1121137"> </a>
<code class="cCode">Length</code>
</h4></div>
<div class="pDefPara2"><a name="wp1121138"> </a>
The current length of the sequence. For bounded sequences, this value must be less than the maximum specified in the OMG IDL type.
</div><div class="pDefTerm2"><h4 class="pDefTerm2"><a name="wp1121139"> </a>
<code class="cCode">Value</code>
</h4></div>
<div class="pDefPara2"><a name="wp1121140"> </a>
A pointer to the buffer containing the elements of the sequence.
</div><div class="pDefTerm2"><h4 class="pDefTerm2"><a name="wp1121141"> </a>
<code class="cCode">Release</code>
</h4></div>
<div class="pDefPara2"><a name="wp1121142"> </a>
Determines whether elements are released. If this flag has a value of<code class="cCode"> CORBA_TRUE</code>, the sequence assumes ownership of the buffer pointed to by the <code class="cCode">Value</code> argument. If the <code class="cCode">Release</code> flag is<code class="cCode"> CORBA_ TRUE</code>, this buffer must be allocated using the<code class="cCode"> allocbuf </code>member function, because it will be freed using the<code class="cCode"> freebuf </code>member function when the sequence is destroyed.
</div><h4 class="pDefTerm"><a name="wp1121143"> </a>
<code class="cCode">SEQ(const S&amp; From); </code>
</h4><div class="pDefPara"><a name="wp1121144"> </a>
This copy constructor deep copies the sequence from the specified argument. The <code class="cCode">From</code> argument specifies the sequence to be copied.
</div>
<h4 class="pDefTerm"><a name="wp1121145"> </a>
<code class="cCode">~SEQ(); </code>
</h4><div class="pDefPara"><a name="wp1121146"> </a>
This destructor frees the sequence and, depending upon the <code class="cCode">Release</code> flag, may free the sequence elements.
</div>
<h4 class="pDefTerm"><a name="wp1121147"> </a>
<code class="cCode">SEQ&amp; operator=(const SEQ&amp; From); </code>
</h4><div class="pDefPara"><a name="wp1121148"> </a>
This assignment operator deep copies the sequence from the specified sequence argument. Any existing elements in the current sequence are released if the <code class="cCode">Release</code> flag in the current sequence is set to<code class="cCode"> CORBA_TRUE</code>. The <code class="cCode">From</code> argument specifies the sequence to be copied.
</div>
<h4 class="pDefTerm"><a name="wp1121149"> </a>
<code class="cCode">CORBA::ULong maximum( ) const; </code>
</h4><div class="pDefPara"><a name="wp1121150"> </a>
This function returns the maximum of the sequence. For a bounded sequence, this is the value set in the OMG IDL type. For an unbounded sequence, this is the current maximum of the sequence.
</div>
<h4 class="pDefTerm"><a name="wp1121151"> </a>
<code class="cCode">void length(CORBA::ULong Length); </code>
</h4><div class="pDefPara"><a name="wp1121152"> </a>
This function sets the current length of the sequence. The <code class="cCode">Length</code> argument specifies the new length of the sequence. If the sequence is unbounded and the new length is greater than the current maximum, the buffer is reallocated and the elements are copied to the new buffer. If the new length is greater than the maximum, the maximum is set to the new length.
</div>
<div class="pDefParaCont"><a name="wp1121153"> </a>
For a bounded sequence, the length cannot be set to a value greater than the maximum.
</div>
<h4 class="pDefTerm"><a name="wp1121154"> </a>
<code class="cCode">CORBA::ULong length() const; </code>
</h4><div class="pDefPara"><a name="wp1121155"> </a>
This function returns the current length of the sequence.
</div>
<h4 class="pDefTerm"><a name="wp1121156"> </a>
<code class="cCodeEmphasis">TYPE</code><code class="cCode"> &amp; operator[](CORBA::ULong Index); <br />const </code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> &amp; operator[](CORBA::ULong Index) const; </code>
</h4><div class="pDefPara"><a name="wp1121157"> </a>
These accessor functions return a reference to the sequence element at the specified index. The <code class="cCode">Index</code> argument specifies the index of the element to return. This index cannot be greater than the current sequence length. The length must have been set either using the <span style="font-style: normal">TYPE *</span> constructor or the <code class="cCode">length(CORBA::ULong) </code>modifier. If <span style="font-style: normal">TYPE</span> is an object reference, TypeCode reference, or string, the return type will be a <code class="cCode">ForSeq_var</code> class.
</div>
<h4 class="pDefTerm"><a name="wp1121158"> </a>
<code class="cCode">static </code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> * allocbuf(CORBA::ULong NumElems); </code>
</h4><div class="pDefPara"><a name="wp1121159"> </a>
This static function allocates a buffer to be used with the <code class="cCodeEmphasis">TYPE</code><code class="cCode"> * </code>constructor. The NumElems argument specifies the number of elements in the buffer to allocate. If the buffer cannot be allocated, NULL is returned.
</div>
<div class="pDefParaCont"><a name="wp1121160"> </a>
If this buffer is not passed to the <code class="cCodeEmphasis">TYPE</code><code class="cCode"> * </code>constructor with release set to <code class="cCode">CORBA_TRUE</code>, it should be freed using the<code class="cCode"> freebuf </code>member function.
</div>
<h4 class="pDefTerm"><a name="wp1121161"> </a>
<code class="cCode">static void freebuf(</code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> * Value); </code>
</h4><div class="pDefPara"><a name="wp1121162"> </a>
This static function frees a <code class="cCodeEmphasis">TYPE</code><code class="cCode"> *</code> sequence buffer allocated by the<code class="cCode"> allocbuf </code>function. The <code class="cCode">Value</code> argument specifies the <code class="cCodeEmphasis">TYPE</code><code class="cCode"> * </code>buffer allocated by the<code class="cCode"> allocbuf </code>function. A 0 (zero) pointer is ignored.
</div>
<h3 class="pHeading2"><a name="wp1121164"> </a>
Arrays
</h3>
<p class="pBody"><a name="wp1121165"> </a>
An array in OMG IDL is mapped to a C++ array definition. For example, consider the following OMG IDL definition:
</p>
<a name="wp1121166"> </a><div class="pPreformatted"><pre>    // OMG IDL</pre></div><a name="wp1121167"> </a><div class="pPreformatted"><pre>    module INVENT <br />        { <br />        . . .<br />        typedef LogItem   LogArray[10];<br />        };</pre></div><p class="pBody"><a name="wp1121168"> </a>
This definition maps to C++ as follows:
</p>
<a name="wp1121169"> </a><div class="pPreformatted"><pre>    // C++</pre></div><a name="wp1121170"> </a><div class="pPreformatted"><pre>    module INVENT<br />        { <br />        . . .<br />        typedef LogItem LogArray[10];<br />        typedef LogItem LogArray_slice;<br />        static LogArray_slice * LogArray_alloc(void);<br />        static void LogArray_free(LogArray_slice *data);<br /><br />         };</pre></div><h4 class="pHeading3"><a name="wp1121173"> </a>
Array Slice
</h4>
<p class="pBody"><a name="wp1121174"> </a>
A slice of an array is an array with all the dimensions of the original array except the first dimension. The member functions for the array-generated classes use a pointer to a slice to return pointers to an array. A typedef for each slice is generated.
</p>
<p class="pBody"><a name="wp1121175"> </a>
For example, consider the following OMG IDL definition:
</p>
<a name="wp1121176"> </a><div class="pPreformatted"><pre>    // OMG IDL<br />    typedef LogItem         LogMultiArray[5][10];</pre></div><p class="pBody"><a name="wp1121177"> </a>
This definition maps to C++ as follows:
</p>
<a name="wp1138105"> </a><div class="pPreformatted"><pre>    // C++<br />    typedef LogItem          LogMultiArray[5][10];<br />    typedef LogItem           LogMultiArray_slice[10];</pre></div><p class="pBody"><a name="wp1155387"> </a>
If you have a one-dimensional array, an array slice is just a type. For example, if you had a one-dimensional array of <code class="cCode">long</code>, an array slice would result in a <code class="cCode">CORBA::Long</code> data type.
</p>
<h4 class="pHeading3"><a name="wp1121180"> </a>
Array Element Mapping
</h4>
<p class="pBody"><a name="wp1121181"> </a>
The type of the OMG IDL array is mapped to the C++ array element type in the same manner as structs. For more information, see the section <a href="member.html#wp1121637">Member Mapping</a>.
</p>
<h4 class="pHeading3"><a name="wp1121185"> </a>
Vars
</h4>
<p class="pBody"><a name="wp1121189"> </a>
A var class is generated for an array. For more information, see the section <a href="member.html#wp1009915">Using var Classes</a>.
</p>
<h4 class="pHeading3"><a name="wp1138122"> </a>
Out
</h4>
<p class="pBody"><a name="wp1138126"> </a>
An out class is generated for an array. For more information, see the section <a href="member.html#wp1132019">Using out Classes</a>.
</p>
<h4 class="pHeading3"><a name="wp1121190"> </a>
Allocation Member Functions
</h4>
<p class="pBody"><a name="wp1121191"> </a>
For each array, there are two static functions for array allocation and deallocation. For a given OMG IDL type <code class="cCodeEmphasis">TYPE</code>, the allocation and deallocation routines are as follows:
</p>
<h4 class="pDefTerm"><a name="wp1121192"> </a>
<code class="cCode">static </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_slice * </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_alloc(void); </code>
</h4><div class="pDefPara"><a name="wp1121193"> </a>
This function allocates a <code class="cCodeEmphasis">TYPE</code> array, returning a pointer to the allocated <code class="cCodeEmphasis">TYPE</code> array. If the array cannot be dynamically allocated, 0 (zero) is returned.
</div>
<h4 class="pDefTerm"><a name="wp1121194"> </a>
<code class="cCode">static void </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_free(</code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_slice * Value); </code>
</h4><div class="pDefPara"><a name="wp1121195"> </a>
This function frees a dynamically allocated <code class="cCodeEmphasis">TYPE</code> array. The <code class="cCode">Value</code> argument is a pointer to the dynamically allocated <code class="cCodeEmphasis">TYPE</code> array to be freed.
</div>
<h3 class="pHeading2"><a name="wp1121196"> </a>
Exceptions
</h3>
<p class="pBody"><a name="wp1121197"> </a>
An exception in OMG IDL is mapped to a C++ class. The C++ class contains the following:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1121198"> </a>Constructors</li>
<li><a name="wp1121199"> </a>Destructors</li>
<li><a name="wp1121200"> </a>A static<code class="cCode"> _narrow</code> function, to determine the type of exception</li>
</ul></div>
<p class="pBody"><a name="wp1121201"> </a>
The generated class is similar to a variable-length structure, but with an additional constructor to simplify initialization, and with the static <code class="cCode">_narrow</code> member function to determine the type of UserException.
</p>
<p class="pBody"><a name="wp1121202"> </a>
For example, consider the following OMG IDL definition:
</p>
<a name="wp1121203"> </a><div class="pPreformatted"><pre>    // OMG IDL</pre></div><a name="wp1121204"> </a><div class="pPreformatted"><pre>    module INVENT<br />        {<br />        exception NonExist<br />            {<br />            ID BadId;<br />            };<br />         };</pre></div><p class="pBody"><a name="wp1121205"> </a>
This definition maps to C++ as follows:
</p>
<a name="wp1121206"> </a><div class="pPreformatted"><pre>    // C++</pre></div><a name="wp1121207"> </a><div class="pPreformatted"><pre>    class INVENT<br />        {<br />         . . .</pre></div><a name="wp1121208"> </a><div class="pPreformatted"><pre>        class NonExist : public CORBA::UserException<br />            {<br />            public:<br />                static NonExist * _narrow(CORBA::Exception_ptr);<br />                NonExist (ID _BadId);<br />                NonExist ();<br />                NonExist (const NonExist &amp;);<br />                ~NonExist ();<br />                NonExist &amp; operator=(const NonExist &amp;);<br />                void _raise ();<br />                ID BadId;<br />            };<br />        };</pre></div><p class="pBody"><a name="wp1121210"> </a>
Attributes (data members) of the Exception class are public, so you may access them directly. 
</p>
<h4 class="pHeading3"><a name="wp1121211"> </a>
Member Mapping
</h4>
<p class="pBody"><a name="wp1121214"> </a>
Members of an exception are mapped in the same manner as structs. For more information, see <a href="member.html#wp1121637">Member Mapping</a>.
</p>
<p class="pBody"><a name="wp1121216"> </a>
All exception members are public data in the C++ class, and are accessed directly.
</p>
<h4 class="pHeading3"><a name="wp1121217"> </a>
Var
</h4>
<p class="pBody"><a name="wp1121220"> </a>
A var class is generated for an exception. For more information, see the section <a href="member.html#wp1009915">Using var Classes</a>.
</p>
<h4 class="pHeading3"><a name="wp1138195"> </a>
Out
</h4>
<p class="pBody"><a name="wp1138199"> </a>
An out class is generated for an exception. For more information, see the section<a href="member.html#wp1132019">Using out Classes</a>.
</p>
<h4 class="pHeading3"><a name="wp1121222"> </a>
Member Functions
</h4>
<p class="pBody"><a name="wp1121223"> </a>
For a given OMG IDL exception <code class="cCodeEmphasis">TYPE</code>, the generated member functions are as follows:
</p>
<h4 class="pDefTerm"><a name="wp1121224"> </a>
<code class="cCode">static </code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> * _narrow(CORBA::Exception_ptr Except); </code>
</h4><div class="pDefPara"><a name="wp1121225"> </a>
This function returns a pointer to a <code class="cCodeEmphasis">TYPE</code> exception class if the exception can be narrowed to a <code class="cCodeEmphasis">TYPE</code> exception. If the exception cannot be narrowed, 0 (zero) is returned. The <code class="cCodeEmphasis">TYPE</code> pointer is not a pointer to a new class. Instead, it is a typed pointer to the original exception pointer and is valid only as long as the Except parameter is valid.
</div>
<h4 class="pDefTerm"><a name="wp1121226"> </a>
<code class="cCodeEmphasis">TYPE</code><code class="cCode"> ( ); </code>
</h4><div class="pDefPara"><a name="wp1121227"> </a>
This is the default constructor for the exception. No initialization of members is performed for fixed-length members. Variable-length members map to self-managing types; these types have constructors that initialize the member.
</div>
<h4 class="pDefTerm"><a name="wp1121228"> </a>
<code class="cCodeEmphasis">TYPE</code><code class="cCode">(member-parameters); </code>
</h4><div class="pDefPara"><a name="wp1121229"> </a>
This constructor has an argument for each of the members in the exception. The constructor copies each argument and does not assume ownership of the memory for any argument. Building on the previous example, the signature of the constructor is:
</div>
<div class="pDefPara2"><a name="wp1121230"> </a>
<code class="cCode">NonExist (ID _BadId);</code>
</div><div class="pDefPara"><a name="wp1121231"> </a>
There is one argument for each member of the exception. The type and parameter-passing mechanism are identical to the Any insertion operator. For information about the Any insertion operator, see the section <a href="member.html#wp1127059">Insertion into Any</a>.
</div>
<h4 class="pDefTerm"><a name="wp1121232"> </a>
<code class="cCodeEmphasis">TYPE</code><code class="cCode"> (const </code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> &amp; From); </code>
</h4><div class="pDefPara"><a name="wp1121233"> </a>
This copy constructor copies the data from the specified <code class="cCodeEmphasis">TYPE</code> exception argument. The <code class="cCode">From</code> argument specifies the exception to be copied.
</div>
<h4 class="pDefTerm"><a name="wp1121234"> </a>
<code class="cCode">~</code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> (); </code>
</h4><div class="pDefPara"><a name="wp1121235"> </a>
This destructor frees the data associated with the exception.
</div>
<h4 class="pDefTerm"><a name="wp1121236"> </a>
<code class="cCodeEmphasis">TYPE</code><code class="cCode"> &amp; operator=(const </code><code class="cCodeEmphasis">TYPE</code><code class="cCode"> &amp; From); </code>
</h4><div class="pDefPara"><a name="wp1121237"> </a>
This assignment operator copies the data from the specified <code class="cCodeEmphasis">TYPE</code> exception argument. The <code class="cCode">From</code> argument specifies the exception to be copied.
</div>
<h4 class="pDefTerm"><a name="wp1138248"> </a>
<code class="cCode">void  _raise ();</code>
</h4><div class="pDefPara"><a name="wp1138291"> </a>
This function causes the exception instance to throw itself. A catch clause 
<a name="wp1141846"> </a>
can catch it by a more derived type.
</div>
<h3 class="pHeading2"><a name="wp1148653"> </a>
Mapping of Pseudo-objects to C++
</h3>
<p class="pBody"><a name="wp1148654"> </a>
CORBA pseudo-objects may be implemented either as normal CORBA objects or as <span style="font-style: normal">serverless objects</span>. In the CORBA specification, the fundamental differences between these strategies are:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1148656"> </a>Serverless object types do not inherit from <code class="cCode">CORBA::Object</code>.</li>
<li><a name="wp1148657"> </a>Individual serverless objects are not registered with any ORB.</li>
<li><a name="wp1148658"> </a>Serverless objects do not necessarily follow the same memory management rules as for regular IDL types.</li>
</ul></div>
<p class="pBody"><a name="wp1148659"> </a>
References to serverless objects are not necessarily valid across computational contexts; for example, address spaces. Instead, references to serverless objects that are passed as parameters may result in the construction of independent, functionally identical copies of objects used by receivers of these references. To support this, the otherwise hidden representational properties (such as data layout) of serverless objects are made known to the ORB. Specifications for achieving this are not contained in this chapter; making serverless objects known to the ORB is an implementation detail. 
</p>
<p class="pBody"><a name="wp1148660"> </a>
This chapter provides a standard mapping algorithm for all pseudo-object types. This avoids the need for piecemeal mappings for each of the nine CORBA pseudo-object types, and accommodates any pseudo-object types that may be proposed in future revisions of <span style="font-style: italic">CORBA.</span> It also avoids representation dependence in the C mapping, while still allowing implementations that rely on C-compatible representations.
</p>
<h3 class="pHeading2"><a name="wp1148057"> </a>
Usage
</h3>
<p class="pBody"><a name="wp1148058"> </a>
Rather than C-PIDL, this mapping uses an augmented form of full OMG IDL to describe serverless object types. Interfaces for pseudo-object types follow the same rules as normal OMG IDL interfaces, with the following exceptions:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1148060"> </a>They are prefaced by the keyword <code style="font-weight: normal" class="cCode">pseudo</code><span style="font-weight: bold">.</span></li>
<li><a name="wp1148064"> </a>Their declarations may refer to other<a href="#wp1148063" title="Footnote 1"><sup class="Footnote">1</sup></a> serverless object types that are not otherwise necessarily allowed in OMG IDL.</li>
</ul></div>
<p class="pBody"><a name="wp1148065"> </a>
The <code class="cCode">pseudo</code> prefix means that the interface may be implemented in either a normal or serverless fashion. That is, apply either the rules described in the following sections, or the normal mapping rules described in this chapter.
</p>
<h3 class="pHeading2"><a name="wp1149078"> </a>
Mapping Rules
</h3>
<p class="pBody"><a name="wp1149079"> </a>
Serverless objects are mapped in the same way as normal interfaces, except for the differences outlined in this section.
</p>
<p class="pBody"><a name="wp1149080"> </a>
Classes representing serverless object types are <em class="cEmphasis">not</em> subclasses of <code class="cCode">CORBA::Object</code>, and are not necessarily subclasses of any other C++ class. Thus, they do not necessarily support, for example, the <code class="cCode">Object::create_request</code> operation.
</p>
<p class="pBody"><a name="wp1149081"> </a>
For each class representing a serverless object type <code class="cCode">T</code>, overloaded versions of the following functions are provided in the CORBA namespace:
</p>
<a name="wp1149082"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />void release(T_ptr);<br />Boolean is_nil(T_ptr p);</code></pre></div><p class="pBody"><a name="wp1149083"> </a>
The mapped C++ classes are not guaranteed to be usefully subclassable by users, although subclasses can be provided by implementations. Implementations are allowed to make assumptions about internal representations and transport formats that may not apply to subclasses.
</p>
<p class="pBody"><a name="wp1152766"> </a>
The member functions of classes representing serverless object types do not necessarily obey the normal memory management rules. This is because some serverless objects, such as <code class="cCode">CORBA::NVList</code>, are essentially just containers for several levels of other serverless objects. Requiring callers to explicitly free the values returned from accessor functions for the contained serverless objects would be counter to their intended usage.
</p>
<p class="pBody"><a name="wp1149085"> </a>
All other elements of the mapping are the same. In particular:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1149086"> </a>The types of references to serverless objects, <code class="cCode">T_ptr</code>, may or may not simply be a typedef of <code class="cCode">T*</code>.</li>
<li><a name="wp1149087"> </a>Each mapped class supports the following static member functions:</li>
<a name="wp1149088"> </a><div class="pPreformattedRelative"><pre><code class="cCode">// C++<br />static T_ptr _duplicate(T_ptr p);<br />static T_ptr _nil();</code></pre></div><li><a name="wp1149089"> </a>Legal implementations of <code class="cCode">_duplicate</code> include simply returning the argument or constructing references to a new instance. Individual implementations may provide stronger guarantees about behavior.</li>
<li><a name="wp1149090"> </a>The corresponding C++ classes may or may not be directly instantiable or have other instantiation constraints. For portability, users should invoke the appropriate constructive operations. </li>
<li><a name="wp1149091"> </a>As with normal interfaces, assignment operators are not supported.</li>
<li><a name="wp1149092"> </a>Although they can transparently employ &#8220;copy-style&#8221; rather than &#8220;reference-style&#8221; mechanics, parameter passing signatures and rules as well as memory management rules are identical to those for normal objects, unless otherwise noted.</li>
</ul></div>
<h3 class="pHeading2"><a name="wp1146619"> </a>
Relation to the C PIDL Mapping
</h3>
<p class="pBody"><a name="wp1146620"> </a>
All serverless object interfaces and declarations that rely on them have direct analogs in the C mapping. The mapped C++ classes can, but need not, be implemented using representations compatible to those chosen for the C mapping. Differences between the pseudo-object specifications for C-PIDL and C++ PIDL are as follows:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1146621"> </a>C++ PIDL calls for removal of representation dependencies through the use of interfaces rather than structs and typedefs.</li>
<li><a name="wp1146622"> </a>C++ PIDL calls for placement of operations on pseudo-objects in their interfaces, including a few cases of redesignated functionality as noted.</li>
<li><a name="wp1146623"> </a>In C++ PIDL, <code class="cCode">release</code> performs the role of the associated <code class="cCode">free</code> and <code class="cCode">delete</code> operations in the C mapping, unless otherwise noted.</li>
</ul></div>
<p class="pBody"><a name="wp1146624"> </a>
Brief descriptions and listings of each pseudo-interface and its C++ mapping are provided in the following sections. Further details, including definitions of types referenced but not defined below, may be found in the relevant sections of this document.
</p>
<h3 class="pHeading2"><a name="wp1121238"> </a>
Typedefs
</h3>
<p class="pBody"><a name="wp1121239"> </a>
A typedef in OMG IDL is mapped to a typedef in C++. Depending upon the OMG IDL data type, additional typedefs and member functions may be defined. The generated code for each data type is as follows:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1121240"> </a>Basic data types (short, long, unsigned short, unsigned long, float, double, char, boolean, and octet)</li>
<p class="pBodyRelative"><a name="wp1121241"> </a>
Basic data types map to a simple typedef. For example:
</p>
<a name="wp1121242"> </a><div class="pPreformattedRelative"><pre><code class="cCode">// OMG IDL<br />typedef long ID;</code></pre></div><a name="wp1121243"> </a><div class="pPreformattedRelative"><pre><code class="cCode">// C++<br />typedef CORBA::Long ID;</code></pre></div><li><a name="wp1121244"> </a>string</li>
<p class="pBodyRelative"><a name="wp1121245"> </a>
A string typedef is mapped to a simple typedef. For example:
</p>
<a name="wp1121246"> </a><div class="pPreformattedRelative"><pre><code class="cCode">// OMG IDL<br />typedef string IDStr;</code></pre></div><a name="wp1121247"> </a><div class="pPreformattedRelative"><pre><code class="cCode">// C++<br />typedef char * IDStr;</code></pre></div><li><a name="wp1121248"> </a>object, interfaces, TypeCode</li>
<p class="pBodyRelative"><a name="wp1121249"> </a>
Object, interfaces, and TypeCode types are mapped to four typedefs. For example:
</p>
<a name="wp1121250"> </a><div class="pPreformattedRelative"><pre><code class="cCode">// OMG IDL<br />typedef Item Intf;</code></pre></div><a name="wp1121251"> </a><div class="pPreformattedRelative"><pre><code class="cCode">// C++<br />typedef Item Intf;<br />typedef Item_ptr Intf_ptr;<br />typedef Item_var Intf_var;<br />typedef Item_ptr &amp; Intf _out;</code></pre></div><li><a name="wp1121252"> </a>enum, struct, union, sequence</li>
<p class="pBodyRelative"><a name="wp1121253"> </a>
UDTs are mapped to three typedefs. For example:
</p>
<a name="wp1121254"> </a><div class="pPreformattedRelative"><pre>// OMG IDL<br />typedef LogList ListRetType;</pre></div><a name="wp1121255"> </a><div class="pPreformattedRelative"><pre>// C++<br />typedef LogList ListRetType;<br />typedef LogList_var ListRetType_var;<br />typedef LogList_out &amp; ListRetType_out;</pre></div><li><a name="wp1121256"> </a>array</li>
<p class="pBodyRelative"><a name="wp1121257"> </a>
Arrays are mapped to four typedefs and the static member functions to allocate and free memory. For example:
</p>
<a name="wp1121258"> </a><div class="pPreformattedRelative"><pre>// OMG IDL<br />typedef LogArray ArrayRetType;</pre></div><a name="wp1121259"> </a><div class="pPreformattedRelative"><pre>// C++<br />typedef LogArray ArrayRetType;<br />typedef LogArray_var ArrayRetType_var;<br />typedef LogArray_forany ArrayRetType_forany;<br />typedef LogArray_slice ArrayRetType_slice;<br />ArrayRetType_slice * ArrayRetType_alloc();<br />void ArrayRetType_free(ArrayRetType_slice *);</pre></div></ul></div>
<h3 class="pHeading2"><a name="wp1147535"> </a>
Implementing Interfaces
</h3>
<p class="pBody"><a name="wp1147536"> </a>
An operation in OMG IDL is mapped to a C++ member function.
</p>
<p class="pBody"><a name="wp1147537"> </a>
The name of the member function is the name of the operation. The operation is defined as a member function in both the interface class and the stub class. The interface class is virtual; the stub class inherits from the virtual class and contains the member function code from the client application stub. When an operation is invoked on the object reference, the code contained in the corresponding stub member function executes.
</p>
<p class="pBody"><a name="wp1147538"> </a>
For example, consider the following OMG IDL definition:
</p>
<a name="wp1147539"> </a><div class="pPreformatted"><pre>// OMG IDL</pre></div><a name="wp1147540"> </a><div class="pPreformatted"><pre>module INVENT<br />    {<br />     interface Order <br />        {<br />        . . .<br />        ItemList modifyOrder (in ItemList ModifyList);<br />        };<br />    };</pre></div><p class="pBody"><a name="wp1147541"> </a>
This definition maps to C++ as follows:
</p>
<a name="wp1147542"> </a><div class="pPreformatted"><pre>// C++</pre></div><a name="wp1147543"> </a><div class="pPreformatted"><pre>class INVENT<br />    {<br />    . . .</pre></div><a name="wp1147544"> </a><div class="pPreformatted"><pre>    class Order : public virtual CORBA::Object<br />        {<br />        . . .<br />        virtual ItemList * modifyOrder ( <br />            const ItemList &amp; ModifyList) = 0;<br />        };<br />    };</pre></div><a name="wp1147545"> </a><div class="pPreformatted"><pre>class Stub_Order : public Order<br />    {<br />    . . .<br />    ItemList * modifyOrder ( <br />        const ItemList &amp; ModifyList);<br />    };</pre></div><p class="pBody"><a name="wp1147546"> </a>
The generated client application stub then contains the following generated code for the stub class:
</p>
<a name="wp1147547"> </a><div class="pPreformatted"><pre>// ROUTINE NAME:&#160;&#160;&#160;&#160;INVENT::Stub_Order::modifyOrder <br />//<br />// FUNCTIONAL DESCRIPTION:<br />//<br />// Client application stub routine for operation <br />// modifyOrder.<br />// (Interface : Order)</pre></div><a name="wp1147548"> </a><div class="pPreformatted"><pre>INVENT::ItemList * INVENT::Stub_Order::modifyOrder (<br />     const INVENT::ItemList &amp; ModifyList)<br />{ <br />. . . <br />}</pre></div><h4 class="pHeading3"><a name="wp1147549"> </a>
Argument Mapping
</h4>
<p class="pBody"><a name="wp1147550"> </a>
Each of the arguments in an operation is mapped to the corresponding C++ type as described in <a href="member.html#wp1154188">Table&#160;13-1</a> and <a href="member.html#wp1154490">Table&#160;13-2</a>.
</p>
<p class="pBody"><a name="wp1147557"> </a>
The parameter passing modes for arguments in an operation are described in <a href="member.html#wp1167840">Table&#160;13-7</a> and <a href="member.html#wp1144513">Table&#160;13-8</a>.
</p>
<h3 class="pHeading2"><a name="wp1146213"> </a>
Implementing Operations
</h3>
<p class="pBody"><a name="wp1146214"> </a>
The signature of an implementation member function is the mapped signature of the OMG IDL operation. Unlike the client side, the server-side mapping requires that the function header include the appropriate exception (<code class="cCode">throw</code>) specification. This requirement allows the compiler to detect when an invalid exception is raised, which is necessary in the case of a local C++-to-C++ library call (otherwise, the call would have to go through a wrapper that checks for a valid exception). For example:
</p>
<a name="wp1146216"> </a><div class="pPreformatted"><pre><code class="cCode">// IDL<br />interface A<br />{<br />exception B {};<br />void f() raises(B);<br />};</code></pre></div><a name="wp1146217"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />class MyA : public virtual POA_A<br />{<br />  public:<br />void f() throw(A::B, CORBA::SystemException);<br />...<br /></code>};</pre></div><p class="pBody"><a name="wp1146218"> </a>
Since all operations and attributes may throw CORBA system exceptions, <code class="cCode">CORBA::SystemException</code> must appear in all exception specifications, even when an operation has no <code class="cCode">raises</code> clause.
</p>
<p class="pBody"><a name="wp1146220"> </a>
Within a member function, the &#8220;this&#8221; pointer refers to the implementation object&#8217;s data as defined by the class. In addition to accessing the data, a member function may implicitly call another member function defined by the same class. For example:
</p>
<a name="wp1146221"> </a><div class="pPreformatted"><pre><code class="cCode">// IDL</code></pre></div><a name="wp1146222"> </a><div class="pPreformatted"><pre><code class="cCode">interface A<br />{<br />void f();<br />void g();<br />};</code></pre></div><a name="wp1146224"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />class MyA : public virtual POA_A<br />{<br />  public:</code></pre></div><a name="wp1146225"> </a><div class="pPreformatted"><pre><code class="cCode">void f() throw(SystemException);<br />void g() throw(SystemException);<br />  private:<br />long x_;<br />};<br /><br />void<br />MyA::f() throw(SystemException)<br />{<br />this-&gt;x_ = 3;<br />this-&gt;g();<br />}</code></pre></div><p class="pBody"><a name="wp1146226"> </a>
However, when a servant member function is invoked in this manner, it is being called simply as a C++ member function, not as the implementation of an operation on a CORBA object. In such a context, any information available via the <code class="cCode">POA_Current</code> object refers to the CORBA request invocation that performed the C++ member function invocation, not to the member function invocation itself.
</p>
<h4 class="pHeading3"><a name="wp1146227"> </a>
Skeleton Derivation from Object
</h4>
<p class="pBody"><a name="wp1146228"> </a>
In several existing ORB implementations, each skeleton class derives from the corresponding interface class. For example, for interface <code class="cCode">Mod::A</code>, the skeleton class <code class="cCode">POA_Mod::A</code> is derived from class <code class="cCode">Mod::A</code>. These systems, therefore, allow an object reference for a servant to be implicitly obtained via normal C++ derived-to-base conversion rules:
</p>
<a name="wp1146229"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />MyImplOfA my_a;    // declare impl of A<br />A_ptr a = &amp;my_a;   // obtain its object reference<br />                   // by C++ derived-to-base conversion</code></pre></div><p class="pBody"><a name="wp1146230"> </a>
Such code can be supported by a conforming ORB implementation, but it is not required, and is thus not portable. The equivalent portable code invokes <code class="cCode">_this()</code> on the implementation object to implicitly register it if it has not yet been registered, and to get its object reference:
</p>
<a name="wp1121260"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />MyImplOfA my_a;          // declare impl of A<br />A_ptr a = my_a._this();  // obtain its object reference</code></pre></div><h3 class="pHeading2"><a name="wp1147205"> </a>
PortableServer Functions
</h3>
<p class="pBody"><a name="wp1147206"> </a>
Objects registered with POAs use sequences of octet, specifically the <code class="cCode">PortableServer::POA::ObjectId</code> type, as object identifiers. However, because C++ programmers often want to use strings as object identifiers, the C++ mapping provides several conversion functions that convert strings to <code class="cCode">ObjectId</code> and vice versa:
</p>
<a name="wp1147207"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />namespace PortableServer<br />{<br />char* ObjectId_to_string(const ObjectId&amp;);<br /><br />ObjectId* string_to_ObjectId(const char*);<br />}</code></pre></div><p class="pBody"><a name="wp1147208"> </a>
These functions follow the normal C++ mapping rules for parameter passing and memory management.
</p>
<p class="pBody"><a name="wp1147209"> </a>
If conversion of an <code class="cCode">ObjectId</code> to a string would result in illegal characters in the string (such as a NULL), the first two functions throw the <code class="cCode">CORBA::BAD_PARAM</code> exception.
</p>
<h3 class="pHeading2"><a name="wp1141571"> </a>
Modules
</h3>
<p class="pBody"><a name="wp1141572"> </a>
A module in OMG IDL is mapped to a C++ class. Objects contained in the module are defined within this C++ class. Because interfaces and types are also mapped to classes, nested C++ classes result.
</p>
<p class="pBody"><a name="wp1141573"> </a>
For example, consider the following OMG IDL definition:
</p>
<a name="wp1141574"> </a><div class="pPreformatted"><pre>     // OMG IDL</pre></div><a name="wp1141575"> </a><div class="pPreformatted"><pre>     module INVENT<br />       {<br />       interface Order<br />             {<br />             . . .<br />             };<br />        };</pre></div><p class="pBody"><a name="wp1141576"> </a>
This definition maps to C++ as follows:
</p>
<a name="wp1141577"> </a><div class="pPreformatted"><pre>     // C++</pre></div><a name="wp1141578"> </a><div class="pPreformatted"><pre>     class INVENT<br />        {<br />        . . .<br />        class Order : public virtual CORBA::Object<br />             {<br />             . . .<br />             };  // class Order<br />         };  // class INVENT</pre></div><p class="pBody"><a name="wp1141579"> </a>
Multiple nested modules yield multiple nested classes. Anything inside the module will be in the module class. Anything inside the interface will be in the interface class.
</p>
<p class="pBody"><a name="wp1141816"> </a>
OMG IDL allows modules, interfaces, and types to have the same name. However, when generating files for the C++ language, having the same name is not allowed. This restriction is necessary because the OMG IDL names are generated into nested C++ classes with the same name; this is not supported by C++ compilers.
</p>
<a name="wp1141820"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The Oracle Tuxedo OMG IDL compiler outputs an informational message if you generate C++ code from OMG IDL with an interface or type with the same name as the current module name. If you ignore this informational message and do not use unique names to differentiate the interface or type from the module name, the compiler will signal errors when compiling the generated files.</td>
</tr>
</table>

<h3 class="pHeading2"><a name="wp1141585"> </a>
Interfaces
</h3>
<p class="pBody"><a name="wp1141586"> </a>
An interface in OMG IDL is mapped to a C++ class. This class contains the definitions of the operations, attributes, constants, and user-defined types (UDTs) contained in the OMG IDL interface.
</p>
<p class="pBody"><a name="wp1141587"> </a>
For an interface <em class="cEmphasis">INTF</em>, the generated interface code contains the following items:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1141588"> </a>Object reference type (<code class="cCodeEmphasis">INTF</code><code class="cCode">_ptr</code>)</li>
<li><a name="wp1141589"> </a>Object reference variable type (<code class="cCodeEmphasis">INTF</code><code class="cCode">_var</code>)</li>
<li><a name="wp1141590"> </a><code class="cCode">_duplicate </code>static member function</li>
<li><a name="wp1141591"> </a><code class="cCode">_narrow </code>static member function</li>
<li><a name="wp1141592"> </a><code class="cCode">_nil </code>static member function</li>
<li><a name="wp1141593"> </a>UDTs</li>
<li><a name="wp1141594"> </a>Member functions for attributes and operations</li>
</ul></div>
<p class="pBody"><a name="wp1141595"> </a>
For example, consider the following OMG IDL definition:
</p>
<a name="wp1141596"> </a><div class="pPreformatted"><pre>     // OMG IDL</pre></div><a name="wp1141597"> </a><div class="pPreformatted"><pre>     module INVENT<br />         {<br />          interface Order<br />            {<br />             void cancelOrder ();<br />             };<br />           };</pre></div><p class="pBody"><a name="wp1141598"> </a>
This definition maps to C++ as follows:
</p>
<a name="wp1141599"> </a><div class="pPreformatted"><pre>    // C++<br />    class INVENT<br />        {<br />         . . .<br />         class   Order;<br />          typedef Order *            Order_ptr;</pre></div><a name="wp1141600"> </a><div class="pPreformatted"><pre>         class Order : public virtual CORBA::Object<br />            {<br />            . . .<br />            static Order_ptr _duplicate(Order_ptr obj); <br />            static Order_ptr _narrow(CORBA::Object_ptr obj);<br />            static Order_ptr _nil();<br />            virtual void cancelOrder () = 0; <br />           . . .<br />           };<br />        };</pre></div><p class="pBody"><a name="wp1141601"> </a>
The object reference types and static member functions are described in the following sections, as are UDTs, operations, and attributes.
</p>
<h3 class="pHeading2"><a name="wp1141602"> </a>
Generated Static Member Functions
</h3>
<p class="pBody"><a name="wp1141603"> </a>
This section describes in detail the generated static member functions: <code class="cCode">_duplicate, _narrow, </code>and<code class="cCode"> _nil </code>for an interface <em class="cEmphasis">INTF</em>.
</p>
<h4 class="pDefTerm"><a name="wp1141604"> </a>
<code class="cCode">static </code><code class="cCodeEmphasis">INTF</code><code class="cCode">_ptr _duplicate (</code><code class="cCodeEmphasis">INTF</code><code class="cCode">_ptr Obj) </code>
</h4><div class="pDefPara"><a name="wp1141605"> </a>
This static member function duplicates an existing <em class="cEmphasis">INTF</em> object reference and returns a new <em class="cEmphasis">INTF</em> object reference. The new <em class="cEmphasis">INTF</em> object reference must be released by calling the<code class="cCode"> CORBA::release </code>member function. If an error occurs, a reference to the nil <em class="cEmphasis">INTF</em> object is returned. The argument <code class="cCode">Obj</code> specifies the object reference to be duplicated.
</div>
<h4 class="pDefTerm"><a name="wp1141606"> </a>
<code class="cCode">static </code><code class="cCodeEmphasis">INTF</code><code class="cCode">_ptr _narrow (CORBA::Object_ptr Obj)</code>
</h4><div class="pDefPara"><a name="wp1141607"> </a>
This static member function returns a new <em class="cEmphasis">INTF</em> object reference given an existing <code class="cCode">CORBA::Object_ptr</code> object reference. The <code class="cCode">Object_ptr</code> object reference may have been created by a call to the <code class="cCode">CORBA::ORB::string_to_object</code> member function or may have been returned as a parameter from an operation.
</div>
<div class="pDefParaCont"><a name="wp1141608"> </a>
The <code class="cCodeEmphasis">INTF</code><code class="cCode">_ptr</code> object reference must correspond to an <em class="cEmphasis">INTF</em> object or to an object that inherits from the <em class="cEmphasis">INTF</em> object. The new <em class="cEmphasis">INTF</em> object reference must be released by calling the <code class="cCode">CORBA::release member</code> function. The argument <code class="cCode">Obj</code> specifies the object reference to be narrowed to an <em class="cEmphasis">INTF</em> object reference. The <code class="cCode">Obj</code> parameter is not modified by this member function and should be released by the user when it is no longer required. If<code class="cCode"> Obj</code> cannot be narrowed to an <em class="cEmphasis">INTF</em> object reference, the <em class="cEmphasis">INTF</em> nil object reference is returned.
</div>
<h4 class="pDefTerm"><a name="wp1141609"> </a>
<code class="cCode">static </code><code class="cCodeEmphasis">INTF</code><code class="cCode">_ptr _nil ( ) </code>
</h4><div class="pDefPara"><a name="wp1141610"> </a>
This static member function returns the new nil object reference for the<code style="font-style: normal" class="cCode"> </code><span style="font-style: italic">INTF</span> interface. The new reference does <span style="font-style: italic">not</span> have to be released by calling the <code class="cCode">CORBA::release</code> member function.
</div>
<h3 class="pHeading2"><a name="wp1141611"> </a>
Object Reference Types
</h3>
<p class="pBody"><a name="wp1141612"> </a>
An interface class (<em class="cEmphasis">INTF</em>) is a virtual class; the CORBA standard does not allow you to:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1141613"> </a>Create or hold an instance of the interface class</li>
<li><a name="wp1141614"> </a>Use a pointer or a reference to the interface class</li>
</ul></div>
<p class="pBody"><a name="wp1141615"> </a>
Instead, you use one of the object reference types,<code class="cCode"> </code><code class="cCodeEmphasis">INTF</code><code class="cCode">_ ptr</code> or <code class="cCodeEmphasis">INTF</code><code class="cCode">_var</code> class. <br />You can obtain an object reference by using the<code class="cCode"> _narrow </code>static member function. Operations are invoked on these classes using the arrow operator (<code class="cCode">-&gt;</code>).
</p>
<p class="pBody"><a name="wp1170573"> </a>
The <code class="cCodeEmphasis">INTF</code><code class="cCode">_var</code> class simplifies memory management by automatically releasing the object reference when the <code class="cCodeEmphasis">INTF</code><code class="cCode">_var</code> class goes out of scope or is reassigned. Variable types are generated for many of the UDTs and are described in <a href="member.html#wp1009915">Using var Classes</a>.
</p>
<h3 class="pHeading2"><a name="wp1170578"> </a>
Attributes
</h3>
<p class="pBody"><a name="wp1121287"> </a>
A read-only attribute in OMG IDL is mapped to a C++ function that returns the attribute value. A read-write attribute maps to two overloaded C++ functions, one to return the attribute value and one to set the attribute value. The name of the overloaded member function is the name of the attribute.
</p>
<p class="pBody"><a name="wp1121288"> </a>
Attributes are generated in the same way that operations are generated. They are defined in both the virtual and the stub classes. For example, consider the following OMG IDL definition:
</p>
<a name="wp1121289"> </a><div class="pPreformatted"><pre>// OMG IDL</pre></div><a name="wp1121290"> </a><div class="pPreformatted"><pre>module INVENT<br />    {<br />    interface Order<br />        {<br />        . . .<br />        attribute itemStruct   itemInfo;<br />        };<br />    };</pre></div><p class="pBody"><a name="wp1121291"> </a>
This definition maps to C++ as follows:
</p>
<a name="wp1121292"> </a><div class="pPreformatted"><pre>// C++</pre></div><a name="wp1121293"> </a><div class="pPreformatted"><pre>class INVENT<br />    {<br />    . . .</pre></div><a name="wp1121294"> </a><div class="pPreformatted"><pre>    class Item : public virtual CORBA::Object<br />        {<br />        . . .<br />         virtual itemStruct * itemInfo ( ) = 0;</pre></div><a name="wp1121295"> </a><div class="pPreformatted"><pre>        virtual void itemInfo (<br />            const itemStruct &amp; itemInfo) = 0;<br />        };<br />    };</pre></div><a name="wp1121296"> </a><div class="pPreformatted"><pre>class Stub_Item : public Item<br />    {<br />. . . <br />    itemStruct * itemInfo ();</pre></div><a name="wp1121297"> </a><div class="pPreformatted"><pre>    void itemInfo (<br />       const itemStruct &amp; itemInfo); <br />    };</pre></div><p class="pBody"><a name="wp1121298"> </a>
The generated client application stub then contains the following generated code for the stub class:
</p>
<a name="wp1121299"> </a><div class="pPreformatted"><pre>// ROUTINE NAME:       INVENT::Stub_Item::itemInfo <br />//<br />// FUNCTIONAL DESCRIPTION:<br />//<br />//   Client application stub routine for attribute<br />//   INVENT::Stub_Item::itemInfo. (Interface : Item)</pre></div><a name="wp1121300"> </a><div class="pPreformatted"><pre>INVENT::itemStruct * INVENT::Stub_Item::itemInfo ( )<br />{<br />. . .<br />}</pre></div><a name="wp1121301"> </a><div class="pPreformatted"><pre>//<br />// ROUTINE NAME:       INVENT::Stub_Item::itemInfo<br />//<br />// FUNCTIONAL DESCRIPTION:<br />//<br />//   Client application stub routine for attribute<br />//   INVENT::Stub_Item::itemInfo. (Interface : Item) </pre></div><a name="wp1121302"> </a><div class="pPreformatted"><pre>void INVENT::Stub_Item::itemInfo (<br />  const INVENT::itemStruct &amp; itemInfo)<br />{<br />}</pre></div><h4 class="pHeading3"><a name="wp1121303"> </a>
Argument Mapping
</h4>
<p class="pBody"><a name="wp1121304"> </a>
An attribute is equivalent to two operations, one to return the attribute and one to set the attribute. For example, the <code class="cCode">itemInfo</code> attribute listed above is equivalent to:
</p>
<a name="wp1121305"> </a><div class="pPreformatted"><pre>void itemInfo (in itemStruct itemInfo); <br />itemStruct itemInfo ();</pre></div><p class="pBody"><a name="wp1127003"> </a>
The argument mapping for the attribute is the same as the mapping for an operation argument. The attribute is mapped to the corresponding C++ type as described in <a href="member.html#wp1154188">Table&#160;13-1</a> and <a href="member.html#wp1154490">Table&#160;13-2</a>. The parameter passing modes for arguments in an operation are described in <a href="member.html#wp1167840">Table&#160;13-7</a> and <a href="member.html#wp1144513">Table&#160;13-8</a>.
</p>
<h3 class="pHeading2"><a name="wp1127028"> </a>
Any Type
</h3>
<p class="pBody"><a name="wp1127030"> </a>
An <code class="cCode">any</code> in OMG IDL is mapped to the <code class="cCode">CORBA::Any</code> class. The <code class="cCode">CORBA::Any</code> class handles C++ types in a type-safe manner.
</p>
<h4 class="pHeading3"><a name="wp1127037"> </a>
Handling Typed Values
</h4>
<p class="pBody"><a name="wp1127039"> </a>
To decrease the chances of creating an <code class="cCode">any</code> with a mismatched TypeCode and value, the C++ function overloading facility is utilized. Specifically, for each distinct type in an OMG IDL specification, overloaded functions to insert and extract values of that type are provided. Overloaded operators are used for these functions to completely avoid any name space pollution. The nature of these functions, which are described in detail below, is that the appropriate TypeCode is implied by the C++ type of the value being inserted into or extracted from the <code class="cCode">any</code>.
</p>
<p class="pBody"><a name="wp1127042"> </a>
Since the type-safe <code class="cCode">any</code> interface described below is based upon C++ function overloading, it requires C++ types generated from OMG IDL specifications to be distinct. However, there are special cases in which this requirement is not met:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1170581"> </a>The Boolean, octet, and char OMG IDL types are not required to map to distinct C++ types, which means that a separate means of distinguishing them from each other for the purpose of function overloading is necessary. The means of distinguishing these types from each other is described in <a href="member.html#wp1127150">Distinguishing Boolean, Octet, Char, and Bounded Strings</a>.</li>
<li><a name="wp1170586"> </a>Since all strings are mapped to <code class="cCode">char*</code> regardless of whether they are bounded or unbounded, another means of creating or setting an <code class="cCode">any</code> with a bounded string value is necessary. This is described in <a href="member.html#wp1127150">Distinguishing Boolean, Octet, Char, and Bounded Strings</a>.</li>
<li><a name="wp1127055"> </a>In C++, arrays within a function argument list decay into pointers to their first elements. This means that function overloading cannot be used to distinguish between arrays of different sizes. The means for creating or setting an <code class="cCode">any</code> when dealing with arrays is described below and in <a href="member.html#wp1121164">Arrays</a>.</li>
</ul></div>
<h4 class="pHeading3"><a name="wp1127059"> </a>
Insertion into Any
</h4>
<p class="pBody"><a name="wp1127060"> </a>
To allow a value to be set in an <code class="cCode">any</code> in a type-safe fashion, the following overloaded operator function is provided for each separate OMG IDL type T:
</p>
<a name="wp1127061"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />void operator&lt;&lt;=(Any&amp;, T);</code></pre></div><p class="pBody"><a name="wp1127063"> </a>
This function signature suffices for the following types, which are usually passed by value:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1127064"> </a><code class="cCode">Short</code>, <code class="cCode">UShort</code>, <code class="cCode">Long</code>, <code class="cCode">ULong</code>, <code class="cCode">Float</code>, <code class="cCode">Double</code></li>
<li><a name="wp1127065"> </a>Enumerations</li>
<li><a name="wp1127066"> </a>Unbounded strings (<code class="cCode">char*</code> passed by value)</li>
<li><a name="wp1127067"> </a>Object references (<code class="cCode">T_ptr</code>)</li>
</ul></div>
<p class="pBody"><a name="wp1127068"> </a>
For values of type T that are too large to be passed by value efficiently, two forms of the insertion function are provided:
</p>
<a name="wp1127069"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />void operator&lt;&lt;=(Any&amp;, const T&amp;);     // copying form<br />void operator&lt;&lt;=(Any&amp;, T*);            // non-copying form</code></pre></div><p class="pBody"><a name="wp1127070"> </a>
Note that the copying form is largely equivalent to the first form shown, as far as the caller is concerned.
</p>
<p class="pBody"><a name="wp1127072"> </a>
These &#8220;left-shift-assign&#8221; operators are used to insert a typed value into an <code class="cCode">any</code>, as follows:
</p>
<a name="wp1127073"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />Long value = 42;<br />Any a;<br />a &lt;&lt;= value;</code></pre></div><p class="pBody"><a name="wp1127075"> </a>
In this case, the version of <code class="cCode">operator&lt;&lt;=</code> overloaded for type <code class="cCode">Long</code> sets both the value and the TypeCode properly for the Any variable.
</p>
<p class="pBody"><a name="wp1127076"> </a>
Setting a value in an <code class="cCode">any</code> using <code class="cCode">operator&lt;&lt;=</code> means the following:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1127077"> </a>For the copying version of <code class="cCode">operator&lt;&lt;=</code>, the lifetime of the value in the Any is independent of the lifetime of the value passed to <code class="cCode">operator&lt;&lt;=</code>. The implementation of the Any does not store its value as a reference or a pointer to the value passed to <code class="cCode">operator&lt;&lt;=</code>.</li>
<li><a name="wp1127078"> </a>For the noncopying version of <code class="cCode">operator&lt;&lt;=</code>, the inserted <code class="cCode">T*</code> is consumed by the Any. The caller may not use the <code class="cCode">T*</code> to access the pointed-to data after insertion because the Any assumes ownership of T*, and the Any may immediately copy the pointed-to data and destroy the original.</li>
<li><a name="wp1127079"> </a>With both the copying and noncopying versions of<code class="cCode"> operator&lt;&lt;=</code>, any previous value held by the <code class="cCode">Any</code> is properly deallocated. For example, if the <code class="cCode">Any(TypeCode_ptr,void*,TRUE)</code> constructor (described in <a href="member.html#wp1127168">Handling Untyped Values</a>) were called to create the <code class="cCode">Any</code>, the <code class="cCode">Any</code> is responsible for deallocating the memory pointed to by the <code class="cCode">void*</code> before copying the new value.</li>
</ul></div>
<p class="pBody"><a name="wp1127084"> </a>
Copying insertion of a string type causes the following function to be invoked:
</p>
<a name="wp1127085"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />void operator&lt;&lt;=(Any&amp;, const char*);</code></pre></div><p class="pBody"><a name="wp1127086"> </a>
Since all string types are mapped to <code class="cCode">char*</code>, this insertion function assumes that the value being inserted is an unbounded string. <a href="member.html#wp1127150">Distinguishing Boolean, Octet, Char, and Bounded Strings</a> describes how bounded strings may be correctly inserted into an <code class="cCode">Any</code>. Noncopying insertion of both bounded and unbounded strings can be achieved using the <code class="cCode">Any::from_string</code> helper type described in <a href="member.html#wp1127150">Distinguishing Boolean, Octet, Char, and Bounded Strings</a>.
</p>
<p class="pBody"><a name="wp1127096"> </a>
Type-safe insertion of arrays uses the <code class="cCode">Array_forany</code> types described in <a href="member.html#wp1121164">Arrays</a>. The ORB provides a version of <code class="cCode">operator&lt;&lt;=</code> overloaded for each <code class="cCode">Array_forany</code> type. For example:
</p>
<a name="wp1127098"> </a><div class="pPreformatted"><pre><code class="cCode">// IDL<br />typedef long LongArray[4][5];</code></pre></div><a name="wp1127099"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />typedef Long LongArray[4][5];<br />typedef Long LongArray_slice[5];<br />class LongArray_forany { ... };<br /><br />void operator&lt;&lt;=(Any &amp;, const LongArray_forany &amp;);</code></pre></div><p class="pBody"><a name="wp1127100"> </a>
The <code class="cCode">Array_forany</code> types are always passed to <code class="cCode">operator&lt;&lt;=</code> by reference to <code class="cCode">const</code>. The <code class="cCode">nocopy</code> flag in the <code class="cCode">Array_forany</code> constructor is used to control whether the inserted value is copied (<code class="cCode">nocopy == FALSE</code>) or consumed (<code class="cCode">nocopy == TRUE</code>). Because the <code class="cCode">nocopy</code> flag defaults to <code class="cCode">FALSE</code>, copying insertion is the default.
</p>
<p class="pBody"><a name="wp1138351"> </a>
Because of the type ambiguity between an array of <code class="cCode">T</code> and a <code class="cCode">T*</code>, it is highly recommended that portable code explicitly use the appropriate <code class="cCode">Array_forany</code> type when inserting an array into an Any. For example:
</p>
<a name="wp1127105"> </a><div class="pPreformatted"><pre><code class="cCode">// IDL<br />struct S {... };<br />typedef S SA[5];</code></pre></div><a name="wp1127106"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />struct S { ... };<br />typedef S SA[5];<br />typedef S SA_slice;<br />class SA_forany { ... };<br /><br />SA s;<br />// ...initialize s...<br />Any a;<br />a &lt;&lt;= s;					// line 1<br />a &lt;&lt;= SA_forany(s);					// line 2</code></pre></div><p class="pBody"><a name="wp1127107"> </a>
Line 1 results in the invocation of the noncopying <code class="cCode">operator&lt;&lt;=(Any&amp;, S*)</code> due to the decay of the <code class="cCode">SA</code> array type into a pointer to its first element, rather than the invocation of the copying <code class="cCode">SA_forany</code> insertion operator. Line 2 explicitly constructs the <code class="cCode">SA_forany</code> type and thus results in the desired insertion operator being invoked.
</p>
<p class="pBody"><a name="wp1127108"> </a>
The noncopying version of <code class="cCode">operator&lt;&lt;=</code> for object references takes the address of the <code class="cCode">T_ptr</code> type, as follows:
</p>
<a name="wp1127109"> </a><div class="pPreformatted"><pre><code class="cCode">// IDL<br />interface T { ... };</code></pre></div><a name="wp1127110"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />void operator&lt;&lt;=(Any&amp;, T_ptr);							        // copying<br />void operator&lt;&lt;=(Any&amp;, T_ptr*);       							// non-copying</code></pre></div><p class="pBody"><a name="wp1127111"> </a>
The noncopying object reference insertion consumes the object reference pointed to by <code class="cCode">T_ptr*</code>; therefore, after insertion the caller may not access the object referred to by <code class="cCode">T_ptr</code> because the Any may have duplicated and then immediately released the original object reference. The caller maintains ownership of the storage for the <code class="cCode">T_ptr</code> itself.
</p>
<p class="pBody"><a name="wp1127112"> </a>
The copying version of<code class="cCode"> operator&lt;&lt;=</code> is also supported on the <code class="cCode">Any_var</code> type.
</p>
<h4 class="pHeading3"><a name="wp1127114"> </a>
Extraction from Any
</h4>
<p class="pBody"><a name="wp1127116"> </a>
To allow type-safe retrieval of a value from an <code class="cCode">any</code>, the ORB provides the following operators for each OMG IDL type T:
</p>
<a name="wp1127117"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />Boolean operator&gt;&gt;=(const Any&amp;, T&amp;);</code></pre></div><p class="pBody"><a name="wp1127118"> </a>
This function signature suffices for primitive types that are usually passed by value. For values of type T that are too large to be passed by value efficiently, the ORB provides a different signature, as follows:
</p>
<a name="wp1127119"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />Boolean operator&gt;&gt;=(const Any&amp;, T*&amp;);</code></pre></div><p class="pBody"><a name="wp1127120"> </a>
The first form of this function is used only for the following types:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1127121"> </a><code class="cCode">Boolean, Char, Octet, Short, UShort, Long, ULong, Float, Double</code></li>
<li><a name="wp1127122"> </a>Enumerations</li>
<li><a name="wp1127123"> </a>Unbounded strings (<code class="cCode">char*</code> passed by reference, i.e., <code class="cCode">char*&amp;</code>)</li>
<li><a name="wp1127124"> </a>Object references (<code class="cCode">T_ptr</code>)</li>
</ul></div>
<p class="pBody"><a name="wp1127125"> </a>
For all other types, the second form of the function is used.
</p>
<p class="pBody"><a name="wp1127129"> </a>
This &#8220;right-shift-assign&#8221; operator is used to extract a typed value from an <code class="cCode">any,</code> as follows:
</p>
<a name="wp1127130"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />Long value;<br />Any a;<br />a &lt;&lt;= Long(42);<br />if (a &gt;&gt;= value) {<br />     	// ... use the value ...<br />}</code></pre></div><p class="pBody"><a name="wp1127131"> </a>
In this case, the version of <code class="cCode">operator&gt;&gt;=</code> for type <code class="cCode">Long</code> determines whether the Any truly does contain a value of type <code class="cCode">Long</code> and, if so, copies its value into the reference variable provided by the caller and returns <code class="cCode">TRUE</code>. If the Any does not contain a value of type <code class="cCode">Long</code>, the value of the caller&#8217;s reference variable is not changed, and <code class="cCode">operator&gt;&gt;=</code> returns <code class="cCode">FALSE</code>.
</p>
<p class="pBody"><a name="wp1127133"> </a>
For nonprimitive types, extraction is done by pointer. For example, consider the following OMG IDL struct:
</p>
<a name="wp1127134"> </a><div class="pPreformatted"><pre><code class="cCode">// IDL<br />struct MyStruct {<br />    long lmem;<br />    short smem;<br />};</code></pre></div><p class="pBody"><a name="wp1127135"> </a>
Such a struct could be extracted from an Any as follows:
</p>
<a name="wp1127136"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />Any a;<br />// ... a is somehow given a value of type MyStruct ...<br />MyStruct *struct_ptr;<br />if (a &gt;&gt;= struct_ptr) {<br />     	// ... use the value ...<br />}</code></pre></div><p class="pBody"><a name="wp1127137"> </a>
If the extraction is successful, the caller&#8217;s pointer points to storage managed by the Any, and <code class="cCode">operator&gt;&gt;=</code> returns <code class="cCode">TRUE</code>. The caller must not try to <code class="cCode">delete</code> or otherwise release this storage. The caller also should not use the storage after the contents of the Any variable are replaced via assignment, insertion, or the <code class="cCode">replace</code> function, or after the Any variable is destroyed. Care must be taken to avoid using <code class="cCode">T_var</code> types with these extraction operators, since they will try to assume responsibility for deleting the storage owned by the Any.
</p>
<p class="pBody"><a name="wp1127139"> </a>
If the extraction is not successful, the value of the caller&#8217;s pointer is set equal to the NULL pointer, and <code class="cCode">operator&gt;&gt;=</code> returns <code class="cCode">FALSE</code>.
</p>
<p class="pBody"><a name="wp1127142"> </a>
Correct extraction of array types relies on the <code class="cCode">Array_forany</code> types described in <a href="member.html#wp1121164">Arrays</a>.
</p>
<p class="pBody"><a name="wp1140772"> </a>
An example of the OMG IDL is as follows:
</p>
<a name="wp1127144"> </a><div class="pPreformatted"><pre><code class="cCode">// IDL<br />typedef long A[20];<br />typedef A B[30][40][50];</code></pre></div><a name="wp1127145"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />typedef Long A[20];<br />typedef Long A_slice;<br />class A_forany { ... };<br />typedef A B[30][40][50];<br />typedef A B_slice[40][50];<br />class B_forany { ... };<br /><br />Boolean operator&gt;&gt;=(const Any&amp;, A_forany&amp;);																		     // for type A<br />Boolean operator&gt;&gt;=(const Any&amp;, B_forany&amp;);     																		// for type B</code></pre></div><p class="pBody"><a name="wp1127146"> </a>
The <code class="cCode">Array_forany</code> types are always passed to <code class="cCode">operator&gt;&gt;=</code> by reference.
</p>
<p class="pBody"><a name="wp1127147"> </a>
For strings and arrays, applications are responsible for checking the TypeCode of the Any to be sure that they do not overstep the bounds of the array or string object when using the extracted value.
</p>
<p class="pBody"><a name="wp1127148"> </a>
The <code class="cCode">operator&gt;&gt;=</code> is also supported on the <code class="cCode">Any_var</code> type.
</p>
<h4 class="pHeading3"><a name="wp1127150"> </a>
Distinguishing Boolean, Octet, Char, and Bounded Strings
</h4>
<p class="pBody"><a name="wp1127151"> </a>
Since the Boolean, octet, and char OMG IDL types are not required to map to distinct C++ types, another means of distinguishing them from each other is necessary so that they can be used with the type-safe Any interface. Similarly, since both bounded and unbounded strings map to <code class="cCode">char*</code>, another means of distinguishing them must be provided. This is done by introducing several new helper types nested in the Any class interface. For example, this is accomplished as shown below:
</p>
<a name="wp1127153"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />class Any<br />{<br />  public:<br />    // special helper types needed for boolean, octet,<br />    // char, and bounded string insertion<br />    struct from_boolean {<br />        from_boolean(Boolean b) : val(b) {}<br />        Boolean val;<br />    };<br />    struct from_octet {<br />        from_octet(Octet o) : val(o) {}<br />        Octet val;<br />    };<br />    struct from_char {<br />       from_char(Char c) : val(c) {}<br />       Char val;<br />    };<br />    struct from_string {<br />       from_string(char* s, ULong b,<br />                 Boolean nocopy = FALSE) :<br />            val(s), bound(b) {}<br />       char *val;<br />       ULong bound;<br />    };</code></pre></div><a name="wp1155424"> </a><div class="pPreformatted"><pre><code class="cCode">    void operator&lt;&lt;=(from_boolean);<br />    void operator&lt;&lt;=(from_char);<br />    void operator&lt;&lt;=(from_octet);<br />    void operator&lt;&lt;=(from_string);<br />    // special helper types needed for boolean, octet,<br />    // char, and bounded string extraction<br />    struct to_boolean {<br />        to_boolean(Boolean &amp;b) : ref(b) {}<br />        Boolean &amp;ref;<br />    };<br />    struct to_char {<br />        to_char(Char &amp;c) : ref(c) {}<br />        Char &amp;ref;<br />    };<br />    struct to_octet {<br />        to_octet(Octet &amp;o) : ref(o) {}<br />        Octet &amp;ref;<br />    };<br />    struct to_string {<br />        to_string(char *&amp;s, ULong b) : val(s), bound(b) {}<br />        char *&amp;val;<br />        ULong bound;<br />    };</code></pre></div><a name="wp1155425"> </a><div class="pPreformatted"><pre><code class="cCode">    Boolean operator&gt;&gt;=(to_boolean) const;<br />    Boolean operator&gt;&gt;=(to_char) const;<br />    Boolean operator&gt;&gt;=(to_octet) const;<br />    Boolean operator&gt;&gt;=(to_string) const;</code></pre></div><a name="wp1155426"> </a><div class="pPreformatted"><pre><code class="cCode">    // other public Any details omitted</code></pre></div><a name="wp1155427"> </a><div class="pPreformatted"><pre><code class="cCode">private:<br />    // these functions are private and not implemented<br />    // hiding these causes compile-time errors for<br />    // unsigned char<br />    void operator&lt;&lt;=(unsigned char);<br />    Boolean operator&gt;&gt;=(unsigned char &amp;) const;<br />};</code></pre></div><p class="pBody"><a name="wp1127154"> </a>
The ORB provides the overloaded <code class="cCode">operator&lt;&lt;=</code> and <code class="cCode">operator&gt;&gt;=</code> functions for these special helper types. These helper types are used as shown here:
</p>
<a name="wp1127155"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />Boolean b = TRUE;<br />Any any;<br />any &lt;&lt;= Any::from_boolean(b);<br />// ...<br />if (any &gt;&gt;= Any::to_boolean(b)) {<br />     // ...any contained a Boolean...<br />}<br /><br />char* p = &quot;bounded&quot;;<br />any &lt;&lt;= Any::from_string(p, 8);<br />// ...<br />if (any &gt;&gt;= Any::to_string(p, 8)) {<br />     // ...any contained a string&lt;8&gt;...<br />}</code></pre></div><p class="pBody"><a name="wp1127156"> </a>
A bound value of 0 (zero) indicates an unbounded string.
</p>
<p class="pBody"><a name="wp1127157"> </a>
For noncopying insertion of a bounded or unbounded string into an Any, the <code class="cCode">nocopy</code> flag on the <code class="cCode">from_string</code> constructor should be set to <code class="cCode">TRUE</code>:
</p>
<a name="wp1127158"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />char* p = string_alloc(8);<br />// ...initialize string p...<br />any &lt;&lt;= Any::from_string(p, 8, 1);	      // any consumes p</code></pre></div><p class="pBody"><a name="wp1127159"> </a>
Assuming that boolean, char, and octet all map the C++ type <code style="font-weight: normal" class="cCode">unsigned</code><span style="font-weight: bold"> </span><code class="cCode">char</code>, the private and unimplemented <code class="cCode">operator&lt;&lt;=</code> and <code class="cCode">operator&gt;&gt;= </code>functions for <code style="font-weight: normal" class="cCode">unsigned</code><span style="font-weight: bold"> </span><code class="cCode">char</code> cause a compile-time error if straight insertion or extraction of any of the boolean, char, or octet types is attempted:
</p>
<a name="wp1127160"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />Octet oct = 040;<br />Any any;<br />any &lt;&lt;= oct;                      // this line will not compile<br />any &lt;&lt;= Any::from_octet(oct);      // but this one will</code></pre></div><h4 class="pHeading3"><a name="wp1127162"> </a>
Widening to Object
</h4>
<p class="pBody"><a name="wp1127163"> </a>
Sometimes it is desirable to extract an object reference from an Any as the base Object type. This can be accomplished using a helper type similar to those required for extracting boolean, char, and octet:
</p>
<a name="wp1127164"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />class Any<br />{<br />  public:<br />    ...<br />    struct to_object {<br />        to_object(Object_ptr &amp;obj) : ref(obj) {}<br />        Object_ptr &amp;ref;<br />    ;<br />    Boolean operator&gt;&gt;=(to_object) const;<br />    ...<br />};</code></pre></div><p class="pBody"><a name="wp1127165"> </a>
The <code class="cCode">to_object</code> helper type is used to extract an object reference from an Any as the base Object type. If the Any contains a value of an object reference type as indicated by its TypeCode, the extraction function <code class="cCode">operator&gt;&gt;=(to_object)</code> explicitly widens its contained object reference to Object and returns <code class="cCode">TRUE</code>; otherwise, it returns FALSE. This is the only object reference extraction function that performs widening on the extracted object reference. As with regular object reference extraction, no duplication of the object reference is performed by the<code class="cCode"> to_object</code> extraction operator.
</p>
<h4 class="pHeading3"><a name="wp1127168"> </a>
Handling Untyped Values
</h4>
<p class="pBody"><a name="wp1127169"> </a>
Under some circumstances the type-safe interface to Any is not sufficient. An example is a situation in which data types are read from a file in binary form and are used to create values of type Any. For these cases, the Any class provides a constructor with an explicit TypeCode and generic pointer:
</p>
<p class="pBody"><a name="wp1127171"> </a>
<code class="cCode">// C++<br />Any(TypeCode_ptr tc, void *value, Boolean release = FALSE);</code>
</p>
<p class="pBody"><a name="wp1127172"> </a>
The constructor duplicates the given TypeCode pseudo-object reference. If the <code class="cCode">release</code> parameter is <code class="cCode">TRUE</code>, the Any object assumes ownership of the storage pointed to by the <code class="cCode">value</code> parameter. A caller should make no assumptions about the continued lifetime of the <code class="cCode">value</code> parameter once it has been handed to an Any with <code class="cCode">release=TRUE</code>, since the Any may copy the <code class="cCode">value</code> parameter and immediately free the original pointer. If the <code class="cCode">release</code> parameter is <code class="cCode">FALSE</code> (the default case), the Any object assumes that the caller manages the memory pointed to by <code class="cCode">value</code>. The <code class="cCode">value</code> parameter can be a NULL pointer.
</p>
<p class="pBody"><a name="wp1127174"> </a>
The Any class also defines three unsafe operations:
</p>
<a name="wp1127175"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />void replace(<br />    TypeCode_ptr,<br />    void *value,<br />    Boolean release = FALSE<br />);<br />TypeCode_ptr type() const;<br />const void *value() const;</code></pre></div><p class="pBody"><a name="wp1127177"> </a>
The <code class="cCode">replace</code> function is intended to be used with types that cannot be used with the type-safe insertion interface, and so is similar to the constructor described above. The existing TypeCode is released and value storage is deallocated, if necessary. The TypeCode<span style="font-weight: bold"> </span>function parameter is duplicated. If the <code class="cCode">release</code> parameter is <code class="cCode">TRUE</code>, the Any object assumes ownership for the storage pointed to by the <code class="cCode">value</code> parameter. The Any should make no assumptions about the continued lifetime of the<code class="cCode"> value</code> parameter once it has been handed to the <code class="cCode">Any::replace</code> function with <code class="cCode">release=TRUE</code>, since the Any may copy the <code class="cCode">value</code> parameter and immediately free the original pointer. If the <code class="cCode">release</code> parameter is <code class="cCode">FALSE</code> (the default case), the Any object assumes that the caller manages the memory occupied by the value. The <code class="cCode">value</code> parameter of the <code class="cCode">replace</code> function can be a NULL pointer.
</p>
<p class="pBody"><a name="wp1127180"> </a>
Note that neither the constructor shown above nor the <code class="cCode">replace</code> function is type-safe. In particular, no guarantees are made by the compiler at run time as to the consistency between the TypeCode and the actual type of the <code style="font-style: normal" class="cCode">void*</code><span style="font-style: italic"> </span>argument. The behavior of an ORB implementation when presented with an <code class="cCode">Any</code> that is constructed with a mismatched TypeCode and value is not defined.
</p>
<p class="pBody"><a name="wp1127182"> </a>
The <code class="cCode">type</code> function returns a<code class="cCode"> TypeCode_ptr</code> pseudo-object reference to the TypeCode associated with the Any. Like all object reference return values, the caller must release the reference when it is no longer needed, or assign it to a <code class="cCode">TypeCode_var</code> variable for automatic management.
</p>
<p class="pBody"><a name="wp1127184"> </a>
The <code class="cCode">value</code> function returns a pointer to the data stored in the Any. If the Any has no associated value, the <code class="cCode">value</code> function returns a NULL pointer.
</p>
<h4 class="pHeading3"><a name="wp1127186"> </a>
Any Constructors, Destructor, Assignment Operator
</h4>
<p class="pBody"><a name="wp1127187"> </a>
The default constructor creates an Any with a TypeCode of type <code class="cCode">tk_null</code>, and no value. The copy constructor calls <code class="cCode">_duplicate</code> on the <code class="cCode">TypeCode_ptr</code> of its Any parameter and deep-copies the parameter&#8217;s value. The assignment operator releases its own <code class="cCode">TypeCode_ptr</code> and deallocates storage for the current value if necessary, then duplicates the <code class="cCode">TypeCode_ptr</code> of its Any parameter and deep-copies the parameter&#8217;s value. The destructor calls <code class="cCode">release</code> on the <code class="cCode">TypeCode_ptr</code> and deallocates storage for the value, if necessary.
</p>
<p class="pBody"><a name="wp1127192"> </a>
Other constructors are described in the section <a href="member.html#wp1127168">Handling Untyped Values</a>.
</p>
<h4 class="pHeading3"><a name="wp1127198"> </a>
 The Any Class
</h4>
<p class="pBody"><a name="wp1128486"> </a>
The full definition of the Any class can be found in the section <a href="corba_api.html#wp1033362">Any Class Member Functions</a>.
</p>
<h3 class="pHeading2"><a name="wp1165186"> </a>
Value Type
</h3>
<p class="pBody"><a name="wp1165187"> </a>
This section is based on information contained in Chapters 3, 5, and 6 of the <em class="cEmphasis">Common Object Request Broker: Architecture and Specification</em>, Revision 2.4.2, February 2001, and the <em class="cEmphasis">CORBA C++ Language Mapping Specification</em>, June 1999, published by the Object Management Group (OMG). Used with permission of the OMG.
</p>
<h4 class="pHeading3"><a name="wp1165188"> </a>
Overview
</h4>
<p class="pBody"><a name="wp1165189"> </a>
Objects, more specifically, interface types that objects support, are defined in an IDL interface, allowing arbitrary implementations. There is great value in having a distributed object system that places almost no constraints on implementation. However, there are many occasions in which it is desirable to be able to pass an object by value, rather than by reference. This may be particularly useful when an object&#8217;s primary &#8220;purpose&#8221; is to encapsulate data, or an application explicitly wishes to make a &#8220;copy&#8221; of an object.
</p>
<p class="pBody"><a name="wp1165190"> </a>
The semantics of passing an object by value are similar to that of standard programming languages. The receiving side of a parameter passed by value receives a description of the &#8220;state&#8221; of the object. It then instantiates a new instance with that state but having a separate identity from that of the sending side. Once the parameter passing operation is complete, no relationship is assumed to exist between the two instances. 
</p>
<p class="pBody"><a name="wp1165191"> </a>
Because it is necessary for the receiving side to instantiate an instance, it must necessarily know something about the object&#8217;s state and implementation. Thus, valuetype(s) provide semantics that bridge between CORBA structs and CORBA interfaces, as follows:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1165192"> </a>They support description of complex state (that is, arbitrary graphs, with recursion and cycles).</li>
<li><a name="wp1165193"> </a>Their instances are always local to the context in which they are used (because they are always copied when passed as a parameter to a remote call).</li>
<li><a name="wp1165194"> </a>They support both public and private (to the implementation) data members.</li>
<li><a name="wp1165195"> </a>They can be used to specify the state of an object implementation (that is, they can support an interface).</li>
<li><a name="wp1165196"> </a>They support single inheritance (of valuetype) and can support an interface.</li>
<li><a name="wp1165197"> </a>They may be also be abstract.</li>
</ul></div>
<h4 class="pHeading3"><a name="wp1165198"> </a>
Architecture
</h4>
<p class="pBody"><a name="wp1165199"> </a>
The basic notion of valuetypes is relatively simple. A valuetype is, in some sense, half way between a &#8220;regular&#8221; IDL interface type and a struct. The use of valuetype is a signal from the application programmer that some additional properties (state) and implementation details be specified beyond that of an interface type. Specification of this information puts some additional constraints on the implementation choices beyond that of interface types. This is reflected in both the semantics specified herein, and in the language mappings.
</p>
<h4 class="pHeading3"><a name="wp1165200"> </a>
Benefits
</h4>
<p class="pBody"><a name="wp1165201"> </a>
Prior to supporting valuetypes (objects passable by value), all CORBA objects had object references. When multiple clients invoked on a particular object, they use the same object reference. The instance(s) of the object remained on the server ORB and its state was maintained by the server ORB, not the client ORB. 
</p>
<p class="pBody"><a name="wp1165202"> </a>
Valuetypes represent a significant addition to the CORBA architecture. As with objects passed by reference, valuetypes have state and methods, but do not have object references and are always invoked locally as programming language objects. Upon request from the receiving side, valuetypes package their state in the sending context, send their state &#8220;over the wire&#8221; to the receiving side, where an instance is created and populated with the transmitted state. The sending side has no further control of the client-side instance. Thus, the receiving side can make subsequent invocations of the instance locally. This model eliminates the delays involved when communicating over the network. These delays can be significant in large networks. The addition of valuetypes enables CORBA implementations to more easily scale to meet large data-handling requirements. 
</p>
<p class="pBody"><a name="wp1165203"> </a>
Therefore, an essential property of valuetypes is that their implementations are always local. That is, the explicit use of valuetypes in a concrete programming language is always guaranteed to use a local implementation, and will not require a remote call. They have no identity (their value is their identity) and they are not &#8220;registered&#8221; with the ORB.
</p>
<h4 class="pHeading3"><a name="wp1165205"> </a>
Valuetype Example
</h4>
<p class="pBody"><a name="wp1165206"> </a>
For example, consider the following IDL valuetype taken from the <em class="cEmphasis">CORBA C++ Language Mapping Specification</em>, June 1999, published by the Object Management Group (OMG):
</p>
<a name="wp1165207"> </a><div class="pPreformatted"><pre><code class="cCode">// IDL<br />valuetype Example {<br />      short op1();<br />      long op2(in Example x);<br />      private short val1;<br />      public long val2;</code></pre></div><a name="wp1165208"> </a><div class="pPreformatted"><pre><code class="cCode">      private string val3;<br />      private float val4;<br />      private Example val5;<br />};</code></pre></div><a name="wp1165209"> </a><div class="pPreformatted"><pre><code class="cCode">The C++ mapping for this valuetype is:</code></pre></div><a name="wp1165210"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />class Example : public virtual ValueBase {<br />   public:<br />      virtual Short op1() = 0;<br />      virtual Long op2(Example*) = 0;</code></pre></div><a name="wp1165211"> </a><div class="pPreformatted"><pre><code class="cCode">      virtual Long val2() const = 0;<br />      virtual void val2(Long) = 0;</code></pre></div><a name="wp1165212"> </a><div class="pPreformatted"><pre><code class="cCode">      static Example* _downcast(ValueBase*);</code></pre></div><a name="wp1165213"> </a><div class="pPreformatted"><pre><code class="cCode">   protected:<br />      Example();<br />      virtual ~Example();</code></pre></div><a name="wp1165214"> </a><div class="pPreformatted"><pre><code class="cCode">      virtual Short val1() const = 0;<br />      virtual void val1(Short) = 0;</code></pre></div><a name="wp1165215"> </a><div class="pPreformatted"><pre><code class="cCode">      virtual const char* val3() const = 0;<br />      virtual void val3(char*) = 0;<br />      virtual void val3(const char*) = 0;<br />      virtual void val3(const String_var&amp;) = 0;</code></pre></div><a name="wp1165216"> </a><div class="pPreformatted"><pre><code class="cCode">      virtual Float val4() const = 0;<br />      virtual void val4(Float) = 0;</code></pre></div><a name="wp1165217"> </a><div class="pPreformatted"><pre><code class="cCode">      virtual Example* val5() const = 0;<br />      virtual void val5(Example*) = 0;</code></pre></div><a name="wp1165218"> </a><div class="pPreformatted"><pre><code class="cCode">   private:<br />      // private and unimplemented<br />      void operator=(const Example&amp;);<br />};</code></pre></div><a name="wp1165219"> </a><div class="pPreformatted"><pre><code class="cCode">class OBV_Example : public virtual Example {<br />   public:<br />      virtual Long val2() const;<br />      virtual void val2(Long);</code></pre></div><a name="wp1165220"> </a><div class="pPreformatted"><pre><code class="cCode">   protected:<br />      OBV_Example();<br />      OBV_Example(Short init_val1, Long init_val2,<br />                const char* init_val3, Float init_val4,<br />                Example* init_val5);<br />      virtual ~OBV_Example();</code></pre></div><a name="wp1165221"> </a><div class="pPreformatted"><pre><code class="cCode">      virtual Short val1() const;<br />      virtual void val1(Short);</code></pre></div><a name="wp1165222"> </a><div class="pPreformatted"><pre><code class="cCode">      virtual const char* val3() const;<br />      virtual void val3(char*);<br />      virtual void val3(const char*);<br />      virtual void val3(const String_var&amp;);</code></pre></div><a name="wp1165223"> </a><div class="pPreformatted"><pre><code class="cCode">      virtual Float val4() const;<br />      virtual void val4(Float);</code></pre></div><a name="wp1165224"> </a><div class="pPreformatted"><pre><code class="cCode">      virtual Example* val5() const;<br />      virtual void val5(Example*);</code></pre></div><a name="wp1165225"> </a><div class="pPreformatted"><pre><code class="cCode">      // ...<br />};</code></pre></div><p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1128492"> </a>
Fixed-length Versus Variable-length User-defined Types
</h2><p class="pBody"><a name="wp1009905"> </a>
The memory management rules and member function signatures for a user-defined type depend upon whether the type is fixed-length or variable-length. A user-defined type is variable-length if it is one of the following:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1009907"> </a>A bounded or unbounded string</li>
<li><a name="wp1009908"> </a>A bounded or unbounded sequence</li>
<li><a name="wp1009910"> </a>A struct or union that contains a variable-length member</li>
<li><a name="wp1009911"> </a>An array with a variable-length element type</li>
<li><a name="wp1009912"> </a>A typedef to a variable-length type</li>
</ul></div>
<p class="pBody"><a name="wp1009913"> </a>
If a type is not on this list, the type is fixed-length.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1009915"> </a>
Using var Classes
</h2><p class="pBody"><a name="wp1009916"> </a>
Automatic variables (vars) are provided to simplify memory management. Vars are provided through a var class that assumes ownership for the memory required for the type and frees the memory when the instance of the var object is destroyed or when a new value is assigned to the var object.
</p>
<p class="pBody"><a name="wp1009917"> </a>
The Oracle Tuxedo provides var classes for the following types:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1009918"> </a>String (CORBA::String_var)</li>
<li><a name="wp1009920"> </a>Object references (CORBA::Object_var)</li>
<li><a name="wp1009925"> </a>User-defined OMG IDL types (<code class="cCode">struct</code>, <code class="cCode">union</code>, <code class="cCode">sequence</code>, <code class="cCode">array</code>, and<code class="cCode"> interface</code>)</li>
</ul></div>
<p class="pBody"><a name="wp1009926"> </a>
The var classes have common member functions, but may support additional operators depending upon the OMG IDL type. For an OMG IDL type <span style="font-style: normal">TYPE</span>, the<em style="font-style: italic" class="cEmphasis"> </em><span style="font-style: normal">TYPE_</span>var class contains constructors, destructors, assignment operators, and operators to access the underlying <span style="font-style: normal">TYPE</span> type. An example var class is as follows:
</p>
<a name="wp1009927"> </a><div class="pPreformatted"><pre><code class="cCode">class TYPE_var<br />    { <br />    public:<br />        // constructors<br />        TYPE_var();<br />        TYPE_var(TYPE *);<br />        TYPE_var(const TYPE_var &amp;);<br />        // destructor<br />        ~TYPE_var();<br /><br />        // assignment operators<br />        TYPE_var &amp;operator=(TYPE *);<br />        TYPE_var &amp;operator=(const TYPE_var &amp;);<br /><br />        // accessor operators<br />        TYPE *operator-&gt;();<br />        TYPE *operator-&gt;() const;</code></pre></div><a name="wp1155482"> </a><div class="pPreformatted"><pre><code class="cCode">        TYPE_var_ptr in() const; <br />        TYPE_var_ptr&amp; inout(); <br />        TYPE_var_ptr&amp; out();</code></pre></div><a name="wp1155463"> </a><div class="pPreformatted"><pre><code class="cCode">        TYPE_var_ptr _retn();<br />        operator const TYPE_ptr&amp;() const;<br />        operator TYPE_ptr&amp;();<br />    </code>    operator TYPE_ptr;<br />        };</pre></div><p class="pBody"><a name="wp1139498"> </a>
The details of the member functions are as follows:
</p>
<h4 class="pDefTerm"><a name="wp1009932"> </a>
<code class="cCode">TYPE_var() </code>
</h4><div class="pDefPara"><a name="wp1009933"> </a>
This is the default constructor for the <code class="cCode">TYPE_var</code> class. The constructor initializes to 0 (zero) the <code class="cCode">TYPE *</code> owned by the var class. You may not invoke the operator-&gt; on a <code class="cCode">TYPE_var</code> class unless a valid <code style="font-style: normal" class="cCode">TYPE *</code><span style="font-style: oblique"> </span>has been assigned to it.
</div>
<h4 class="pDefTerm"><a name="wp1009934"> </a>
<code class="cCode">TYPE_var(TYPE * Value);</code> 
</h4><div class="pDefPara"><a name="wp1009935"> </a>
This constructor assumes ownership of the specified <span style="font-style: normal">TYPE *</span> parameter. When the <span style="font-style: normal">TYPE_</span>var is destroyed, the <span style="font-style: normal">TYPE</span> is released. The <code class="cCode">Value</code> argument is a pointer to the <span style="font-style: normal">TYPE</span> to be owned by this var class. This pointer must not be 0 (zero).
</div>
<h4 class="pDefTerm"><a name="wp1009936"> </a>
<code class="cCode">TYPE_var(const TYPE_var &amp; From);</code> 
</h4><div class="pDefPara"><a name="wp1009937"> </a>
This copy constructor allocates a new <span style="font-style: normal">TYPE</span> and makes a deep copy of the data contained in the <span style="font-style: normal">TYPE</span> owned by the <code class="cCode">From</code> parameter. When the <span style="font-style: normal">TYPE_</span>var is destroyed, the copy of the <span style="font-style: normal">TYPE</span> is released or deleted. The <code class="cCode">From</code> parameter specifies the var class that points to the <span style="font-style: normal">TYPE</span> to be copied.
</div>
<h4 class="pDefTerm"><a name="wp1009938"> </a>
<code class="cCode">~TYPE_var(); </code>
</h4><div class="pDefPara"><a name="wp1009939"> </a>
This destructor uses the appropriate mechanism to release the <span style="font-style: normal">TYPE</span> owned by the var class. For strings, this is the <code class="cCode">CORBA::string_free</code> routine. For object references, this is the<code class="cCode"> CORBA::release </code>routine. For other types, this may be <code class="cCode">delete</code> or a generated static routine used to free allocated memory.
</div>
<h4 class="pDefTerm"><a name="wp1009940"> </a>
<code class="cCode">TYPE_var &amp;operator=(TYPE * NewValue); </code>
</h4><div class="pDefPara"><a name="wp1009941"> </a>
This assignment operator assumes ownership of the <span style="font-style: normal">TYPE</span> pointed to by the <code class="cCode">NewValue</code> parameter. If the <span style="font-style: normal">TYPE_</span>var currently owns a <span style="font-style: normal">TYPE</span>, it is released before assuming ownership of the <code class="cCode">NewValue</code> parameter. The <code class="cCode">NewValue</code> argument is a pointer to the <span style="font-style: normal">TYPE</span> to be owned by this var class. This pointer must not be 0 (zero).
</div>
<h4 class="pDefTerm"><a name="wp1009942"> </a>
<code class="cCode">TYPE_var &amp;operator=(const TYPE_var &amp;From); </code>
</h4><div class="pDefPara"><a name="wp1009943"> </a>
This assignment operator allocates a new <span style="font-style: normal">TYPE</span> and makes a deep copy of the data contained in the <span style="font-style: normal">TYPE</span> owned by the <code class="cCode">From</code> <span style="font-style: normal">TYPE_</span>var parameter. If <span style="font-style: normal">TYPE_</span>var currently owns a <span style="font-style: normal">TYPE</span>, it is released. When the <span style="font-style: normal">TYPE_</span>var is destroyed, the copy of the <span style="font-style: normal">TYPE</span> is released. The <code class="cCode">From</code> parameter specifies the var class that points to the data to be copied.
</div>
<h4 class="pDefTerm"><a name="wp1009944"> </a>
<code class="cCode">TYPE *operator-&gt;(); <br />TYPE *operator-&gt;() const; </code>
</h4><div class="pDefPara"><a name="wp1009945"> </a>
These operators return a pointer to the <span style="font-style: normal">TYPE</span> owned by the var class. The var class continues to own the <span style="font-style: normal">TYPE</span> and it is the responsibility of the var class to release <span style="font-style: normal">TYPE</span>. You cannot use the <code class="cCode">operator-&gt;</code> until the var owns a valid <span style="font-style: normal">TYPE</span>. Do not try to release this return value or access this return value after the <span style="font-style: normal">TYPE_var</span> has been destroyed.
</div>
<h4 class="pDefTerm"><a name="wp1139502"> </a>
<code class="cCode">TYPE_var_ptr in() const;<br />TYPE_var_ptr&amp; inout();<br />TYPE_var_ptr&amp; out();<br />TYPE_var_ptr _retn();</code>
</h4><div class="pDefPara"><a name="wp1139504"> </a>
Because implicit conversions can sometimes cause a problem with some C++ compilers and with code readability, the <span style="font-style: normal">TYPE</span>_var types also support member functions that allow them to be explicitly converted for purposes of parameter passing. To pass a<em style="font-style: italic" class="cEmphasis"> </em><span style="font-style: normal">TYPE</span>_var and an <code class="cCode">in</code> parameter, call the <code class="cCode">in()</code> member function; for <code class="cCode">inout</code> parameters, the <code class="cCode">inout()</code> member function; for <code class="cCode">out</code> parameters, the <code class="cCode">out()</code> member function. To obtain a return value from the <span style="font-style: normal">TYPE</span>_var, call the <code class="cCode">_return()</code> function. For each <code class="cCode">TYPE</code>_var type, the return types of each of these functions will match the type shown in <a href="member.html#wp1167840">Table&#160;13-7</a> for the <code class="cCode">in</code>, <code class="cCode">inout</code>, <code class="cCode">out</code>, and return modes for the underlying type <span style="font-style: normal">TYPE,</span> respectively.
</div>
<p class="pBody"><a name="wp1138684"> </a>
Some differences occur in the operators supported for the user-defined data types. <a href="member.html#wp1154616">Table&#160;13-3</a> describes the various operators supported by each OMG IDL data type, in the generated C++ code. Because the assignment operators are supported for all of the data types described in <a href="member.html#wp1154616">Table&#160;13-3</a>, they are not included in the comparison.
</p>
<p class="pGraphic"><a name="wp1154613"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1154616table1154614"><caption><a name="wp1154616"> </a>
Table 13-3  &#160;Comparison of Operators Supported for User-defined Data Type var Classes

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1154693"> </a>
OMG IDL Data Type
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1154695"> </a>
operator -&gt;
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1154697"> </a>
operator[ ]
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154699"> </a>
<code class="cCode">struct</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154701"> </a>
Yes
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154703"> </a>
No
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154705"> </a>
<code class="cCode">union</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154707"> </a>
Yes
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154709"> </a>
No
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154711"> </a>
<code class="cCode">sequence</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154713"> </a>
Yes
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154715"> </a>
Yes, non-const only
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154717"> </a>
<code class="cCode">array</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154719"> </a>
No
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154721"> </a>
Yes
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<p class="pBody"><a name="wp1138731"> </a>
The signatures are as shown in <a href="member.html#wp1154832">Table&#160;13-4</a>.
</p>
<p class="pGraphic"><a name="wp1154829"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1154832table1154830"><caption><a name="wp1154832"> </a>
Table 13-4  Operator Signatures for _var Classes

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1154891"> </a>
OMG IDL Data Type
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1154893"> </a>
Operator Member Functions
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154899"> </a>
<code class="cCode">struct</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154901"> </a>
<span style="font-style: normal">TYPE</span><code style="font-style: normal" class="cCode"> * operator-&gt; ()   <br /></code><span style="font-style: normal">TYPE</span><code class="cCode"> * operator-&gt; () const</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154903"> </a>
<code class="cCode">union</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154905"> </a>
<span style="font-style: normal">TYPE</span><code style="font-style: normal" class="cCode"> * operator-&gt; ()   <br /></code><span style="font-style: normal">TYPE</span><code class="cCode"> * operator-&gt; () const</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154907"> </a>
<code class="cCode">sequence</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154909"> </a>
<span style="font-style: normal">TYPE</span><code style="font-style: normal" class="cCode"> * operator-&gt; ()   <br /></code><span style="font-style: normal">TYPE</span><code style="font-style: normal" class="cCode"> * operator-&gt; () const   <br /></code><span style="font-style: normal">TYPE</span><code class="cCode"> &amp; operator[](CORBA::Long index)</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154911"> </a>
<code class="cCode">array</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1154913"> </a>
<span style="font-style: normal">TYPE</span><code style="font-style: normal" class="cCode">_slice &amp; operator[](CORBA::Long index)   </code><span style="font-style: normal">TYPE</span><code class="cCode">_slice &amp; operator[](CORBA::Long index) const</code>
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<h3 class="pHeading2"><a name="wp1162851"> </a>
Sequence vars
</h3>
<p class="pBody"><a name="wp1009948"> </a>
Sequence vars support the following additional operator[] member function:
</p>
<h4 class="pDefTerm"><a name="wp1009949"> </a>
<code class="cCode">TYPE &amp;operator[](CORBA::ULong Index); </code>
</h4><div class="pDefPara"><a name="wp1009950"> </a>
This operator invokes the <code class="cCode">operator[]</code> of sequence owned by the var class. The<code class="cCode"> operator[]</code> returns a reference to the appropriate element of the sequence at the specified index. The <code class="cCode">Index</code> argument specifies the index of the element to return. This index cannot be greater than the current sequence length.
</div>
<h3 class="pHeading2"><a name="wp1009951"> </a>
Array vars
</h3>
<p class="pBody"><a name="wp1009952"> </a>
Array vars do not support operator-&gt;, but do support the following additional operator[] member functions to access the array elements:
</p>
<h4 class="pDefTerm"><a name="wp1009953"> </a>
<code class="cCode">TYPE_slice&amp; operator[](CORBA::ULong Index); <br />const TYPE_slice &amp; operator[](CORBA::ULong Index) const; </code>
</h4><div class="pDefPara"><a name="wp1092412"> </a>
These operators return a reference to the array slice at the specified index. An array slice is an array with all the dimensions of the original array except the first dimension. The member functions for the array-generated classes use a pointer to a slice to return pointers to an array. The <code class="cCode">Index</code> argument specifies the index of the slice to return. This index cannot be greater than the array dimension.
</div>
<h3 class="pHeading2"><a name="wp1009955"> </a>
String vars
</h3>
<p class="pBody"><a name="wp1009958"> </a>
The String vars in the member functions described in this section and in the section <a href="member.html#wp1162851">Sequence vars</a> have a <span style="font-style: normal">TYPE</span> of <code class="cCode">char *</code>. String vars support additional member functions, as follows:
</p>
<h4 class="pDefTerm"><a name="wp1139986"> </a>
<code class="cCode">String_var(char * str) </code>
</h4><div class="pDefPara"><a name="wp1139987"> </a>
This constructor makes a <code class="cCode">String_var</code> from a string. The <code class="cCode">str</code> argument specifies the string that will be assumed. The user must not use the <code class="cCode">str</code> pointer to access data.
</div>
<h4 class="pDefTerm"><a name="wp1140153"> </a>
<code class="cCode">String_var(const char * str) <br />String_var(const String_var &amp; var)</code>
</h4><div class="pDefPara"><a name="wp1009961"> </a>
This constructor makes a <code class="cCode">String_var</code> from a const<code class="cCode"> </code>string. The <code class="cCode">str</code> argument specifies the const string that will be copied. The <code class="cCode">var</code> argument specifies a reference to the string to be copied.
</div>
<h4 class="pDefTerm"><a name="wp1139975"> </a>
<code class="cCode">String_var &amp; operator=(char * str) </code>
</h4><div class="pDefPara"><a name="wp1139976"> </a>
This assignment operator first releases the contained string using <code class="cCode">CORBA::string_free</code>, and then assumes ownership of the input string. The <code class="cCode">str</code> argument specifies the string whose ownership will be assumed by this <code class="cCode">String_var</code> object.
</div>
<h4 class="pDefTerm"><a name="wp1009962"> </a>
<code class="cCode">String_var &amp; operator=(const char * str)<br />String_var &amp; operator=(const String_var &amp; var) </code>
</h4><div class="pDefPara"><a name="wp1009963"> </a>
This assignment operator first releases the contained string using <code class="cCode">CORBA::string_free</code>, and then copies the input string. The <code class="cCode">Data</code> argument specifies the string whose ownership will be assumed by this <code class="cCode">String_var</code> object.
</div>
<h4 class="pDefTerm"><a name="wp1009966"> </a>
<code class="cCode">char operator[] (Ulong Index)<br />char operator[] (Ulong Index) const </code>
</h4><div class="pDefPara"><a name="wp1009967"> </a>
These array operators are superscripting operators that provide access to characters within the string. The <code class="cCode">Index</code> argument specifies the index of the array to use in accessing a particular character within the array. Zero-based indexing is used. The returned value of the <code class="cCode">Char operator[] (Ulong Index)</code> function can be used as an lvalue. The returned value of the <br /><code class="cCode">Char operator[] (Ulong Index) const</code> function cannot be used as an lvalue.
</div>
<h4 class="pHeading3"><a name="wp1139189"> </a>
out Classes
</h4>
<p class="pBody"><a name="wp1139190"> </a>
Structured types (struct, union, sequence), arrays, and interfaces have a corresponding generated _out class. The out class is provided for simplifying the memory management of pointers to variable-length and fixed-length types. For more information about <code class="cCode">out</code> classes and the common member functions, see the section <a href="member.html#wp1132019">Using out Classes</a>.
</p>
<p class="pBody"><a name="wp1139196"> </a>
Some differences occur in the operators supported for the user-defined data types. <a href="member.html#wp1155044">Table&#160;13-5</a> describes the various operators supported by each OMG IDL data type, in the generated C++ code. Because the assignment operators are supported for all of the data types described in <a href="member.html#wp1155044">Table&#160;13-5</a>, they are not included in the comparison.
</p>
<p class="pGraphic"><a name="wp1155017"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1155044table1155042"><caption><a name="wp1155044"> </a>
Table 13-5  Comparison of Operators Supported for User-defined Data Type Out Classes

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1155085"> </a>
OMG IDL Data Type
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1155087"> </a>
operator -&gt;
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1155089"> </a>
operator[ ]
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155110"> </a>
<code class="cCode">struct</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155112"> </a>
Yes
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155114"> </a>
No
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155116"> </a>
<code class="cCode">union</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155118"> </a>
Yes
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155120"> </a>
No
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155122"> </a>
<code class="cCode">sequence</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155124"> </a>
Yes
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155126"> </a>
Yes, non-const only
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155128"> </a>
<code class="cCode">array</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155130"> </a>
No
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155132"> </a>
Yes
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<p class="pBody"><a name="wp1139243"> </a>
The signatures are as shown in <a href="member.html#wp1155178">Table&#160;13-6</a>.
</p>
<p class="pGraphic"><a name="wp1155175"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1155178table1155176"><caption><a name="wp1155178"> </a>
Table 13-6  Operator Signatures for _out Classes

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1155213"> </a>
OMG IDL Data Type
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1155215"> </a>
Operator Member Functions
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155217"> </a>
<code class="cCode">struct</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155219"> </a>
<span style="font-style: normal">TYPE</span><code style="font-style: normal" class="cCode"> * operator-&gt; ()   <br /></code><span style="font-style: normal">TYPE</span><code class="cCode"> * operator-&gt; () const</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155221"> </a>
<code class="cCode">union</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155223"> </a>
<span style="font-style: normal">TYPE</span><code style="font-style: normal" class="cCode"> * operator-&gt; ()   <br /></code><span style="font-style: normal">TYPE</span><code class="cCode"> * operator-&gt; () const</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155225"> </a>
<code class="cCode">sequence</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155227"> </a>
<span style="font-style: normal">TYPE</span><code style="font-style: normal" class="cCode"> * operator-&gt; ()   <br /></code><span style="font-style: normal">TYPE</span><code style="font-style: normal" class="cCode"> * operator-&gt; () const   <br /></code><span style="font-style: normal">TYPE</span><code class="cCode"> &amp; operator[](CORBA::Long index)</code>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155229"> </a>
<code class="cCode">array</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1155231"> </a>
<span style="font-style: normal">TYPE</span><code style="font-style: normal" class="cCode">_slice &amp; operator[](CORBA::Long index)   </code><span style="font-style: normal">TYPE</span><code class="cCode">_slice &amp; operator[](CORBA::Long index) const</code>
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1132019"> </a>
Using out Classes
</h2><p class="pBody"><a name="wp1132020"> </a>
When a <code class="cCodeEmphasis">TYPE</code><code class="cCode">_var</code> is passed as an <code class="cCode">out</code> parameter, any previous value it referred to must be implicitly deleted. To give the ORB enough hooks to meet this requirement, each <code class="cCode">T_var</code> type has a corresponding <code class="cCodeEmphasis">TYPE</code><code class="cCode">_out</code> type that is used solely as the <code class="cCode">out</code> parameter type. 
</p>
<a name="wp1141720"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The <code class="cCode">_out</code> classes are not intended to be instantiated directly by the programmer. Specify an <code class="cCode">_out</code> class only in function signatures. </td>
</tr>
</table>

<p class="pBody"><a name="wp1141729"> </a>
The general form for <code class="cCodeEmphasis">TYPE</code><code class="cCode">_out</code> types for variable-length types is as follows:
</p>
<a name="wp1132021"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />class TYPE_out<br />{<br />  public:<br />    TYPE_out(TYPE*&amp; p) : ptr_(p) { ptr_ = 0; }<br />    TYPE_out(TYPE_var&amp; p) : ptr_(p.ptr_) { delete ptr_; ptr_ = 0;}<br />    TYPE_out(TYPE_out&amp; p) : ptr_(p.ptr_) {}<br />    TYPE_out&amp; operator=(TYPE_out&amp; p) { ptr_ = p.ptr_;<br />                                       return *this;<br />    }<br />    Type_out&amp; operator=(Type* p) { ptr_ = p; return *this; }<br /><br />    operator Type*&amp;() { return ptr_; }<br />    Type*&amp; ptr() { return ptr_; }<br />     <br />    Type* operator-&gt;() { return ptr_; }<br /><br />  private:<br />     Type*&amp; ptr_;</code></pre></div><a name="wp1132022"> </a><div class="pPreformatted"><pre><code class="cCode">     // assignment from </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_var not allowed<br />     void operator=(const TYPE_var&amp;):<br />};</code></pre></div><p class="pBody"><a name="wp1132039"> </a>
The first constructor binds the reference data member with the <code class="cCode">T*&amp;</code> argument and sets the pointer to the zero (0) pointer value. The second constructor binds the reference data member with the pointer held by the<code class="cCode"> </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_var</code> argument, and then calls <code class="cCode">delete</code> on the pointer (or <code class="cCode">string_free()</code> in the case of the <code class="cCode">String_out</code> type or <code class="cCodeEmphasis">TYPE</code><code class="cCode">_free()</code> in the case of a <code class="cCodeEmphasis">TYPE</code><code class="cCode">_var</code> for an array type <code class="cCodeEmphasis">TYPE</code>). The third constructor, the copy constructor, binds the reference data member to the same pointer referenced by the data member of the constructor argument. 
</p>
<p class="pBody"><a name="wp1140886"> </a>
Assignment from another<code class="cCode"> </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_out</code> copies the <code class="cCodeEmphasis">TYPE</code><code class="cCode">*</code> referenced by the <code class="cCodeEmphasis">TYPE</code><code class="cCode">_out</code> argument to the data member. The overloaded assignment operator for<code class="cCodeEmphasis"> TYPE</code><code class="cCode">*</code> simply assigns the pointer argument to the data member. Note that assignment does not cause any previously held pointer to be deleted; in this regard, the <code class="cCodeEmphasis">TYPE</code><code class="cCode">_out</code> type behaves exactly as a <code class="cCodeEmphasis">TYPE</code><code class="cCode">*</code>. The <code class="cCodeEmphasis">TYPE</code><code class="cCode">*&amp;</code> conversion operator returns the data member. The <code class="cCode">ptr()</code> member function, which can be used to avoid having to rely on implicit conversion, also returns the data member. The overloaded arrow operator (<code class="cCode">operator-&gt;()</code>) allows access to members of the data structure pointed to by the <code class="cCodeEmphasis">TYPE</code><code class="cCode">*</code> data member. Compliant applications may not call the overloaded <code class="cCode">operator-&gt;()</code> unless the <code class="cCodeEmphasis">TYPE</code><code class="cCode">_out</code> has been initialized with a valid nonNULL<code class="cCode"> </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">*</code>.
</p>
<p class="pBody"><a name="wp1132040"> </a>
Assignment to a <code class="cCodeEmphasis">TYPE</code><code class="cCode">_out</code> from instances of the corresponding <code class="cCodeEmphasis">TYPE</code><code class="cCode">_var</code> type is disallowed because there is no way to determine whether the application developer wants a copy to be performed, or whether the <code class="cCodeEmphasis">TYPE</code><code class="cCode">_var</code> should yield ownership of its managed pointer so it can be assigned to the <code class="cCodeEmphasis">TYPE</code><code class="cCode">_out</code>. To perform a copy of a <code class="cCodeEmphasis">TYPE</code><code class="cCode">_var</code> to a <code class="cCodeEmphasis">TYPE</code><code class="cCode">_out</code>, the application should use <code class="cCode">new</code>, as follows:
</p>
<a name="wp1132041"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br /></code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_var t = ...;<br />my_out = new </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">(t.in());        // heap-allocate a copy</code></pre></div><p class="pBody"><a name="wp1132042"> </a>
The <code class="cCode">in()</code> function called on <code class="cCode">t</code> typically returns a <code class="cCode">const </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">&amp;</code>, suitable for invoking the copy constructor of the newly allocated <code class="cCode">T</code> instance.
</p>
<p class="pBody"><a name="wp1132043"> </a>
Alternatively, to make the <code class="cCodeEmphasis">TYPE</code><code class="cCode">_var</code> yield ownership of its managed pointer so it can be returned in a <code class="cCode">T_out</code> parameter, the application should use the <code class="cCodeEmphasis">TYPE</code><code class="cCode">_var::_retn()</code> function, as follows:
</p>
<a name="wp1132044"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br /></code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_var t = ...;<br />my_out = t._retn();       // t yields ownership, no copy</code></pre></div><p class="pBody"><a name="wp1132045"> </a>
Note that the <code class="cCodeEmphasis">TYPE</code><code class="cCode">_out</code> types are not intended to serve as general-purpose data types to be created and destroyed by applications; they are used only as types within operation signatures to allow necessary memory management side-effects to occur properly.
</p>
<h3 class="pHeading2"><a name="wp1132046"> </a>
Object Reference out Parameter
</h3>
<p class="pBody"><a name="wp1132047"> </a>
When a <code class="cCode">_var</code> is passed as an <code class="cCode">out</code> parameter, any previous value it refers to must be implicitly released. To give C++ mapping implementations enough hooks to meet this requirement, each object reference type results in the generation of an <code class="cCode">_out</code> type that is used solely as the <code class="cCode">out</code> parameter type. For example, interface <code class="cCodeEmphasis">TYPE</code> results in the object reference type <code class="cCodeEmphasis">TYPE</code><code class="cCode">_ptr</code>, the helper type <code class="cCodeEmphasis">TYPE</code><code class="cCode">_var</code>, and the <code style="font-weight: normal" class="cCode">out</code><span style="font-weight: bold"> </span>parameter type <code class="cCodeEmphasis">TYPE</code><code class="cCode">_out</code>. The general form for object reference <code style="font-weight: normal" class="cCode">_out</code><span style="font-weight: bold"> </span>types is as follows:
</p>
<a name="wp1132048"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />class </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_out<br />{<br />  public:<br />    </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_out(</code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_ptr&amp; p) : ptr_(p) { ptr_ = </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">::_nil(); }<br />   </code><code class="cCodeEmphasis"> TYPE</code><code class="cCode">_out(</code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_var&amp; p) : ptr_(p.ptr_) {<br />        release(ptr_); ptr_ = </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">::_nil();<br />    }<br />    </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_out(</code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_out&amp; a) : ptr_(a.ptr_) {}<br />    </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_out&amp; operator=(</code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_out&amp; a) {<br />        ptr_ = a.ptr_; return *this;<br />    }<br />    </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_out&amp; operator=(const </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_var&amp; a) {<br />    ptr_ = </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">::_duplicate(</code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_ptr(a)); return *this;<br />    }<br />    </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_out&amp; operator=(TYPE_ptr p) { ptr_ = p; return *this; }<br />    operator </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_ptr&amp;() { return ptr_; }<br />    </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_ptr&amp; ptr() { return ptr_; }<br />    </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_ptr operator-&gt;() { return ptr_; }<br /><br />  private:<br />    </code><code class="cCodeEmphasis">TYPE</code><code class="cCode">_ptr&amp; ptr_;<br />};</code></pre></div><h3 class="pHeading2"><a name="wp1132049"> </a>
Sequence outs
</h3>
<p class="pBody"><a name="wp1132050"> </a>
Sequence outs support the following additional <code class="cCode">operator[]</code> member function:
</p>
<h4 class="pDefTerm"><a name="wp1132051"> </a>
<code class="cCode">TYPE &amp;operator[](CORBA::ULong Index); </code>
</h4><div class="pDefPara"><a name="wp1132052"> </a>
This operator invokes the <code class="cCode">operator[] </code>of the sequence owned by the out class. The <code class="cCode">operator[] </code>returns a reference to the appropriate element of the sequence at the specified index. The <code class="cCode">Index</code> argument specifies the index of the element to return. This index cannot be greater than the current sequence length.
</div>
<h3 class="pHeading2"><a name="wp1132053"> </a>
Array outs
</h3>
<p class="pBody"><a name="wp1132054"> </a>
Array outs do not support <code class="cCode">operator-&gt;</code>, but do support the following additional <code class="cCode">operator[]</code> member functions to access the array elements:
</p>
<h4 class="pDefTerm"><a name="wp1132055"> </a>
<code class="cCode">TYPE_slice&amp; operator[](CORBA::ULong Index); <br />const TYPE_slice &amp; operator[](CORBA::ULong Index) const; </code>
</h4><div class="pDefPara"><a name="wp1132056"> </a>
These operators return a reference to the array slice at the specified index. An array slice is an array with all the dimensions of the original array except the first dimension. The member functions for the array-generated classes use a pointer to a slice to return pointers to an array. The <code class="cCode">Index</code> argument specifies the index of the slice to return. This index cannot be greater than the array dimension.
</div>
<h3 class="pHeading2"><a name="wp1132057"> </a>
String outs
</h3>
<p class="pBody"><a name="wp1132058"> </a>
When a <code class="cCode">String_var</code> is passed as an <code class="cCode">out</code> parameter, any previous value it refers to must be implicitly freed. To give C++ mapping implementations enough hooks to meet this requirement, the string type also results in the generation of a <code class="cCode">String_out</code> type in the CORBA namespace that is used solely as the string <code class="cCode">out</code> parameter type. The general form for the <code style="font-weight: normal" class="cCode">String_out</code><span style="font-weight: bold"> </span>type is as follows:
</p>
<a name="wp1132059"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />class String_out<br />{<br />  public:<br />     String_out(char*&amp; p) : ptr_(p) { ptr_ = 0; }<br />     String_out(String_var&amp; p) : ptr_(p.ptr_) {<br />         string_free(ptr_); ptr_ = 0;<br />     }<br />     String_out(String_out&amp; s) : ptr_(s.ptr_) {}<br />	     String_out&amp; operator=(String_out&amp; s) {<br />          ptr_ = s.ptr_; return *this;<br />     }<br />     String_out&amp; operator=(char* p) {<br />          ptr_ = p; return *this;<br />     }<br />     String_out&amp; operator=(const char* p) {<br />          ptr_ = string_dup(p); return *this;<br />     }<br />     operator char*&amp;() { return ptr_; }<br />     char*&amp; ptr() { return ptr_; }</code></pre></div><a name="wp1132060"> </a><div class="pPreformatted"><pre><code class="cCode">  private:<br />     char*&amp; ptr_;</code></pre></div><a name="wp1132061"> </a><div class="pPreformatted"><pre><code class="cCode">     // assignment from String_var disallowed<br />     void operator=(const String_var&amp;);<br />};</code></pre></div><p class="pBody"><a name="wp1132062"> </a>
The first constructor binds the reference data member with the <code class="cCode">char*&amp;</code> argument. The second constructor binds the reference data member with the<code class="cCode"> char*</code> held by the <code class="cCode">String_var</code> argument, and then calls<code class="cCode"> string_free()</code> on the string. The third constructor, the copy constructor, binds the reference data member to the same <code style="font-weight: normal" class="cCode">char*</code><span style="font-weight: bold"> </span>bound to the data member of its argument. 
</p>
<p class="pBody"><a name="wp1140909"> </a>
Assignment from another <code class="cCode">String_out</code> copies the <code class="cCode">char*</code> referenced by the argument <code class="cCode">String_out</code> to the <code class="cCode">char*</code> referenced by the data member. The overloaded assignment operator for <code class="cCode">char*</code> simply assigns the <code class="cCode">char*</code> argument to the data member. The overloaded assignment operator for <code style="font-weight: normal" class="cCode">const</code><span style="font-weight: bold"> </span><code class="cCode">char*</code> duplicates the argument and assigns the result to the data member. Note that the assignment does not cause any previously held string to be freed; in this regard, the <code class="cCode">String_out</code> type behaves exactly as a <code class="cCode">char*</code>. The <code class="cCode">char*&amp;</code> conversion operator returns the data member. The <code class="cCode">ptr()</code> member function, which can be used to avoid having to rely on implicit conversion, also returns the data member.
</p>
<p class="pBody"><a name="wp1132063"> </a>
Assignment from <code class="cCode">String_var</code> to a <code class="cCode">String_out</code> is disallowed because of the memory management ambiguities involved. Specifically, it is not possible to determine whether the string owned by the <code class="cCode">String_var</code> should be taken over by the <code class="cCode">String_out</code> without copying, or if it should be copied. Disallowing assignment from <code class="cCode">String_var</code> forces the application developer to make the choice explicitly, as follows:
</p>
<a name="wp1132064"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />void<br />A::op(String_out arg)<br />{<br />    String_var s = string_dup(&quot;some string&quot;);<br />    ...<br />    out = s;               // disallowed; either<br />    out = string_dup(s);   // 1: copy, or<br />    out = s._retn();       // 2: adopt<br />}</code></pre></div><p class="pBody"><a name="wp1132065"> </a>
On the line marked with the comment &#8220;1,&#8221; the caller is explicitly copying the string held by the <code class="cCode">String_var</code> and assigning the result to the <code class="cCode">out</code> argument. Alternatively, the caller could use the technique shown on the line marked with the comment &#8220;2&#8221; to force the <code class="cCode">String_var</code> to give up its ownership of the string it holds so that it may be returned in the <code class="cCode">out</code> argument without incurring memory management errors. 
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1125564"> </a>
Argument Passing Considerations
</h2><p class="pBody"><a name="wp1125566"> </a>
The mapping of parameter passing modes attempts to balance the need for both efficiency and simplicity. For primitive types, enumerations, and object references, <br />the modes are straightforward, passing the type <code class="cCode">P</code> for primitives and enumerations and the type <code class="cCode">A_ptr</code> for an interface type <em class="cEmphasis">A</em>.
</p>
<p class="pBody"><a name="wp1125568"> </a>
Aggregate types are complicated by the question of when and how parameter memory is allocated and deallocated. Mapping <code class="cCode">in</code> parameters is straightforward because the parameter storage is caller-allocated and read-only. The mapping for <code class="cCode">out</code> and <code class="cCode">inout</code> parameters is more problematic. For variable-length types, the callee must allocate some if not all of the storage. For fixed-length types, such as a <em class="cEmphasis">Point</em> type <br />represented as a struct containing three floating point members, caller allocation is preferable (to allow stack allocation).
</p>
<p class="pBody"><a name="wp1125570"> </a>
To accommodate both kinds of allocation, avoid the potential confusion of split allocation, and eliminate confusion with respect to when copying occurs, the mapping is <code class="cCode">T&amp;</code> for a fixed-length aggregate <code class="cCode">T</code> and <code class="cCode">T*&amp;</code> for a variable-length <code class="cCode">T</code>. This approach has the unfortunate consequence that usage for structs depends on whether the struct is fixed- or variable-length; however, the mapping is consistently <code class="cCode">T_var&amp;</code> if the caller uses the managed type <code class="cCode">T_var</code>.
</p>
<p class="pBody"><a name="wp1125571"> </a>
The mapping for <code class="cCode">out</code> and <code class="cCode">inout</code> parameters additionally requires support for deallocating any previous variable-length data in the parameter when a<code class="cCode"> T_var</code> is passed. Even though their initial values are not sent to the operation, the Oracle Tuxedo includes <code class="cCode">out</code> parameters because the parameter could contain the result from a previous call. The provision of the <code class="cCode">T_out</code> types is intended to give implementations the hooks necessary to free the inaccessible storage while converting from the<code class="cCode"> T_var</code> types. The following examples demonstrate the compliant behavior:
</p>
<a name="wp1125572"> </a><div class="pPreformatted"><pre><code class="cCode">// IDL<br />struct S { string name; float age; };<br />void f(out S p);</code></pre></div><a name="wp1125573"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />S_var s;<br />f(s);<br />// use s<br />f(s);        // first result will be freed<br /><br />S *sp;       // need not initialize before passing to out<br />f(sp);<br />// use sp<br />delete sp;   // cannot assume next call will free old value<br />f(sp);</code></pre></div><p class="pBody"><a name="wp1125574"> </a>
Note that implicit deallocation of previous values for <code class="cCode">out</code> and <code class="cCode">inout</code> parameters works only with <code class="cCode">T_var</code> types, not with other types:
</p>
<a name="wp1125575"> </a><div class="pPreformatted"><pre><code class="cCode">// IDL<br />void q(out string s);</code></pre></div><a name="wp1125576"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />char *s;<br />for (int i = 0; i &lt; 10; i++)<br />q(s);          // memory leak!</code></pre></div><p class="pBody"><a name="wp1125577"> </a>
Each call to the <code class="cCode">q</code> function in the loop results in a memory leak because the caller is not invoking <code class="cCode">string_free</code> on the <code class="cCode">out</code> result. There are two ways to fix this, as shown below:
</p>
<a name="wp1125578"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />char *s;<br />String_var svar;<br />for (int i = 0 ; i &lt; 10; i++) {<br />    q(s);<br />    string_free(s);    // explicit deallocation<br />    // OR:<br />    q(svar);           // implicit deallocation<br />}</code></pre></div><p class="pBody"><a name="wp1125579"> </a>
Using a plain <code class="cCode">char*</code> for the <code class="cCode">out</code> parameter means that the caller must explicitly deallocate its memory before each reuse of the variable as an <code class="cCode">out</code> parameter, while using a <code class="cCode">String_var</code> means that any deallocation is performed implicitly upon each use of the variable as an <code class="cCode">out</code> parameter.
</p>
<p class="pBody"><a name="wp1125580"> </a>
Variable-length data must be explicitly released before being overwritten. For example, before assigning to an <code class="cCode">inout</code> string parameter, the implementor of an operation may first delete the old character data. Similarly, an <code class="cCode">inout</code> interface parameter should be released before being reassigned. One way to ensure that the parameter storage is released is to assign it to a local <code class="cCode">T_var</code> variable with an automatic release, as in the following example:
</p>
<a name="wp1125583"> </a><div class="pPreformatted"><pre><code class="cCode">// IDL<br />interface A;<br />void f(inout string s, inout A obj);</code></pre></div><a name="wp1125584"> </a><div class="pPreformatted"><pre><code class="cCode">// C++<br />void Aimpl::f(char *&amp;s, A_ptr &amp;obj) {<br />    String_var s_tmp = s;<br />    s = /* new data */;<br />    A_var obj_tmp = obj;<br />    obj = /* new reference */<br />}</code></pre></div><p class="pBody"><a name="wp1125592"> </a>
For parameters that are passed or returned as a pointer (<code class="cCode">T*</code>) or as a reference to a pointer (<code class="cCode">T*&amp;</code>), an application is not allowed to pass or return a NULL pointer; the result of doing so is undefined. In particular, a caller may not pass a NULL pointer under any of the following circumstances:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1125594"> </a><code class="cCode">in</code> and <code class="cCode">inout</code> string</li>
<li><a name="wp1125595"> </a><code class="cCode">in</code> and <code class="cCode">inout</code> array (pointer to first element)</li>
</ul></div>
<p class="pBody"><a name="wp1125596"> </a>
However, a caller may pass a reference to a pointer with a NULL value for <code class="cCode">out</code> parameters, because the callee does not examine the value, but overwrites it. A callee may not return a NULL pointer under any of the following circumstances:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1125597"> </a><code class="cCode">out</code> and return variable-length struct</li>
<li><a name="wp1125598"> </a><code class="cCode">out</code> and return variable-length union</li>
<li><a name="wp1125599"> </a><code class="cCode">out</code> and return string</li>
<li><a name="wp1125600"> </a>	<code class="cCode">out</code> and return sequence</li>
<li><a name="wp1125601"> </a><code class="cCode">out</code> and return variable-length array, return fixed-length array</li>
<li><a name="wp1125602"> </a>	<code class="cCode">out</code> and return any</li>
</ul></div>
<h3 class="pHeading2"><a name="wp1125612"> </a>
Operation Parameters and Signatures
</h3>
<p class="pBody"><a name="wp1125616"> </a>
<a href="member.html#wp1167840">Table&#160;13-7</a> displays the mapping for the basic OMG IDL parameter passing modes and return type according to the type being passed or returned. <a href="member.html#wp1144513">Table&#160;13-8</a> displays the same information for <code class="cCode">T_var</code> types. <a href="member.html#wp1144513">Table&#160;13-8</a> is merely for informational purposes; it is expected that operation signatures for both clients and servers will be written in terms of the parameter-passing modes shown in <a href="member.html#wp1167840">Table&#160;13-7</a>, with the exception that the <code class="cCode">T_out</code> types will be used as the actual parameter types for all <code class="cCode">out</code> parameters.
</p>
<p class="pBody"><a name="wp1170671"> </a>
It is also expected that <code class="cCode">T_var</code> types will support the necessary conversion operators to allow them to be passed directly. Callers should always pass instances of either<code class="cCode"> T_var</code> types or the base types shown in <a href="member.html#wp1167840">Table&#160;13-7</a>, and callees should treat their <code class="cCode">T_out</code> parameters as if they were actually the corresponding underlying types shown in <a href="member.html#wp1167840">Table&#160;13-7</a>.
</p>
<p class="pBody"><a name="wp1125635"> </a>
In <a href="member.html#wp1167840">Table&#160;13-7</a>, fixed-length arrays are the only case where the type of an <code class="cCode">out</code> <br />parameter differs from a return value, which is necessary because C++ does not allow a function to return an array. The mapping returns a pointer to a <em class="cEmphasis">slice</em> of the <br />array, where a slice is an array with all the dimensions of the original array <br />specified except the first dimension.
</p>
<p class="pGraphic"><a name="wp1144027"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1167840table1144028"><caption><a name="wp1167840"> </a>
Table 13-7  Basic Argument and Result Passing&#160;

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1167850"> </a>
Data Type
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1167852"> </a>
In
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1167854"> </a>
Inout
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1167856"> </a>
Out
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1167858"> </a>
Return
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167860"> </a>
short
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167862"> </a>
Short
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167864"> </a>
Short&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167866"> </a>
Short&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167868"> </a>
Short
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167870"> </a>
long
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167872"> </a>
Long
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167874"> </a>
Long&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167876"> </a>
Long&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167878"> </a>
Long
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167880"> </a>
unsigned short
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167882"> </a>
UShort
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167884"> </a>
UShort&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167886"> </a>
UShort&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167888"> </a>
UShort
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167890"> </a>
unsigned long
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167892"> </a>
ULong
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167894"> </a>
ULong&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167896"> </a>
ULong&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167898"> </a>
ULong
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167900"> </a>
float
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167902"> </a>
Float
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167904"> </a>
Float&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167906"> </a>
Float&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167908"> </a>
Float
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167910"> </a>
double
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167912"> </a>
Double
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167914"> </a>
Double&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167916"> </a>
Double&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167918"> </a>
Double
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167920"> </a>
boolean
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167922"> </a>
Boolean
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167924"> </a>
Boolean&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167926"> </a>
Boolean&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167928"> </a>
Boolean
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167930"> </a>
char
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167932"> </a>
Char
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167934"> </a>
Char&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167936"> </a>
Char&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167938"> </a>
Char
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167940"> </a>
wchar
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167942"> </a>
WChar
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167944"> </a>
WChar&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167946"> </a>
WChar
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167948"> </a>
Octet
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168096"> </a>
octet
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168098"> </a>
Octet
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168100"> </a>
Octet&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168102"> </a>
Octet&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168104"> </a>
Octet
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167950"> </a>
enum
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167952"> </a>
enum
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167954"> </a>
enum&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167956"> </a>
enum&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167958"> </a>
enum
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167960"> </a>
object reference ptr (See Note below.)
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167962"> </a>
objref_ptr
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167964"> </a>
objref_ptr&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167966"> </a>
objref_ptr&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167968"> </a>
objref_ptr
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167970"> </a>
struct, fixed
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167972"> </a>
const struct&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167974"> </a>
struct&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167976"> </a>
struct&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167978"> </a>
struct
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167980"> </a>
struct, variable
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167982"> </a>
const struct&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167984"> </a>
struct&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167986"> </a>
struct*&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167988"> </a>
struct*
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167990"> </a>
union, fixed
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167992"> </a>
const union&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167994"> </a>
union&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167996"> </a>
union&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167998"> </a>
union
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168000"> </a>
union, variable
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168002"> </a>
const union&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168004"> </a>
union&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168006"> </a>
union*&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168008"> </a>
union*
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168010"> </a>
string
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168012"> </a>
const char*
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168014"> </a>
char*&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168016"> </a>
char*&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168018"> </a>
char*
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168082"> </a>
wstring
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168084"> </a>
const WChar
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168086"> </a>
WChar*&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168088"> </a>
Wchar*&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168074"> </a>
WChar*
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168020"> </a>
sequence
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168022"> </a>
const sequence&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168024"> </a>
sequence&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168026"> </a>
sequence*&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168028"> </a>
sequence*
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168030"> </a>
array, fixed
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168032"> </a>
const array
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168034"> </a>
array
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168036"> </a>
array
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168038"> </a>
array slice* (See Note below.)
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168040"> </a>
array, variable
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168042"> </a>
const array
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168044"> </a>
array
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168046"> </a>
array slice*&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168048"> </a>
array slice*
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168050"> </a>
any
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168052"> </a>
const any&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168054"> </a>
any&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168056"> </a>
any*&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1168058"> </a>
any*
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<a name="wp1142148"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The Object reference ptr data type includes pseudo-object references. The array slice return is an array with all the dimensions of the original array except the first dimension.</td>
</tr>
</table>

<p class="pBody"><a name="wp1153356"> </a>
A caller is responsible for providing storage for all arguments passed as <code class="cCode">in</code> arguments.
</p>
<p class="pGraphic"><a name="wp1144506"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1144513table1144511"><caption><a name="wp1144513"> </a>
Table 13-8  T_var Argument and Result Passing

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1144627"> </a>
Data Type
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1144629"> </a>
In
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1144631"> </a>
Inout
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1144633"> </a>
Out
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1144635"> </a>
Return
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144637"> </a>
object reference var (See Note below.)
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144642"> </a>
const objref_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144644"> </a>
objref_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144646"> </a>
objref_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144648"> </a>
objref_var
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144650"> </a>
struct_var
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144652"> </a>
const struct_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144654"> </a>
struct_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144656"> </a>
struct_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144658"> </a>
struct_var
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144660"> </a>
union_var
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144662"> </a>
const union_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144664"> </a>
union_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144666"> </a>
union_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144668"> </a>
union_var
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144670"> </a>
string_var
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144672"> </a>
const string_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144674"> </a>
string_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144676"> </a>
string_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144678"> </a>
string_var
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144680"> </a>
sequence_var
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144682"> </a>
const sequence_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144684"> </a>
sequence_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144686"> </a>
sequence_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144688"> </a>
sequence_var
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144690"> </a>
array_var
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144692"> </a>
const array_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144694"> </a>
array_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144696"> </a>
array_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144698"> </a>
array_var
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144700"> </a>
any_var
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144702"> </a>
const any_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144704"> </a>
any_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144706"> </a>
any_var&amp;
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144708"> </a>
any_var
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<a name="wp1144510"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td><b class="cBold">The object reference var</b> data type includes pseudo-object references.</td>
</tr>
</table>

<p class="pBody"><a name="wp1153368"> </a>
<a href="member.html#wp1144716">Table&#160;13-9</a> and <a href="member.html#wp1145074">Table&#160;13-10</a> describe the caller&#8217;s responsibility for storage associated with <code class="cCode">inout</code> and <code class="cCode">out</code> parameters and for return results.
</p>
<p class="pGraphic"><a name="wp1144713"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1144716table1144714"><caption><a name="wp1144716"> </a>
Table 13-9  Caller Argument Storage Responsibilities&#160;

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1144903"> </a>
Type
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1144905"> </a>
Inout Param
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1144907"> </a>
Out Param
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1144909"> </a>
Return Result
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144911"> </a>
short
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144913"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144915"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144917"> </a>
1
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144919"> </a>
long
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144921"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144923"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144925"> </a>
1
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144927"> </a>
unsigned short
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144929"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144931"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144933"> </a>
1
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144935"> </a>
unsigned long
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144937"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144939"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144941"> </a>
1
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144943"> </a>
float
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144945"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144947"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144949"> </a>
1
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144951"> </a>
double
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144953"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144955"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144957"> </a>
1
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144959"> </a>
boolean
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144961"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144963"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144965"> </a>
1
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144967"> </a>
char
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144969"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144971"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144973"> </a>
1
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167777"> </a>
wchar
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167779"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167781"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167783"> </a>
1
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144975"> </a>
octet
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144977"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144979"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144981"> </a>
1
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144983"> </a>
enum
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144985"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144987"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144989"> </a>
1
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144991"> </a>
object reference ptr
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144993"> </a>
2
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144995"> </a>
2
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144997"> </a>
2
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1144999"> </a>
struct, fixed
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145001"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145003"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145005"> </a>
1
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145007"> </a>
struct, variable
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145009"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145011"> </a>
3
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145013"> </a>
3
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145015"> </a>
union, fixed
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145017"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145019"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145021"> </a>
1
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145023"> </a>
union, variable
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145025"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145027"> </a>
3
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145029"> </a>
3
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145031"> </a>
string
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145033"> </a>
4
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145035"> </a>
3
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145037"> </a>
3
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167791"> </a>
wstring
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167793"> </a>
4
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167795"> </a>
3
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1167797"> </a>
3
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145039"> </a>
sequence
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145041"> </a>
5
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145043"> </a>
3
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145045"> </a>
3
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145047"> </a>
array, fixed
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145049"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145051"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145053"> </a>
6
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145055"> </a>
array, variable
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145057"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145059"> </a>
6
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145061"> </a>
6
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145063"> </a>
any
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145065"> </a>
5
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145067"> </a>
3
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145069"> </a>
3
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<p class="pGraphic"><a name="wp1142519"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1145074table1145072"><caption><a name="wp1145074"> </a>
Table 13-10  Argument Passing Cases&#160;

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1145117"> </a>
Case
</div>
</th>
    <th scope="col">&#160;</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145121"> </a>
1
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145123"> </a>
Caller allocates all necessary storage, except that which may be encapsulated and managed within the parameter itself. For <code class="cCode">inout</code> parameters, the caller provides the initial value, and the callee may change that value. For <code class="cCode">out</code> parameters, the caller allocates the storage but need not initialize it, and the callee sets the value. Function returns are by value.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145125"> </a>
2
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145127"> </a>
Caller allocates storage for the object reference. For <code class="cCode">inout</code> parameters, the caller provides an initial value; if the callee wants to reassign the <code class="cCode">inout</code> parameter, it will first call <code class="cCode">CORBA::release</code> on the original input value. To continue to use an object reference passed in as an <code class="cCode">inout</code>, the caller must first duplicate the reference. The caller is responsible for the release of all <code class="cCode">out</code> and return object references. Release of all object references embedded in other structures is performed automatically by the structures themselves.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145129"> </a>
3
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145131"> </a>
For <code class="cCode">out</code> parameters, the caller allocates a pointer and passes it by reference to the callee. The callee sets the pointer to point to a valid instance of the parameter&#8217;s type. For returns, the callee returns a similar pointer. The callee is not allowed to return a NULL pointer in either case. 
</div>
<div class="pCellBody"><a name="wp1145132"> </a>
In both cases, the caller is responsible for releasing the returned storage. To maintain local/remote transparency, the caller must always release the returned storage, regardless of whether the callee is located in the same address space as the caller or is located in a different address space. Following the completion of a request, the caller is not allowed to modify any values in the returned storage&#8212;to do so, the caller must first copy the returned instance into a new instance, and modify the new instance.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145134"> </a>
4
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145136"> </a>
For <code class="cCode">inout</code> strings, the caller provides storage for both the input string and the <code class="cCode">char*</code> pointing to it. Since the callee may deallocate the input string and reassign the <code class="cCode">char*</code> to point to new storage to hold the output value, the caller should allocate the input string using <code class="cCode">string_alloc()</code>. The size of the <code class="cCode">out</code> string is, therefore, not limited by the size of the in string. The caller is responsible for deleting the storage for the <code class="cCode">out</code> using <code class="cCode">string_free()</code>. The callee is not allowed to return a NULL pointer for an <code class="cCode">inout</code>, <code class="cCode">out</code>, or return value.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145138"> </a>
5
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145140"> </a>
For <code class="cCode">inout</code> sequences and <code class="cCode">anys</code>, assignment or modification of the sequence or <code class="cCode">any</code> may cause deallocation of owned storage before any reallocation occurs, depending upon the state of the Boolean release parameter with which the sequence or <code class="cCode">any</code> was constructed.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145142"> </a>
6
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1145144"> </a>
For <code class="cCode">out</code> parameters, the caller allocates a pointer to an array slice, which has all the same dimensions of the original array except the first, and passes the pointer by reference to the callee. The callee sets the pointer to point to a valid instance of the array. 
</div>
<div class="pCellBody"><a name="wp1145145"> </a>
For returns, the callee returns a similar pointer. The callee is not allowed to return a NULL pointer in either case. In both cases, the caller is responsible for releasing the returned storage. 
</div>
<div class="pCellBody"><a name="wp1145146"> </a>
To maintain local/remote transparency, the caller must always release the returned storage, regardless of whether the callee is located in the same address space as the callee or is located in a different address space. Following completion of a request, the caller is not allowed to modify any values in the returned storage&#8212;to do so, the caller must first copy the returned array instance into a new array instance, and modify the new instance.
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>

<p class="troubleshoot">
<a href="#wp1148064" title="Footnote 1"><sup class="Footnote">1</sup></a>In particular, <code class="cCode">exception</code> used as a data type and a function name.
</p>
 
<br/>
    <table id="SummaryNotReq2" width="100%" border="0" cellpadding="0" cellspacing="0">
      <tr> 
        <td>
&nbsp;
<a href="member.html"><img id="LongDescNotReq8" src="/global_resources/images/backtop.gif" width="90" height="25" alt="Back to Top" title="Back to Top" border="0" /></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a accesskey="4" href="command.html"><img id="LongDescNotReq9" src="/global_resources/images/prevtop.gif" border="0" alt="Previous" /></a>&nbsp;
<a accesskey="5" href="corba_api.html"><img id="LongDescNotReq10" src="/global_resources/images/nexttop.gif" border="0" alt="Next" /></a>
<script language="Javascript1.1" type="text/javascript">
Copyright();
</script>
<noscript><a href="http://edocs.bea.com/copyright.html">&copy; BEA Systems</a></noscript>
        </td>
      </tr>
    </table>

<!-- WebAnalytics BEGIN -->

<!--#include virtual="/global_resources/edocs_wt.html"-->
      
<!-- WebAnalytics END -->

  </body>
</html>
