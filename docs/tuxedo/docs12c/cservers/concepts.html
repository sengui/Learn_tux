<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>

<!-- LOCALIZATION RELATED INFORMATION -->
<meta name="LOC_PROJ_ID" content="WLPF8.1" />
<meta name="LOC_OWNER" content="BEAJ" />
<meta name="LOC_STATUS" content="READY!" />
<meta name="LOC_COMMENT" content="LOC_COMMENT" />
<meta name="LOC_US_REV" content="1" />
<meta name="LOC_US_CHANGE" content="41824" />
<meta name="LOC_US_SRCFILE" content="//depot/tuxedo/tux12c/cservers/fm/concepts.fm" />
<!-- LOCALIZATION RELATED INFORMATION -->

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="GENERATOR" content="Quadralay WebWorks AutoMap 2003 Platinum Edition for FrameMaker 8.6.6577.0" />
    <meta name="TEMPLATEBASE" content="BEA_WFP_Template_V1.04" />
    <meta name="LASTUPDATED" content="06/26/12 11:03:49" />
    <link rel="StyleSheet" href="/global_resources/edocs.css" type="text/css" media="all" />

<title>CORBA Server Application Concepts</title>

<!-- BEA scripts begin -->

<script language="Javascript" src="/global_resources/js/banner.js" type="text/javascript"></script>
<!-- This script outputs the banner required for edocs documentation. -->

<script language="Javascript" src="floatwin.js" type="text/javascript"></script>
<!-- This script opens a new small floating window and puts TOC<i>&lt;name&gt;</i>.html and IX<i>&lt;name&gt;</i>.html files in it and sets a generic popup window code to enable the display of some viewlets in the WebLogic Platform Tour. -->

<script language="Javascript1.1" src="/global_resources/js/footer.js" type="text/javascript"></script>
<!-- This script outputs the footer with the correct copyright date and link to copyright page.-->

<script language="Javascript1.1" src="/global_resources/js/googlesearch4.js" type="text/javascript"></script>
<!-- This script outputs the google search form. -->

<script language="Javascript1.1" src="/global_resources/js/note.js" type="text/javascript"></script>
<!-- This script outputs a note such as a BETA note. -->

<script language="JavaScript1.1" src="/global_resources/js/search.js" type="text/javascript"></script>
<!-- This script is not for online documents. It is only used by the QuestAgent Java Applet for CD search indexes. -->

<!-- BEA scripts end -->

  </head>

  <body>


<script language="Javascript1.1" type="text/javascript">
GoogleURL();
</script><noscript>This script outputs the google search URL required for search on edocs documentation.</noscript>

<script language="Javascript1.1" type="text/javascript">
Banner();
</script><noscript>This script outputs the banner required for edocs documentation.</noscript>

<script language="Javascript1.1" type="text/javascript">
GoogleSearchCollection();
</script><noscript>This script outputs the google search parameters required for search on edocs documentation.</noscript>

<!-- page title -->
<h1 class="booktitle">Creating CORBA Server Applications
</h1>
<!-- page title end -->

    <table id="SummaryNotReq1" width="100%" border="0" align="left" cellpadding="2%" cellspacing="0">
      <tr> 
        <td>
&nbsp;&nbsp;&nbsp;&nbsp;
<a accesskey="4" href="index.html"><img id="LongDescNotReq1" src="/global_resources/images/doc_nav_prev.gif" border="0" alt="Previous" /></a>&nbsp;
<a accesskey="5" href="maksrv.html"><img id="LongDescNotReq2" src="/global_resources/images/doc_nav_next.gif" border="0" alt="Next" /></a>&nbsp;
<img id="LongDescNotReq3" src="/global_resources/images/doc_nav_dots.gif" border="0" alt="" />&nbsp;
<a accesskey="1" href="javascript:OpenWindowToc();" onmouseover="window.status='Table of Contents'; return true" onfocus="window.status='Table of Contents'; return true" onmouseout="window.status=''; return true" onblur="window.status=''; return true" title="Open TOC in new window">      <img id="LongDescNotReq4" src="/global_resources/images/doc_nav_contents.gif" alt="Open TOC in new window" border="0" /></a>&nbsp;
<a accesskey="2" href="javascript:OpenWindowIndex();" onmouseover="window.status='Index'; return true" onfocus="window.status='Index'; return true" onmouseout="window.status=''; return true" onblur="window.status=''; return true" title="Open Index in new window">     <img id="LongDescNotReq5" src="/global_resources//images/doc_nav_index.gif" border="0" alt="Open Index in new window" /></a>&nbsp;
<a href="../pdf/cservers.pdf" target="pdf"><img id="LongDescNotReq6" src="/global_resources/images/doc_nav_pdf.gif" width="59" height="44" alt="View as PDF - New Window" title="View as PDF - New Window" border="0" /></a>&nbsp;
<a href="http://www.adobe.com/products/acrobat/alternate.html" target="_blank"><img id="LongDescNotReq7" src="/global_resources/images/get_reader.gif" width="52" height="44" alt="Get Adobe Reader - New Window" title="Get Adobe Reader - New Window" border="0" /></a>
<a name="link_group_0"></a>
	</td>
      </tr>
    </table>

<a name="skipnav" title="Content starts here"><img src="/global_resources/images/_.gif" alt="Content starts here" border="0" height="1" width="1" /></a>



<h1 class="pChapHead"><a name="wp1030997"> </a>
CORBA Server Application Concepts
</h1>
<p class="pBody"><a name="wp1022236"> </a>
This topic includes the following sections:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022239"> </a><a href="concepts.html#wp1022295">The Entities You Create to Build a CORBA Server Application</a>:</li>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1022243"> </a><a href="concepts.html#wp1022317">The Implementation of the CORBA Objects for Your Server Application</a></li>
<li><a name="wp1022247"> </a><a href="concepts.html#wp1022449">The Server Object</a></li>
</ul></div>
<li><a name="wp1022251"> </a><a href="concepts.html#wp1022465">Process for Developing CORBA Server Applications</a>:</li>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1022255"> </a><a href="concepts.html#wp1022493">Generating Object References</a></li>
<li><a name="wp1022259"> </a><a href="concepts.html#wp1022539">Managing Object State</a></li>
<li><a name="wp1022263"> </a><a href="concepts.html#wp1022649">Reading and Writing an Object&#8217;s Data</a></li>
<li><a name="wp1022267"> </a><a href="concepts.html#wp1025990">Using Design Patterns</a></li>
</ul></div>
</ul></div>
<p class="pBody"><a name="wp1022270"> </a>
Each of the chapters in this book gives procedures for and examples of building CORBA server applications that take advantage of various Oracle Tuxedo software features. For background information about Oracle Tuxedo CORBA server applications and how they work, see <a href="../getstart/index.html">Getting Started with Oracle Tuxedo CORBA Applications</a>.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1022295"> </a>
The Entities You Create to Build a CORBA Server Application
</h2><p class="pBody"><a name="wp1022299"> </a>
To build a CORBA server application, you create the following two entities:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022301"> </a>The implementation of the CORBA objects that execute your server application&#8217;s business logic.</li>
<li><a name="wp1022302"> </a>The Server object, which implements the operations that initialize and release the server application and instantiate the CORBA objects needed to satisfy client requests.</li>
</ul></div>
<p class="pBody"><a name="wp1022303"> </a>
There are also a number of files that you work with that are generated by the IDL compiler and that you build into a CORBA server application. These files are listed and described in <a href="maksrv.html">Steps for Creating an Oracle Tuxedo CORBA Server Application.</a>
</p>
<p class="pBody"><a name="wp1022310"> </a>
The sections that follow provide introductory information about these entities. For complete details about how to generate these components, see <a href="maksrv.html">Steps for Creating an Oracle Tuxedo CORBA Server Application.</a>
</p>
<h3 class="pHeading2"><a name="wp1022317"> </a>
The Implementation of the CORBA Objects for Your Server Application
</h3>
<p class="pBody"><a name="wp1022318"> </a>
Having a clear understanding of what CORBA objects are, and how they are defined, implemented, instantiated, and managed is critical for the person who is designing or creating a CORBA server application.
</p>
<p class="pBody"><a name="wp1022319"> </a>
The CORBA objects for which you have defined interfaces in the Object Management Group Interface Definition Language (OMG IDL) contain the business logic and data for your CORBA server applications. All client application requests involve invoking an operation on a CORBA object. The code you write that implements the operations defined for an interface is called an object implementation. For example, in C++, the object implementation is a C++ class.
</p>
<p class="pBody"><a name="wp1022323"> </a>
This topic includes the following sections:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022324"> </a>How OMG IDL interface definitions establish the operations that can be invoked on a CORBA object</li>
<li><a name="wp1022325"> </a>How you implement the operations on a CORBA object</li>
<li><a name="wp1022326"> </a>How client applications access and manipulate your application&#8217;s CORBA objects</li>
<li><a name="wp1022327"> </a>How you instantiate a CORBA object with code and data at run time in response to a client request</li>
</ul></div>
<h4 class="pHeading3"><a name="wp1022333"> </a>
How Interface Definitions Establish the Operations on a CORBA Object
</h4>
<p class="pBody"><a name="wp1022334"> </a>
A CORBA object&#8217;s interface identifies the operations that can be performed on it. A distinguishing characteristic of CORBA objects is that an object&#8217;s interface definition is separate from its implementation. The definition for the interface establishes how the operations on the interface must be implemented, including what the valid parameters are that can be passed to and returned from an operation.
</p>
<p class="pBody"><a name="wp1022335"> </a>
An interface definition, which is expressed in OMG IDL, establishes the client/server contract for an application. That is, for a given interface, the server application is bound to do the following:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022336"> </a>Implement the operations defined for that interface</li>
<li><a name="wp1022337"> </a>Always use the parameters defined with each operation</li>
</ul></div>
<p class="pBody"><a name="wp1022338"> </a>
How the server application implements the operations may change over time. This is acceptable behavior as long as the server application continues to meet the requirement of implementing the defined interface and using the defined parameters. In this way, the client stub is always a reliable proxy for the object implementation on the server machine. This underscores one of the key architectural strengths of CORBA&#8212;that you can change how a server application implements an object over time without requiring the client application to be modified or even to be aware that the object implementation has changed.
</p>
<p class="pBody"><a name="wp1022339"> </a>
The interface definition also determines the content of both the client stub and the skeleton in the server application; these two entities, in combination with the ORB and the Portable Object Adapter (POA), ensure that a client request for an operation on an object can be routed to the code in the server application that can satisfy the request. 
</p>
<p class="pBody"><a name="wp1022340"> </a>
Once the system designer has specified the interfaces of the business objects in the application, the programmer&#8217;s job is to implement those interfaces. This book explains how.
</p>
<p class="pBody"><a name="wp1022343"> </a>
For more information about OMG IDL, see <a href="../creclient/index.html">Creating CORBA Client Applications</a>. 
</p>
<h4 class="pHeading3"><a name="wp1022346"> </a>
How You Implement the Operations on a CORBA Object
</h4>
<p class="pBody"><a name="wp1022347"> </a>
As stated earlier, the code that implements the operations defined for a CORBA object&#8217;s interface is called an object implementation. For C++, this code consists of a set of methods, one for each of the operations defined for the interfaces in your application&#8217;s OMG IDL file. The file containing the set of object implementations for your application is known as an implementation file. The Oracle Tuxedo system provides an IDL compiler, which compiles your application&#8217;s OMG IDL file to produce several files, one being an implementation file, shown in the following figure.
</p>
<p class="pGraphic"><a name="wp1024416"> </a>
</p>
<div class="figure" align="left"><img src="wwimages/idlconc.gif" height="95" width="469" id="wp1024432"/></div><p class="pGraphic">

</p>
<p class="pBody"><a name="wp1022355"> </a>
The generated implementation file contains method templates, method declarations, object constructors and destructors, and other data that you can use as a starting place for writing your application&#8217;s object implementations. For example, in C++, the generated implementation file contains signatures for each interface&#8217;s methods. You enter the business logic for each method in this file, and then provide this file as input to the command that builds the executable server application file.
</p>
<h4 class="pHeading3"><a name="wp1022359"> </a>
How Client Applications Access and Manipulate Your Application&#8217;s CORBA Objects
</h4>
<p class="pBody"><a name="wp1022360"> </a>
Client applications access and manipulate the CORBA objects managed by the server application via <b style="font-style: italic" class="cBold">object references</b> to those objects. Client applications invoke operations (that is, requests) on an object reference. These requests are sent as messages to the server application, which invokes the appropriate operations on CORBA objects. The fact that these requests are sent to the server application and invoked in the server application is completely transparent to the client; client applications appear simply to be making invocations on the client stub. 
</p>
<p class="pBody"><a name="wp1022361"> </a>
Client applications may manipulate a CORBA object only by means of an object reference. One primary design consideration is how to create object references and return them to the client applications that need them in a way that is appropriate for your application.
</p>
<p class="pBody"><a name="wp1022364"> </a>
Typically, object references to CORBA objects are created in the Oracle Tuxedo system by <b style="font-style: italic" class="cBold">factories</b>. A factory is any CORBA object that returns, as one of its operations, a reference to another CORBA object. You implement your application&#8217;s factories the same way that you implement other CORBA objects defined for your application. You can make your factories widely known to the Oracle Tuxedo domain, and to clients connected to the Oracle Tuxedo domain, by registering them with the FactoryFinder. Registering a factory is an operation typically performed by the Server object, which is described in the section <a href="concepts.html#wp1022449"><span class="cHyperlink">
The Server Object on page&#160;1-7</span></a>. For more information about designing factories, see the section <a href="concepts.html#wp1022493"><span class="cHyperlink">
Generating Object References on page&#160;1-8</span></a>.
</p>
<h5 class="pHeading4"><a name="wp1022379"> </a>
The Content of an Object Reference
</h5>
<p class="pBody"><a name="wp1022380"> </a>
From the client application&#8217;s perspective, an object reference is opaque; it is like a black box that client applications use without having to know what is inside. However, object references contain all the information needed for the Oracle Tuxedo system to locate a specific object instance and to locate any state data that is associated with that object.
</p>
<p class="pBody"><a name="wp1022384"> </a>
An object reference contains the following information:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022385"> </a>The interface name</li>
<p class="pBodyRelative"><a name="wp1022386"> </a>
This is the Interface Repository ID of the object&#8217;s OMG IDL interface.
</p>
<li><a name="wp1022387"> </a>The object ID (OID)</li>
<p class="pBodyRelative"><a name="wp1022388"> </a>
The OID uniquely identifies the instance of the object to which the reference applies. If the object has data in external storage, the OID also typically includes a key that the server machine can use to locate the object&#8217;s data.
</p>
<li><a name="wp1022389"> </a>Group ID</li>
<p class="pBodyRelative"><a name="wp1022390"> </a>
The group ID identifies the server group to which the object reference is routed when a client application makes a request using that object reference. Generating a nondefault group ID is part of a key Oracle Tuxedo feature called factory-based routing, which is described in the section <a href="scale.html#wp1023981"><span class="cHyperlink">
Factory-based Routing on page&#160;8-11</span></a>.
</p>
</ul></div>
<a name="wp1022397"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The combination of the three items in the preceding list uniquely identifies the CORBA object. It is possible for an object with a given interface and OID to be simultaneously active in two different groups, if those two groups both contain the same object implementation. If you need to guarantee that only one object instance of a given interface name and OID is available at any one time in your domain, either: use factory-based routing to ensure that objects with a particular OID are always routed to the same group, or configure your domain so that a given object implementation is in only one group. This assures that if multiple clients have an object reference containing a given interface name and OID, the reference is always routed to the same object instance.</td>
</tr>
</table>

<a name="wp1022398"> </a><table class="Note">
<tr>
<td valign="top"><b class="texthide">Note:</b></td>
<td>For more information about factory-based routing, see the section <a href="scale.html#wp1023981">&quot;Factory-based Routing&quot; on page&#160;-11</a>.</td>
</tr>
</table>
<h5 class="pHeading4"><a name="wp1022403"> </a>
The Lifetime of an Object Reference
</h5>
<p class="pBody"><a name="wp1022406"> </a>
Object references created by server applications running in an Oracle Tuxedo domain typically have a usable lifespan that extends beyond the life of the server process that creates them. Oracle Tuxedo object references can be used by client applications regardless of whether the server processes that originally created them are still running. In this way, object references are not tied to a specific server process.
</p>
<p class="pBody"><a name="wp1022411"> </a>
An object reference created with the <code class="cCode">TP::create_active_object_reference()</code> operation is valid only for the lifetime of the server process in which it was created. For more information, see the section <a href="creasimp.html#wp1024360"><span class="cHyperlink">
Preactivating an Object with State on page&#160;3-15</span></a>.
</p>
<h5 class="pHeading4"><a name="wp1024709"> </a>
Passing Object Instances
</h5>
<p class="pBody"><a name="wp1024731"> </a>
The ORB cannot marshal an object instance as an object reference. For example, passing a factory reference in the following code fragment generates a CORBA marshal exception in the Oracle Tuxedo system:
</p>
<a name="wp1024710"> </a><div class="pPreformatted"><pre>connection::setFactory(this);</pre></div><p class="pBody"><a name="wp1024711"> </a>
To pass an object instance, you should create a proxy object reference and pass the proxy instead, as in the following example:
</p>
<a name="wp1024712"> </a><div class="pPreformatted"><pre>CORBA::Object myRef = TP::get_object_reference();<br />ResultSetFactory factoryRef = ResultSetFactoryHelper::_narrow(myRef);<br />connection::setFactoryRef(factoryRef);</pre></div><h4 class="pHeading3"><a name="wp1022417"> </a>
How You Instantiate a CORBA Object at Run Time
</h4>
<p class="pBody"><a name="wp1022418"> </a>
When a server application receives a request for an object that is not mapped in the server machine&#8217;s memory (that is, the object is not active), the TP Framework invokes the <code class="cCode">Server::create_servant()</code>operation. The <code class="cCode">Server::create_servant()</code>operation is implemented in the Server object, which, as mentioned in the section <a href="concepts.html#wp1022317"><span class="cHyperlink">
The Implementation of the CORBA Objects for Your Server Application on page&#160;1-2</span></a>, is a component of a CORBA server application that you create.
</p>
<p class="pBody"><a name="wp1022425"> </a>
The <code class="cCode">Server::create_servant()</code>operation causes an instance of the CORBA object implementation to be mapped into the server machine&#8217;s memory. This instance of the object&#8217;s implementation is called the object&#8217;s <b style="font-style: italic" class="cBold">servant</b>. Formally speaking, a servant is an instance of the C++ class that implements an interface defined in the application&#8217;s OMG IDL file. The servant is generated via the C++ <code class="cCode">new</code> statement that you write in the <code class="cCode">Server::create_servant()</code>operation.
</p>
<p class="pBody"><a name="wp1022426"> </a>
After the object&#8217;s servant has been created, the TP Framework invokes the <code class="cCode">Tobj_ServantBase::activate_object()</code> operation on the servant. The <code class="cCode">Tobj_ServantBase::activate_object()</code> operation is a virtual operation that is defined on the <code class="cCode">Tobj_ServantBase</code> base class, from which all object implementation classes inherit. The TP Framework invokes the <code class="cCode">Tobj_ServantBase::activate_object()</code> operation to tie the servant to an object ID (OID). (Conversely, when the TP Framework invokes the <code class="cCode">Tobj_ServantBase::deactivate_object()</code> operation on an object, the servant&#8217;s association with the OID is broken.)
</p>
<p class="pBody"><a name="wp1022427"> </a>
If your object has data on disk that you want to read into memory when the CORBA object is activated, you can have that data read by defining and implementing the <code class="cCode">Tobj_ServantBase::activate_object()</code> operation on the object. The <code class="cCode">Tobj_ServantBase::activate_object()</code> operation can contain the specific read operations required to bring an object&#8217;s durable state into memory. (There are circumstances in which you may prefer instead to have an object&#8217;s disk data read into memory by one or more separate operations on the object that you may have coded in the implementation file. For more information, see the section <a href="concepts.html#wp1022649"><span class="cHyperlink">
Reading and Writing an Object&#8217;s Data on page&#160;1-14</span></a>.) After the invocation of the <code class="cCode">Tobj_ServantBase::activate_object()</code> operation is complete, the object is said to be active.
</p>
<p class="pBody"><a name="wp1022431"> </a>
This collection of the object&#8217;s implementation and data compose the run-time, active instance of the CORBA object.
</p>
<h5 class="pHeading4"><a name="wp1025782"> </a>
Servant Pooling
</h5>
<p class="pBody"><a name="wp1025789"> </a>
Servant pooling provides your CORBA server application the opportunity to keep a servant in memory after the servant&#8217;s association with a specific OID has been broken. When a client request that can be satisfied with a pooled servant arrives, the TP Framework bypasses the <code class="cCode">TP::create_servant</code> operation and creates a link between the pooled servant and the OID provided in the client request.
</p>
<p class="pBody"><a name="wp1022443"> </a>
Servant pooling thus provides the CORBA server application with a means to minimize the costs of reinstantiating a servant each time a request arrives for an object that can be satisfied by that servant. For more information about servant pooling and how to use it, see the section <a href="maksrv.html#wp1023763"><span class="cHyperlink">
Servant Pooling on page&#160;2-25</span></a>.
</p>
<a name="wp1025746"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Servant pooling was first introduced in release 4.2 of the WebLogic Enterprise product. </td>
</tr>
</table>

<h3 class="pHeading2"><a name="wp1022449"> </a>
The Server Object
</h3>
<p class="pBody"><a name="wp1022452"> </a>
The Server object is the other programming code entity that you create for a CORBA server application. The Server object implements operations that execute the following tasks:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022454"> </a>Performing basic server application initialization operations, which may include registering factories<em class="cEmphasis"> </em>managed by the server application and allocating resources needed by the server application. If the server application is transactional, the Server object also implements the code that opens an XA resource manager.</li>
<li><a name="wp1022455"> </a>Instantiating the CORBA objects needed to satisfy client requests.</li>
<li><a name="wp1022456"> </a>Performing server process shutdown and cleanup procedures when the server application has finished servicing requests. For example, if the server application is transactional, the Server object also implements the code that closes the XA resource manager.</li>
</ul></div>
<p class="pBody"><a name="wp1022457"> </a>
You create the Server object from scratch, using a common text editor. You then provide the Server object as input into the server application build command, <code class="cCode">buildobjserver</code>. For more information about creating the Server object, see <a href="maksrv.html">Steps for Creating an Oracle Tuxedo CORBA Server Application.</a>
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1022465"> </a>
Process for Developing CORBA Server Applications
</h2><p class="pBody"><a name="wp1022467"> </a>
This section presents important background information about the following topics, which have a major influence on how you design and implement CORBA server applications: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022473"> </a><a href="concepts.html#wp1022493">Generating Object References</a></li>
<li><a name="wp1022477"> </a><a href="concepts.html#wp1022539">Managing Object State</a></li>
<li><a name="wp1022481"> </a><a href="concepts.html#wp1022649">Reading and Writing an Object&#8217;s Data</a></li>
<li><a name="wp1022485"> </a><a href="concepts.html#wp1025990">Using Design Patterns</a></li>
</ul></div>
<p class="pBody"><a name="wp1022487"> </a>
It is not essential that you read these topics before proceeding to the next chapter; however, this information is located here because it applies broadly to fundamental design and implementation issues for all CORBA server applications.
</p>
<h3 class="pHeading2"><a name="wp1022493"> </a>
Generating Object References
</h3>
<p class="pBody"><a name="wp1022496"> </a>
One of the most basic functions of a CORBA server application is providing client applications with object references to the objects they need to execute their business logic. CORBA client applications typically get object references to the initial CORBA objects they use from the following two sources:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022498"> </a>The <b class="cBold">Bootstrap object</b></li>
<li><a name="wp1022501"> </a><b class="cBold">Factories</b> managed in the Oracle Tuxedo domain</li>
</ul></div>
<p class="pBody"><a name="wp1022503"> </a>
Client applications use the Bootstrap object to resolve initial references to a specific set of objects in the Oracle Tuxedo domain, such as the FactoryFinder and the SecurityCurrent objects. The Bootstrap object is described in <a href="../getstart/index.html">Getting Started with Oracle Tuxedo CORBA Applications</a> and <a href="../creclient/index.html">Creating CORBA Client Applications</a>.
</p>
<p class="pBody"><a name="wp1022513"> </a>
Factories, however, are designed, implemented and registered by you, and they provide the means by which client applications get references to objects in the CORBA server application, particularly the initial server application object. At its simplest, a factory is a CORBA object that returns an object reference to another CORBA object. The client application typically invokes an operation on a factory to obtain an object reference to a CORBA object of a specific type. Planning and implementing your factories carefully is an important task when developing CORBA server applications.
</p>
<h4 class="pHeading3"><a name="wp1022522"> </a>
How Client Applications Find Your Server Application&#8217;s Factories
</h4>
<p class="pBody"><a name="wp1022523"> </a>
Client applications are able to locate via the FactoryFinder the factories managed by your server application. When you develop the Server object, you typically include code that registers with the FactoryFinder any factories managed by the server application. It is via this registration operation that the FactoryFinder keeps track of your server application&#8217;s factories and can provide object references to them to the client applications that request them. We recommend that you use factories and register them with the FactoryFinder; this model makes it simple for client applications to find the objects in your CORBA server application.
</p>
<h4 class="pHeading3"><a name="wp1022527"> </a>
Creating an Active Object Reference
</h4>
<p class="pBody"><a name="wp1022530"> </a>
An active object reference is a feature that gives an alternate means through which your server application can generate object references. Active object references are not typically created by factories as described in the previous section, and active object references are meant for preactivating objects with state. The next section discusses object state in more detail.
</p>
<p class="pBody"><a name="wp1022532"> </a>
While an object associated with a conventional object reference is not instantiated until a client application makes an invocation on the object, the object associated with an active object reference is created and activated at the time the active object reference is created. Active object references are especially convenient for specific purposes, such as iterator objects. The section <a href="creasimp.html#wp1024360"><span class="cHyperlink">
Preactivating an Object with State on page&#160;3-15</span></a> provides more information about active object references.
</p>
<a name="wp1025906"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>The active object reference feature was first introduced in WebLogic Enterprise version 4.2.</td>
</tr>
</table>

<h3 class="pHeading2"><a name="wp1022539"> </a>
Managing Object State
</h3>
<p class="pBody"><a name="wp1022540"> </a>
Object state management is a fundamentally important concern of large-scale client/server systems, because it is critical that such systems optimize throughput and response time. The majority of high-throughput applications, such as applications you run in an Oracle Tuxedo domain, tend to be stateless, meaning that the system flushes state information from memory after a service or an operation has been fulfilled. 
</p>
<p class="pBody"><a name="wp1022541"> </a>
Managing state is an integral part of writing CORBA-based server applications. Typically, it is difficult to manage state in these server applications in a way that scales and performs well. The Oracle Tuxedo software provides an easy way to manage state and simultaneously ensure scalability and high performance. 
</p>
<p class="pBody"><a name="wp1022545"> </a>
The scalability qualities that you can build into a CORBA server application help the server application function well in an environment that includes hundreds or thousands of client applications, multiple machines, replicated server processes, and a proportionately greater number of objects and client invocations on those objects.
</p>
<h4 class="pHeading3"><a name="wp1022547"> </a>
About Object State
</h4>
<p class="pBody"><a name="wp1022548"> </a>
In an Oracle Tuxedo domain, <b style="font-style: italic" class="cBold">object state</b> refers specifically to the process state of an object across client invocations on it. The Oracle Tuxedo software uses the following definitions of stateless and stateful objects shown in <a href="concepts.html#wp1032339">Table&#160;1-1</a>:
</p>
<p class="pGraphic"><a name="wp1022569"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1032339table1022552"><caption><a name="wp1032339"> </a>
Table 1-1  <span style="font-style: normal; font-weight: bold; text-decoration: none; vertical-align: baseline">About Object State</span>

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1022554"> </a>
Object
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1022556"> </a>
Behavior Characteristics
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1022558"> </a>
Stateless
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1022560"> </a>
The object is mapped into memory only for the duration of an invocation on one of the object&#8217;s operations, and is deactivated and has its process state flushed from memory after the invocation is complete; that is, the object&#8217;s state is not maintained in memory after the invocation is complete.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1022562"> </a>
Stateful
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1022564"> </a>
The object remains activated between invocations on it, and its state is maintained in memory across those invocations. The state remains in memory until a specific event occurs, such as:
</div>
<div class="pSmartList1TableBullet"><ul class="SmartList1TableBullet">
<li><a name="wp1022565"> </a>The server process in which the object exists is stopped or is shut down</li>
<li><a name="wp1022566"> </a>The transaction in which the object is participating is either committed or rolled back</li>
<li><a name="wp1022567"> </a>The object invokes the <code class="cCode">TP::deactivateEnable()</code> operation on itself.</li>
</ul></div>
<div class="pCellBody"><a name="wp1022568"> </a>
Each of these events is discussed in more detail in this section.
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<p class="pBody"><a name="wp1022570"> </a>
Both stateless and stateful objects have data; however, stateful objects may have nonpersistent data in memory that is required to maintain context (state) between operation invocations on those objects. Thus, subsequent invocations on such a stateful object always go to the same servant. Conversely, invocations on a stateless object can be directed by the Oracle Tuxedo system to any available server process that can activate the object.
</p>
<p class="pBody"><a name="wp1022574"> </a>
State management also involves how long an object remains active, which has important implications on server performance and the use of machine resources. The duration of an active object is determined by <b style="font-style: italic" class="cBold">object activation policies</b> that you assign to an object&#8217;s interface, described in the section that follows.
</p>
<p class="pBody"><a name="wp1022575"> </a>
Object state is transparent to the client application. Client applications implement a conversational model of interaction with distributed objects. As long as a client application has an object reference, it assumes that the object is always available for additional requests, and the object appears to be maintained continuously in memory for the duration of the client application interaction with it.
</p>
<p class="pBody"><a name="wp1022576"> </a>
To achieve optimal application performance, you need to carefully plan how your application&#8217;s objects manage state. Objects are required to save their state to durable storage, if applicable, before they are deactivated. Objects must also restore their state from durable storage, if applicable, when they are activated. For more information about reading and writing object state information, see the section <a href="concepts.html#wp1022649"><span class="cHyperlink">
Reading and Writing an Object&#8217;s Data on page&#160;1-14</span></a>.
</p>
<a name="wp1028911"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Oracle Tuxedo Release 8.0 or later provides support for parallel objects, as a performance enhancement. This feature allows you to designate all business objects in a particular application as stateless objects. For complete information, see Chapter&#160;3, &#8220;TP Framework,&#8221; in the <a href="../CORBA_ref/index.html">CORBA Programming Reference</a>.</td>
</tr>
</table>

<h4 class="pHeading3"><a name="wp1022582"> </a>
Object Activation Policies
</h4>
<p class="pBody"><a name="wp1022583"> </a>
The Oracle Tuxedo software provides three object activation policies that you can assign to an object&#8217;s interface to determine how long an object remains in memory after it has been invoked by a client request. These policies determine whether the object to which they apply is generally stateless or stateful.
</p>
<p class="pBody"><a name="wp1022584"> </a>
The three policies are listed and described in <a href="concepts.html#wp1032359">Table&#160;1-2</a>.
</p>
<p class="pGraphic"><a name="wp1022617"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1032359table1022585"><caption><a name="wp1032359"> </a>
Table 1-2  Object Activation Policies

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1022587"> </a>
Policy
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1022589"> </a>
Description
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1022591"> </a>
<code class="cCode">Method</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1022593"> </a>
Causes the object to be active only for the duration of the invocation on one of the object&#8217;s operations; that is, the object is activated at the beginning of the invocation, and is deactivated at the end of the invocation. An object with this activation policy is called a <em class="cEmphasis">method-bound object.</em>
</div>
<div class="pCellBody"><a name="wp1022594"> </a>
The <code class="cCode">method</code> activation policy is associated with stateless objects. This activation policy is the default.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1022596"> </a>
<code class="cCode">Transaction</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1022598"> </a>
Causes the object to be activated when an operation is invoked on it. If the object is activated within the scope of a transaction, the object remains active until the transaction is either committed or rolled back. If the object is activated outside the scope of a transaction, its behavior is the same as that of a method-bound object. An object with this activation policy is called a <em class="cEmphasis">transaction-bound object.</em>
</div>
<div class="pCellBody"><a name="wp1022599"> </a>
For more information about object behavior within the scope of a transaction, and general guidelines about using this policy, see <a href="trans.html">Integrating Transactions into a CORBA Server Application.</a>
</div>
<div class="pCellBody"><a name="wp1022603"> </a>
The <code class="cCode">transaction</code> activation policy is associated with stateful objects for a limited time and under specific circumstances.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1022605"> </a>
<code class="cCode">Process</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1022607"> </a>
Causes the object to be activated when an operation is invoked on it, and to be deactivated only under the following circumstances:
</div>
<div class="pSmartList1TableBullet"><ul class="SmartList1TableBullet">
<li><a name="wp1022608"> </a>The server process that manages this object is shut down.</li>
<li><a name="wp1022609"> </a>An operation on this object invokes the <code class="cCode">TP::deactivateEnable()</code> operation, which causes this object to be deactivated. (This is part of a key Oracle Tuxedo feature called application-controlled deactivation, which is described in the section <a href="concepts.html#wp1022624">&quot;Application-controlled Deactivation&quot; on page&#160;-13</a>.</li>
</ul></div>
<div class="pCellBody"><a name="wp1022616"> </a>
An object with this activation policy is called a <em class="cEmphasis">process-bound object.</em> The <code class="cCode">process</code> activation policy is associated with stateful objects.
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<p class="pBody"><a name="wp1022618"> </a>
You determine what events cause an object to be deactivated by assigning object activation policies. For more information about how you assign object activation policies to an object&#8217;s interface, see the section <a href="maksrv.html#wp1023414"><span class="cHyperlink">
Step 4: Define the In-memory Behavior of Objects on page&#160;2-13</span></a>.
</p>
<h4 class="pHeading3"><a name="wp1022624"> </a>
Application-controlled Deactivation
</h4>
<p class="pBody"><a name="wp1022627"> </a>
The Oracle Tuxedo software also provides a feature called <b style="font-style: italic" class="cBold">application-controlled deactivation</b>, which provides a means for an application to deactivate an object during run time. The Oracle Tuxedo software provides the <code class="cCode">TP::deactivateEnable()</code> operation, which a process-bound object can invoke on itself. When invoked, the <code class="cCode">TP::deactivateEnable()</code> operation causes the object in which it exists to be deactivated upon completion of the current client invocation on that object. An object can invoke this operation only on itself; you cannot invoke this operation on any object but the object in which the invocation is made.
</p>
<p class="pBody"><a name="wp1022632"> </a>
The application-controlled deactivation feature is particularly useful when you want an object to remain in memory for the duration of a limited number of client invocations on it, and you want the client application to be able to tell the object that the client is finished with the object. At this point, the object takes itself out of memory.
</p>
<p class="pBody"><a name="wp1022633"> </a>
Application-controlled deactivation, therefore, allows an object to remain in memory in much the same way that a process-bound object can: the object is activated as a result of a client invocation on it, and it remains in memory after the initial client invocation on it is completed. You can then deactivate the object without having to shut down the server process in which the object exists.
</p>
<p class="pBody"><a name="wp1022634"> </a>
An alternative to application-controlled deactivation is to scope a transaction to maintain a conversation between a client application and an object; however, transactions are inherently more costly, and transactions are generally inappropriate in situations where the duration of the transaction may be indefinite. 
</p>
<p class="pBody"><a name="wp1022635"> </a>
A good rule of thumb to use when choosing between application-controlled deactivation and transactions for a conversation is whether there are any disk writing operations involved. If the conversation involves read-only operations, or involves maintaining state only in memory, then application-controlled deactivation is appropriate. If the conversation involves writing data to disk during or at the end of the conversation, transactions may be more appropriate.
</p>
<a name="wp1022636"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>If you use application-controlled deactivation to implement a conversational model between a client application and an object managed by the server application, make sure that the object eventually invokes the <code class="cCode">TP::deactivateEnable()</code> operation. Otherwise, the object remains idle in memory indefinitely. (Note that this can be a risk if the client application crashes before the <code class="cCode">TP::deactivateEnable()</code> operation is invoked. Transactions, on the other hand, implement a timeout mechanism to prevent the situation in which the object remains idle for an indefinite period. This may be another consideration when choosing between the two conversational models.)</td>
</tr>
</table>

<p class="pBody"><a name="wp1022637"> </a>
You implement application-controlled deactivation in an object using the following procedure:
</p>
<div class="pSmartList1"><ol type="1" class="pSmartList1">
<li><a name="wp1022638"> </a>In the implementation file, insert an invocation to the <code class="cCode">TP::deactivateEnable()</code> operation at the appropriate location within the operation of the interface that uses application-controlled deactivation.</li>
<li><a name="wp1022639"> </a>In the Implementation Configuration File (ICF file), assign the <code class="cCode">process</code> activation policy to the interface that contains the operation that invokes the <code class="cCode">TP::deactivateEnable()</code> operation.</li>
<li><a name="wp1022642"> </a>Build and deploy your application as described in the sections <a href="maksrv.html#wp1023495"><span class="cHyperlink">
Step 5: Compile and Link the Server Application on page&#160;2-16</span></a> and <a href="maksrv.html#wp1023514"><span class="cHyperlink">
Step 6: Deploy the Server Application on page&#160;2-16</span></a>.</li>
</ol></div>
<h3 class="pHeading2"><a name="wp1022649"> </a>
Reading and Writing an Object&#8217;s Data
</h3>
<p class="pBody"><a name="wp1022650"> </a>
Many of the CORBA objects managed by the server application may have data that is in external storage. This externally stored data may be regarded as the <em class="cEmphasis">persistent</em> or<em class="cEmphasis"> durable</em> state of the object. You must address durable state handling at appropriate points in the object implementation for object state management to work correctly.
</p>
<p class="pBody"><a name="wp1022651"> </a>
Because of the wide variety of requirements you may have for your client/server application with regards to reading and writing an object&#8217;s durable state, the TP Framework cannot automatically handle durable object state on disk. In general, if an object&#8217;s durable state is modified as a result of one or more client invocations, you must make sure that durable state is saved before the object is deactivated, and you should plan carefully how the object&#8217;s data is stored or initialized while the object is active.
</p>
<p class="pBody"><a name="wp1022652"> </a>
The sections that follow describe the mechanisms available to you to handle an object&#8217;s durable state, and give some general advice how to read and write object state under specific circumstances. The specific topics presented include:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022653"> </a>The available mechanisms for reading and writing an object&#8217;s durable state</li>
<li><a name="wp1022654"> </a>Reading state at object activation</li>
<li><a name="wp1022655"> </a>Reading state within individual operations on an object</li>
<li><a name="wp1022656"> </a>Stateless objects and durable state</li>
<li><a name="wp1022657"> </a>Stateful objects and durable state</li>
<li><a name="wp1022658"> </a>Your responsibilities for object deactivation</li>
<li><a name="wp1022659"> </a>Avoiding unnecessary I/O</li>
</ul></div>
<p class="pBody"><a name="wp1022660"> </a>
How you choose to read and write durable state invariably depends on the specific requirements of your client/server application, especially with regard to how the data is structured. In general, your priority should be to minimize the number of disk operations, especially where a database controlled by an XA resource manager is involved.
</p>
<h4 class="pHeading3"><a name="wp1022661"> </a>
Available Mechanisms for Reading and Writing an Object&#8217;s Durable State
</h4>
<p class="pBody"><a name="wp1022664"> </a>
<a href="concepts.html#wp452220">Table&#160;1-3</a> and <a href="concepts.html#wp452246">Table&#160;1-4</a> describe the available mechanisms for reading and writing an object&#8217;s durable state.
</p>
<p class="pGraphic"><a name="wp1031164"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp452220table1022671"><caption><a name="wp452220"> </a>
Table 1-3  Available Mechanisms for Reading an Object&#8217;s Durable State

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1023829"> </a>
Mechanism
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1023831"> </a>
Description
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1023833"> </a>
<code class="cCode">Tobj_ServantBase::<br />activate_object()</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1023835"> </a>
After the TP Framework creates the servant for an object, the TP Framework invokes the <code class="cCode">Tobj_ServantBase::activate_object()</code> operation on that servant. As mentioned in the section <a href="concepts.html#wp1022417"><span class="cHyperlink">
How You Instantiate a CORBA Object at Run Time on page&#160;1-6</span></a>, this operation is defined on the <code class="cCode">Tobj_ServantBase</code> base class, from which all the CORBA objects you define for your client/server application inherit. 
</div>
<div class="pCellBody"><a name="wp1023839"> </a>
You may choose not to define and implement the <code class="cCode">Tobj_ServantBase::activate_object()</code> operation on your object, in which case nothing happens regarding specific object state handling when the TP Framework activates your object. However, if you define and implement this operation, you can choose to include code in this operation that reads some or all of an object&#8217;s durable state into memory. Therefore, the <code class="cCode">Tobj_ServantBase::activate_object()</code> operation provides your server application with its first opportunity to read an object&#8217;s durable state into memory.
</div>
<div class="pCellBody"><a name="wp1023840"> </a>
Note that if an object&#8217;s OID contains a database key, the <code class="cCode">Tobj_ServantBase::activate_object()</code> operation provides the only means the object has to extract that key from the OID.
</div>
<div class="pCellBody"><a name="wp1023841"> </a>
For more information about implementing the <code class="cCode">Tobj_ServantBase::activate_object()</code> operation, see <a href="maksrv.html#wp1023246"><span class="cHyperlink">
Step 2: Write the Methods That Implement Each Interface&#8217;s Operations on page&#160;2-5</span></a>. For an example of implementing the <code class="cCode">Tobj_ServantBase::activate_object()</code> operation, see <a href="creasimp.html">Designing and Implementing a Basic CORBA Server Application.</a>
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1023849"> </a>
Operations on the object
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1023851"> </a>
You can include inside the individual operations that you define on the object the code that reads an object&#8217;s durable state. 
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<p class="pGraphic"><a name="wp1022698"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp452246table1022699"><caption><a name="wp452246"> </a>
Table 1-4  Available Mechanisms for Writing an Object&#8217;s Durable State

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1022701"> </a>
Mechanism
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1022703"> </a>
Description
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1022705"> </a>
<code class="cCode">Tobj_ServantBase::<br />deactivate_object()</code>
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1022707"> </a>
When an object is being deactivated by the TP Framework, the TP Framework invokes this operation on the object as the final step of object deactivation. As with the <code class="cCode">Tobj_ServantBase::activate_object()</code> operation, the <code class="cCode">Tobj_ServantBase::deactivate_object()</code> operation is defined on the <code class="cCode">Tobj_ServantBase</code> class. You implement the <code class="cCode">deactivate_object()</code> operation on your object optionally if you have specific object state that you want flushed from memory or written to a database.
</div>
<div class="pCellBody"><a name="wp1022708"> </a>
The <code class="cCode">Tobj_ServantBase::deactivate_object()</code> operation provides the final opportunity your server application has to write durable state to disk before the object is deactivated. 
</div>
<div class="pCellBody"><a name="wp1022709"> </a>
If your object keeps any data in memory, or allocates memory for any purpose, you implement the <code class="cCode">Tobj_ServantBase::deactivate_object()</code> operation so your object has a final opportunity to flush that data from memory. Flushing any state from memory before an object is deactivated is critical in avoiding memory leaks.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1022711"> </a>
Operations on the object
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1022713"> </a>
As you may have individual operations on the objects that read durable state from disk, you may also have individual operations on the object that write durable state back to disk. 
</div>
<div class="pCellBody"><a name="wp1022714"> </a>
For method-bound and process-bound objects in general, you typically perform database write operations within these operations and not in the <code class="cCode">Tobj_ServantBase::deactivate_object()</code> operation.
</div>
<div class="pCellBody"><a name="wp1022715"> </a>
For transaction-bound objects, however, writing durable state in the <code class="cCode">Tobj_ServantBase::deactivate_object()</code> operation provides a number of object management efficiencies that may make sense for your transactional server applications.
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<a name="wp1022717"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>If you use the <code class="cCode">Tobj_ServantBase::deactivate_object()</code> operation to write any durable state to disk, any errors that occur while writing to disk are not reported to the client application. Therefore, the only circumstances under which you should write data to disk in this operation is when: the object is transaction-bound (that is, it has the <code class="cCode">transaction</code> activation policy assigned to it), or you scope the disk write operations within a transaction by invoking the TransactionCurrent object. Any errors encountered while writing to disk during a transaction can be reported back to the client application. For more information about using the <code class="cCode">Tobj_ServantBase::deactivate_object()</code> operation to write object state to disk, see the section <a href="maksrv.html#wp1023750"><span class="cHyperlink">
Caveat for State Handling in Tobj_ServantBase::deactivate_object() on page&#160;2-25</span></a>. </td>
</tr>
</table>

<h4 class="pHeading3"><a name="wp1022722"> </a>
Reading State at Object Activation
</h4>
<p class="pBody"><a name="wp1022723"> </a>
Using the <code style="font-style: normal" class="cCode">Tobj_ServantBase::activate_object()</code><span style="font-style: italic"> </span>operation on an object to read durable state may be appropriate when either of the following conditions exist:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022724"> </a>Object data is always used or updated in all the object&#8217;s operations.</li>
<li><a name="wp1022725"> </a>All the object&#8217;s data is capable of being read in one operation.</li>
</ul></div>
<p class="pBody"><a name="wp1022726"> </a>
The advantages of using the <code style="font-style: normal" class="cCode">Tobj_ServantBase::activate_object()</code><span style="font-style: italic"> </span>operation to read durable state include:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022727"> </a>You write code to read data only once, instead of duplicating the code in each of the operations that use that data.</li>
<li><a name="wp1022728"> </a>None of the operations that use an object&#8217;s data need to perform any reading of that data. In this sense, you can write the operations in a way that is independent of state initialization.</li>
</ul></div>
<h4 class="pHeading3"><a name="wp1022729"> </a>
Reading State Within Individual Operations on an Object
</h4>
<p class="pBody"><a name="wp1022730"> </a>
With all objects, regardless of activation policy, you can read durable state in each operation that needs that data. That is, you handle the reading of durable state outside the <code class="cCode">Tobj_ServantBase::activate_object()</code>operation. Cases where this approach may be appropriate include the following:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022731"> </a>Object state is made up of discrete data elements that require multiple operations to read or write.</li>
<li><a name="wp1022732"> </a>Objects do not always use or update state data at object activation.</li>
</ul></div>
<p class="pBody"><a name="wp1022733"> </a>
For example, consider an object that represents a customer&#8217;s investment portfolio. The object contains several discrete records for each investment. If a given operation affects only one investment in the portfolio, it may be more efficient to allow that operation to read the one record than to have a general-purpose <code class="cCode">Tobj_ServantBase::activate_object()</code> operation that automatically reads in the entire investment portfolio each time the object is invoked.
</p>
<h4 class="pHeading3"><a name="wp1022734"> </a>
Stateless Objects and Durable State
</h4>
<p class="pBody"><a name="wp1022735"> </a>
In the case of stateless objects&#8212;that is, objects defined with the <code class="cCode">method</code> activation policy&#8212;you must ensure the following:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022736"> </a>That any durable state needed by the request is brought into memory by the time the operation&#8217;s business logic starts executing.</li>
<li><a name="wp1022737"> </a>That any changes to the durable state are written out by the end of the invocation.</li>
</ul></div>
<p class="pBody"><a name="wp1022738"> </a>
The TP Framework invokes the <code class="cCode">Tobj_ServantBase::activate_object()</code> operation on an object at activation. If an object has an OID that contains a key to the object&#8217;s durable state on disk, the <code class="cCode">Tobj_ServantBase::activate_object() </code>operation provides the only opportunity the object has to retrieve that key from the OID.
</p>
<p class="pBody"><a name="wp1022739"> </a>
If you have a stateless object that you want to be able to participate in a transaction, we generally recommend that if the object writes any durable state to disk that it be done within individual methods on the object. However, if you have a stateless object that is always transactional&#8212;that is, a transaction is always scoped when this object is invoked&#8212;you have the option to handle the database write operations in the <code class="cCode">Tobj_ServantBase::deactivate_object()</code> operation, because you have a reliable mechanism in the XA resource manager to commit or roll back database write operations accurately.
</p>
<a name="wp1022740"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>Even if your object is method-bound, you may have to take into account the possibility that two server processes are accessing the same disk data at the same time. In this case, you may want to consider a concurrency management technique, the easiest of which is transactions. For more information about transactions and transactional objects, see <a href="trans.html">Integrating Transactions into a CORBA Server Application.</a></td>
</tr>
</table>

<h5 class="pHeading4"><a name="wp1022745"> </a>
Servant Pooling and Stateless Objects
</h5>
<p class="pBody"><a name="wp1022746"> </a>
Servant pooling is a particularly useful feature for stateless objects. When your CORBA server application pools servants, you can significantly reduce the costs of instantiating an object each time a client invokes it. As mentioned in the section <a href="concepts.html#wp1025782">&quot;Servant Pooling&quot; on page&#160;-7</a>, a pooled servant remains in memory after a client invocation on it is complete. If you have an application in which a given object is likely to be invoked repeatedly, pooling the servant means that only the object&#8217;s data, and not its methods, needs to be read into and out of memory for each client invocation. If the cost associated with reading an object&#8217;s methods into memory is high, servant pooling can reduce that cost.
</p>
<p class="pBody"><a name="wp1022755"> </a>
For information about how to implement servant pooling, see the section <a href="maksrv.html#wp1023763"><span class="cHyperlink">
Servant Pooling on page&#160;2-25</span></a>.
</p>
<h4 class="pHeading3"><a name="wp1022757"> </a>
Stateful Objects and Durable State
</h4>
<p class="pBody"><a name="wp1022758"> </a>
For stateful objects, you should read and write durable state only at the point where it is needed. This may introduce the following optimizations:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022759"> </a>In the case of process-bound objects, you avoid the situation in which an object allocates a large amount of memory over a long period.</li>
<li><a name="wp1022760"> </a>In the case of transaction-bound objects, you can postpone writing durable state until the <code class="cCode">Tobj_ServantBase::deactivate_object()</code> operation is invoked, when the transaction outcome is known.</li>
</ul></div>
<p class="pBody"><a name="wp1022761"> </a>
In general, transaction-bound objects must depend on the XA resource manager to handle all database write or rollback operations automatically.
</p>
<a name="wp1022762"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>For objects that are involved in a transaction, we do not support having those objects write data to external storage that is not managed by an XA resource manager.</td>
</tr>
</table>

<p class="pBody"><a name="wp1022765"> </a>
For more information about objects and transactions, see <a href="trans.html">Integrating Transactions into a CORBA Server Application.</a>
</p>
<h5 class="pHeading4"><a name="wp1022767"> </a>
Servant Pooling and Stateful Objects
</h5>
<p class="pBody"><a name="wp1022768"> </a>
Servant pooling does not make sense in the case of process-bound objects; however, depending on your application design, servant pooling may provide a performance improvement for transaction-bound objects.
</p>
<h4 class="pHeading3"><a name="wp1022769"> </a>
Your Responsibilities for Object Deactivation
</h4>
<p class="pBody"><a name="wp1022770"> </a>
As mentioned in the preceding sections, you implement the <code class="cCode">Tobj_ServantBase::deactivate_object()</code> operation as a means to write an object&#8217;s durable state to disk. You should also implement this operation on an object as a means to flush any remaining object data from memory so that the object&#8217;s servant can be used to activate another instance of that object. You should not assume that an invocation to an object&#8217;s <code class="cCode">Tobj_ServantBase::deactivate_object()</code> operation also results in an invocation of that object&#8217;s destructor.
</p>
<h4 class="pHeading3"><a name="wp1022771"> </a>
Avoiding Unnecessary I/O
</h4>
<p class="pBody"><a name="wp1022772"> </a>
Be careful not to introduce inefficiencies into the application by doing unnecessary I/O in objects. Situations to be aware of include the following:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022773"> </a>If many operations in an object do not use or affect object state, it may be inefficient to read and write state each time these operations are invoked. Design these objects so that they handle state only in the operations that need it; in such cases, you may not want to have all of the object&#8217;s durable state read in at object activation.</li>
<li><a name="wp1022774"> </a>If object state is made up of data that is read in multiple operations, try to do only the necessary operations at object activation by doing one of the following: </li>
<div class="pSmartList2Bullet"><ul>
<li><a name="wp1022775"> </a>Reading only the state that is common to all the operations in the <code class="cCode">Tobj_ServantBase::activate_object()</code> operation. Defer the reading of additional state to only the operations that require it.</li>
<li><a name="wp1022776"> </a>Writing out only the state that has changed. You can do this by managing flags that indicate the data that was changed during an activation, or by comparing before and after data images.</li>
<p class="pBodyRelative"><a name="wp1022777"> </a>
A general optimization is to initialize a <code class="cCode">dirtyState</code> flag on activation and to write data in the <code class="cCode">Tobj_ServantBase::deactivate_object() </code>operation only if the flag has been changed while the object was active. (Note that this works only if you can be assured that the object is always activated in the same server process.)
</p>
</ul></div>
</ul></div>
<h4 class="pHeading3"><a name="wp1022778"> </a>
Sample Activation Walkthrough
</h4>
<p class="pBody"><a name="wp1025987"> </a>
For examples of the sequence of activity that takes place when an object is activated, see <a href="../getstart/index.html">Getting Started with Oracle Tuxedo CORBA Applications</a>.
</p>
<h3 class="pHeading2"><a name="wp1025990"> </a>
Using Design Patterns
</h3>
<p class="pBody"><a name="wp1022786"> </a>
It is important to structure the business logic of your application around a well-formed design. The Oracle Tuxedo software provides a set of design patterns to address this need. A design pattern is simply a structured solution to a specific design problem. The value of a design pattern lies in its ability to be expressed in a form you can reuse and apply to other design problems.
</p>
<p class="pBody"><a name="wp1022792"> </a>
The Oracle Tuxedo design patterns are structured solutions to enterprise-class application design problems. You can use them to design successful large-scale client/server applications.
</p>
<p class="pBody"><a name="wp1022794"> </a>
The design patterns summarized here are a guide to using good design practices in CORBA client and server applications. They are an important and integral part of designing CORBA client and server applications, and the chapters in this book show examples of using these design patterns to implement the University sample applications.
</p>
<h4 class="pHeading3"><a name="wp1022803"> </a>
Process-Entity Design Pattern
</h4>
<p class="pBody"><a name="wp1022804"> </a>
The Process-Entity design pattern applies to a large segment of enterprise-class client/server applications. This design pattern is referred to as the flyweight pattern in <em class="cEmphasis">Object-Oriented Design Patterns</em>, Gamma et al., and as the Model-View-Controller in other publications. 
</p>
<p class="pBody"><a name="wp1022805"> </a>
In this pattern, the client application creates a long-lived process object that the client application interacts with to make requests. For example, in the University sample applications, this object might be the registrar that handles course browsing operations on behalf of the client application. The courses themselves are database entities and are not made visible to the client application.
</p>
<p class="pBody"><a name="wp1022806"> </a>
The advantages of the Process-Entity design pattern include:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1022807"> </a>You can achieve the advantages of a fine-grained object model without implementing fine-grained objects. Instead, you use CORBA <code class="cCode">struct </code>datatypes to simulate objects.</li>
<li><a name="wp1022808"> </a>Machine resource usage is optimized because there is only a single object mapped into memory: the process object. By contrast, if each database entity were activated into memory as a separate object instance, the number of objects that would need to be handled could overwhelm the machine&#8217;s resources quickly in a large-scale deployment. </li>
<li><a name="wp1022809"> </a>Because they are not exposed to the client application, database entities need not be implemented as CORBA objects. Instead, entities can be implemented as local language objects in the server process. This is a fundamental principle of three-tier designs, but it also accurately models the way in which many businesses operate (for example, a registrar at a real university). The individual who serves as the registrar at a university can handle a large course database for multiple students; you do not need an individual registrar for each individual student. Thus, the process object state is distinct from the entity object state.</li>
</ul></div>
<p class="pBody"><a name="wp1024183"> </a>
An example of applying the Process-Entity design pattern is described in <a href="creasimp.html">Designing and Implementing a Basic CORBA Server Application.</a> For complete details on the Process-Entity design pattern, see <a href="../tech_articles/index.html">Technical Articles</a>.
</p>
<h4 class="pHeading3"><a name="wp1024189"> </a>
List-Enumerator Design Pattern
</h4>
<p class="pBody"><a name="wp1024190"> </a>
The List-Enumerator design pattern also applies to a large segment of enterprise-class client/server applications. The List-Enumerator design pattern leverages a key Oracle Tuxedo feature, application-controlled object deactivation, to handle a cache of data that is stored and tracked in memory during several client invocations, and then to flush the data from memory when the data is no longer needed.
</p>
<p class="pBody"><a name="wp1022825"> </a>
An example of applying the List-Enumerator design pattern is described in <a href="creasimp.html">Designing and Implementing a Basic CORBA Server Application.</a>
</p>
<p class="pBody"><a name="wp1022827"> </a>
Object preactivation, which is an especially useful tool for implementing the List-Enumerator design, is described in the section <a href="creasimp.html#wp1024360"><span class="cHyperlink">
Preactivating an Object with State on page&#160;3-15</span></a>.
</p>
 
<br/>
    <table id="SummaryNotReq2" width="100%" border="0" cellpadding="0" cellspacing="0">
      <tr> 
        <td>
&nbsp;
<a href="concepts.html"><img id="LongDescNotReq8" src="/global_resources/images/backtop.gif" width="90" height="25" alt="Back to Top" title="Back to Top" border="0" /></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a accesskey="4" href="index.html"><img id="LongDescNotReq9" src="/global_resources/images/prevtop.gif" border="0" alt="Previous" /></a>&nbsp;
<a accesskey="5" href="maksrv.html"><img id="LongDescNotReq10" src="/global_resources/images/nexttop.gif" border="0" alt="Next" /></a>
<script language="Javascript1.1" type="text/javascript">
Copyright();
</script>
<noscript><a href="http://edocs.bea.com/copyright.html">&copy; BEA Systems</a></noscript>
        </td>
      </tr>
    </table>

<!-- WebAnalytics BEGIN -->

<!--#include virtual="/global_resources/edocs_wt.html"-->
      
<!-- WebAnalytics END -->

  </body>
</html>
