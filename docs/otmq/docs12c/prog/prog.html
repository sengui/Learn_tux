<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>

<!-- LOCALIZATION RELATED INFORMATION -->
<meta name="LOC_PROJ_ID" content="WLPF8.1" />
<meta name="LOC_OWNER" content="BEAJ" />
<meta name="LOC_STATUS" content="READY!" />
<meta name="LOC_COMMENT" content="LOC_COMMENT" />
<meta name="LOC_US_REV" content="" />
<meta name="LOC_US_CHANGE" content="" />
<meta name="LOC_US_SRCFILE" content="" />
<!-- LOCALIZATION RELATED INFORMATION -->

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="GENERATOR" content="Quadralay WebWorks AutoMap 2003 Platinum Edition for FrameMaker 8.6.6577.0" />
    <meta name="TEMPLATEBASE" content="BEA_WFP_Template_V1.04" />
    <meta name="LASTUPDATED" content="06/27/12 02:38:59" />
    <link rel="StyleSheet" href="/global_resources/edocs.css" type="text/css" media="all" />

<title>Oracle Tuxedo Message Queue Programming Guide</title>

<!-- BEA scripts begin -->

<script language="Javascript" src="/global_resources/js/banner.js" type="text/javascript"></script>
<!-- This script outputs the banner required for edocs documentation. -->

<script language="Javascript" src="floatwin.js" type="text/javascript"></script>
<!-- This script opens a new small floating window and puts TOC<i>&lt;name&gt;</i>.html and IX<i>&lt;name&gt;</i>.html files in it and sets a generic popup window code to enable the display of some viewlets in the WebLogic Platform Tour. -->

<script language="Javascript1.1" src="/global_resources/js/footer.js" type="text/javascript"></script>
<!-- This script outputs the footer with the correct copyright date and link to copyright page.-->

<script language="Javascript1.1" src="/global_resources/js/googlesearch4.js" type="text/javascript"></script>
<!-- This script outputs the google search form. -->

<script language="Javascript1.1" src="/global_resources/js/note.js" type="text/javascript"></script>
<!-- This script outputs a note such as a BETA note. -->

<script language="JavaScript1.1" src="/global_resources/js/search.js" type="text/javascript"></script>
<!-- This script is not for online documents. It is only used by the QuestAgent Java Applet for CD search indexes. -->

<!-- BEA scripts end -->

  </head>

  <body>


<script language="Javascript1.1" type="text/javascript">
GoogleURL();
</script><noscript>This script outputs the google search URL required for search on edocs documentation.</noscript>

<script language="Javascript1.1" type="text/javascript">
Banner();
</script><noscript>This script outputs the banner required for edocs documentation.</noscript>

<script language="Javascript1.1" type="text/javascript">
GoogleSearchCollection();
</script><noscript>This script outputs the google search parameters required for search on edocs documentation.</noscript>

<!-- page title -->
<h1 class="booktitle">Programming Guide
</h1>
<!-- page title end -->

    <table id="SummaryNotReq1" width="100%" border="0" align="left" cellpadding="2%" cellspacing="0">
      <tr> 
        <td>
&nbsp;&nbsp;&nbsp;&nbsp;
<a accesskey="4" href="index.html"><img id="LongDescNotReq1" src="/global_resources/images/doc_nav_prev.gif" border="0" alt="Previous" /></a>&nbsp;
<img id="LongDescNotReq2" src="/global_resources/images/doc_nav_next_grey1.gif" border="0" alt="Next" />&nbsp;
<img id="LongDescNotReq3" src="/global_resources/images/doc_nav_dots.gif" border="0" alt="" />&nbsp;
<a accesskey="1" href="javascript:OpenWindowToc();" onmouseover="window.status='Table of Contents'; return true" onfocus="window.status='Table of Contents'; return true" onmouseout="window.status=''; return true" onblur="window.status=''; return true" title="Open TOC in new window">      <img id="LongDescNotReq4" src="/global_resources/images/doc_nav_contents.gif" alt="Open TOC in new window" border="0" /></a>&nbsp;
&nbsp;
<a href="../pdf/prog.pdf" target="pdf"><img id="LongDescNotReq5" src="/global_resources/images/doc_nav_pdf.gif" width="59" height="44" alt="View as PDF - New Window" title="View as PDF - New Window" border="0" /></a>&nbsp;
<a href="http://www.adobe.com/products/acrobat/alternate.html" target="_blank"><img id="LongDescNotReq6" src="/global_resources/images/get_reader.gif" width="52" height="44" alt="Get Adobe Reader - New Window" title="Get Adobe Reader - New Window" border="0" /></a>
<a name="link_group_0"></a>
	</td>
      </tr>
    </table>

<a name="skipnav" title="Content starts here"><img src="/global_resources/images/_.gif" alt="Content starts here" border="0" height="1" width="1" /></a>



<h1 class="pChapHead"><a name="wp1043185"> </a>
Oracle Tuxedo Message Queue Programming Guide
</h1>
<p class="pBody"><a name="wp1058446"> </a>
This chapter contains the following topics:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1058552"> </a><a href="prog.html#wp1061506">Programmer Tasks</a></li>
<li><a name="wp1061264"> </a><a href="prog.html#wp1058606">Sending and Receiving Messages</a></li>
<li><a name="wp1058557"> </a><a href="prog.html#wp1058628">Using Filters</a></li>
<li><a name="wp1061273"> </a><a href="prog.html#wp1059001">Using Publish/Subscribe</a></li>
<li><a name="wp1061280"> </a><a href="prog.html#wp1059518">Using Recoverable Messaging</a></li>
<li><a name="wp1061285"> </a><a href="prog.html#wp1061002">Using Naming</a></li>
<li><a name="wp1061295"> </a><a href="prog.html#wp1061146">Using WS SAF</a></li>
<li><a name="wp1061301"> </a><a href="prog.html#wp1061160">Building Applications</a></li>
</ul></div>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1061506"> </a>
Programmer Tasks
</h2><p class="pBody"><a name="wp1061507"> </a>
Oracle Tuxedo Message Queue (OTMQ) provides the following features to Oracle Tuxedo application programmers:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1061508"> </a>A set of application programming interfaces to enqueue messages for subsequent process. The queuing service guarantees to execute the enqueue request successfully. A serial of application programming interfaces are provided to dequeue messages in synchronous or asynchronous way. </li>
<li><a name="wp1058533"> </a>The application program can use the same application programming interface as P2P messaging to do publish/subscribe operations. For more information, see <a href="prog.html#wp1059001">Using Publish/Subscribe</a>.</li>
<li><a name="wp1058534"> </a>Besides the message order pre-defined for one queue, the application program can filter the messages being dequeued from the queue by setting filters. For more information, see <a href="prog.html#wp1058628">Using Filters</a>.</li>
<li><a name="wp1058596"> </a>The application program can choose to Using Recoverable Messaging to make sure the message delivery to the target queue.</li>
<li><a name="wp1058598"> </a>Also the OTMQ supports flexible way to bind queue name and alias, which allows the programmer to decouple the programming and the configurations of queues. For more information, see <a href="prog.html#wp1061002">Using Naming</a>.</li>
</ul></div>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1058606"> </a>
Sending and Receiving Messages
</h2><p class="pBody"><a name="wp1058607"> </a>
OTMQ provides the basic queuing features.
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1058608"> </a>Application should first attach to a queue using <code class="cCode">tpqattach(3c</code>) before using queuing features and other advanced features provided by OTMQ.</li>
<li><a name="wp1058609"> </a>For message sending, application calls standard enqueue API<code class="cCode"> tpenqplus(3c)</code> with specified block, DIP and UMA, to determine whether messaging is synchronous or asynchronous, recoverable or not, and action to take when delivery failed as shown in </li>
<div class="pCodeTitle"><a name="wp1065253"> </a>
Listing&#160;1	   Synchronous OTMQ Queue and Enqueue Message Attachment
</div> <a name="wp1065254"> </a><div class="pPreformatted"><pre>#define MSG_CLAS_EXAMPLES            2000<br />#define MSG_TYPE_CLIENT_REQ             1<br /><br />TPQCTL ctl;<br />Q_ATTACH_CTL qattachctl;<br />char q_space[16] = &quot;QSPACE&quot;;<br />char q_name[128] = &quot;myqueue1&quot;;<br />long flags;<br /><br />/* join the application */<br />if (tpinit(NULL) == -1)<br />{<br />&#160;&#160;&#160;&#160;&#160;(void) fprintf(stderr, &quot;failed to join application: %s\n&quot;,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tpstrerror(tperrno));<br />&#160;&#160;&#160;&#160;&#160;exit(1);<br />}<br /><br />memset(&amp;qattachctl, 0x0, sizeof(qattachctl));<br />qattachctl.attachmode = TMQ_ATTACH_BY_NAME;<br />qattachctl.qtype = TMQ_ATTACH_PQ;<br />qattachctl.namespace_list = NULL;<br />qattachctl.namespace_list_len = 0;<br />qattachctl.timeout = 30;<br /><br />memset(&amp;ctl, 0x0, sizeof(ctl));<br />ctl.flags |= OTMQ;<br />flags = TPNOTRAN;<br /><br />if (tpqattach(q_space, q_name, &amp;ctl, &amp;qattachctl, flags) == -1)<br />{</pre></div><a name="wp1065255"> </a><div class="pPreformatted"><pre>&#160;&#160;&#160;&#160;&#160;(void) fprintf(stderr, &quot;failed to attach q[%s.%s]: %s\n&quot;, q_space,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;q_name, tpstrerror(tperrno));<br />&#160;&#160;&#160;&#160;&#160;(void) tpterm();<br />&#160;&#160;&#160;&#160;&#160;exit(1);<br />}<br /><br />/* get request buffer */<br />if ((reqstr = tpalloc(&quot;STRING&quot;, NULL, len)) == NULL)<br />{<br />&#160;&#160;&#160;&#160;&#160;(void) fprintf(stderr, &quot;unable to allocate STRING buffer: %s&quot;,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tpstrerror(tperrno));<br />&#160;&#160;&#160;&#160;&#160;exit(1);<br />}<br /><br />ctl.msg_class = MSG_CLAS_EXAMPLES;  /* user defined message class */<br />ctl.msg_type = MSG_TYPE_CLIENT_REQ; /* user defined message type */<br />ctl.block = OTMQ_DEL_WF;              /* use synchronous way */<br />ctl.DIP = OTMQ_DIP_MEM;               /* interest point */<br />ctl.uma = OTMQ_UMA_RTS;               /* undelivered message action - return to sender */<br />ctl.timeout = 30;<br /><br />/* enqueue the message into the destination queue */<br />if (tpenqplus(target_qspace, target_qname, &amp;ctl, reqstr, 0, 0) == -1)<br />{<br />&#160;&#160;&#160;&#160;&#160;(void) fprintf(stderr, &quot;Failure to enqueue  %s\n&quot;, &#160;&#160;&#160;&#160;&#160;tpstrerror(tperrno)); if (tperrno == TPEDIAGNOSTIC)</pre></div><a name="wp1062608"> </a><div class="pPreformatted"><pre>&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(void) fprintf(stderr, &quot;Diagnostic code=[%d]\t&quot;, &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ctl.diagnostic);<br />}<br />&#160;&#160;&#160;&#160;&#160;tpfree((char *) reqstr);<br />&#160;&#160;&#160;&#160;&#160;(void) tpterm();<br />&#160;&#160;&#160;&#160;&#160;exit(1);<br />}<br /><br />/* detach from queue */<br />/* tpqdetach() */<br />…</pre></div><li><a name="wp1065388"> </a>For synchronous message receiving, application calls standard dequeue API tpdeqplus(3c) as shown in <span class="cHyperlink">
Listing&#160;2</span></li>
<div class="pCodeTitle"><a name="wp1065389"> </a>
Listing&#160;2	   Synchronous Message Dequeue
</div> <a name="wp1065390"> </a><div class="pPreformatted"><pre>char qspacename[16] = &quot;QSPACE&quot;;<br />char qname[128] = &quot;myqueue2&quot;;<br /><br />/* call tpinit to join the application */<br />/* tpinit() */<br />…<br />/* attach to the queue to dequeue message from, then do the dequeue action */</pre></div><a name="wp1065391"> </a><div class="pPreformatted"><pre>/* tpqattach() */<br />… <br /><br />memset(&amp;ctl, 0x0, sizeof(ctl));<br />ctl.flags |= OTMQ;<br />flags = TPNOTRAN;<br /><br />/* get request buffer, allocate a buffer to store the dequeued message */<br />len = 100;<br />if ((reqstr = tpalloc(&quot;STRING&quot;, NULL, len)) == NULL)<br />{<br />&#160;&#160;&#160;&#160;&#160;(void) fprintf(stderr, &quot;unable to allocate STRING buffer: %s&quot;,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tpstrerror(tperrno));<br />&#160;&#160;&#160;&#160;&#160;(void) tpterm();<br />&#160;&#160;&#160;&#160;&#160;exit(1);<br />}<br /><br />/* dequeue the message from the queue */<br />ctl.timeout = 30;<br />if (tpdeqplus(qspacename, qname, &amp;ctl, &amp;reqstr, &amp;len, 0) == -1)<br />{<br />&#160;&#160;&#160;&#160;&#160;if (tperrno == TPEDIAGNOSTIC)<br />&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(void) fprintf(stderr, &quot;Diagnostic code=[%d]\t&quot;, &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ctl.diagnostic);<br />&#160;&#160;&#160;&#160;&#160;} else<br />&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(void) fprintf(stderr, &quot;Failure to dequeue  %s\n&quot;, &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tpstrerror(tperrno));<br />&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;&#160;tpfree((char *) reqstr);<br />&#160;&#160;&#160;&#160;&#160;(void) tpterm();<br />&#160;&#160;&#160;&#160;&#160;exit(1);<br />}</pre></div><a name="wp1065392"> </a><div class="pPreformatted"><pre><br />/* detach from queue */<br />/* tpqdetach() */<br />…</pre></div><li><a name="wp1062620"> </a>For synchronous message receiving, application calls standard dequeue API<code class="cCode"> tpdeqplus(3c)</code> as shown in <a href="prog.html#wp1065526">Listing&#160;3</a>.</li>
<div class="pCodeTitle"><a name="wp1065526"> </a>
Listing&#160;3	   Asynchronous Message Dequeue
</div> <a name="wp1065527"> </a><div class="pPreformatted"><pre>char qspacename[16] = &quot;QSPACE&quot;;<br />char qname[128] = &quot;myqueue2&quot;;<br /><br />/* call tpinit to join the application */<br />/* tpinit() */<br />…<br />/* attach to the queue to dequeue message from, then do the dequeue action */</pre></div><a name="wp1065528"> </a><div class="pPreformatted"><pre>/* tpqattach() */<br />… <br /><br />memset(&amp;ctl, 0x0, sizeof(ctl));<br />ctl.flags |= OTMQ;<br />flags = TPNOTRAN;<br /><br />/* get request buffer, allocate a buffer to store the dequeued message */<br />len = 100;<br />if ((reqstr = tpalloc(&quot;STRING&quot;, NULL, len)) == NULL)<br />{<br />&#160;&#160;&#160;&#160;&#160;(void) fprintf(stderr, &quot;unable to allocate STRING buffer: %s&quot;,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tpstrerror(tperrno));<br />&#160;&#160;&#160;&#160;&#160;(void) tpterm();<br />&#160;&#160;&#160;&#160;&#160;exit(1);</pre></div><a name="wp1065529"> </a><div class="pPreformatted"><pre>}<br /><br />/* dequeue the message from the queue */<br />ctl.timeout = 30;<br />if (tpdeqplus(qspacename, qname, &amp;ctl, &amp;reqstr, &amp;len, 0) == -1)<br />{<br />&#160;&#160;&#160;&#160;&#160;if (tperrno == TPEDIAGNOSTIC)<br />&#160;&#160;&#160;&#160;&#160;{</pre></div><a name="wp1063127"> </a><div class="pPreformatted"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(void) fprintf(stderr, &quot;Diagnostic code=[%d]\t&quot;, &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ctl.diagnostic);<br />&#160;&#160;&#160;&#160;&#160;} else<br />&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(void) fprintf(stderr, &quot;Failure to dequeue  %s\n&quot;, &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tpstrerror(tperrno));<br />&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;&#160;tpfree((char *) reqstr);<br />&#160;&#160;&#160;&#160;&#160;(void) tpterm();<br />&#160;&#160;&#160;&#160;&#160;exit(1);<br />}<br /><br />/* detach from queue */<br />/* tpqdetach() */<br />…</pre></div><li><a name="wp1058611"> </a>For asynchronous message receiving, application calls <code class="cCode">tpqgetmsga(3c)</code>.</li>
<div class="pCodeTitle"><a name="wp1065669"> </a>
Listing&#160;4	   Asynchonous Dequeue Message
</div> <a name="wp1065670"> </a><div class="pPreformatted"><pre>/* first define the user action to be done when message arrive */<br />int gotMessage = 0;<br /><br />int msgAction(long * flag)<br />{<br />&#160;&#160;&#160;&#160;&#160;printf(&quot;Get asynchronous message [%s],flag=0x%X\n&quot;,reqstr,flag);<br />&#160;&#160;&#160;&#160;&#160;gotMessage = 1;</pre></div><a name="wp1065671"> </a><div class="pPreformatted"><pre>}<br /><br />int main(int argc, char **argv)<br />{<br />&#160;&#160;&#160;&#160;&#160;char qspacename[16] = &quot;QSPACE&quot;;<br />&#160;&#160;&#160;&#160;&#160;char qname[128] = &quot;myqueue1&quot;;</pre></div><a name="wp1065672"> </a><div class="pPreformatted"><pre>...<br /><br />&#160;&#160;&#160;&#160;&#160;/* join the application */<br />&#160;&#160;&#160;&#160;&#160;/* tpinit() */<br />&#160;&#160;&#160;&#160;&#160;…<br />&#160;&#160;&#160;&#160;&#160;/* attach to the queue to dequeue message from */<br />&#160;&#160;&#160;&#160;&#160;/* tpqattach() */<br />&#160;&#160;&#160;&#160;&#160;…<br />&#160;&#160;&#160;&#160;&#160;memset(&amp;qctl,0,sizeof(qctl));<br />&#160;&#160;&#160;&#160;&#160;qctl.flags |= OTMQ;<br />&#160;&#160;&#160;&#160;&#160;qctl.filter_idx = -1;    /* no message filter designated, get the first &#160;&#160;&#160;&#160;&#160;available message in queue */<br /><br />&#160;&#160;&#160;&#160;&#160;size_user_data=100;<br />&#160;&#160;&#160;&#160;if( tpqgetmsga(qspacename, <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;qname,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(TPQCTL *)&amp;qctl,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(char **)&amp;reqstr,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long *)&amp;size_user_data,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long *)&amp;msgAction,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long *)0,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long *)0,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;TPNOTIME)  != 0)<br />&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* print out the error message string or diagnostic code */<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;…<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;tpfree((char *) reqstr);<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;(void) tpterm();<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(1);<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br /><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* continue to do other actions, when message arrived in queue,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;* user action &quot;msgAction&quot; will be called */</pre></div><a name="wp1065673"> </a><div class="pPreformatted"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;…</pre></div><a name="wp1063271"> </a><div class="pPreformatted"><pre>}</pre></div><li><a name="wp1058612"> </a>If received message requires confirmation, application calls <code class="cCode">tpqconfirmmsg(3c)</code> to confirm receipt of the message as shown in <a href="prog.html#wp1065799">Listing&#160;5</a>.</li>
<div class="pCodeTitle"><a name="wp1065799"> </a>
Listing&#160;5	   Explicit Confirmation for a Dequeued message
</div> <a name="wp1065800"> </a><div class="pPreformatted"><pre>/* join the application */<br />/* tpinit() */<br />…<br />/* attach to the queue to dequeue message from, then do the dequeue action */</pre></div><a name="wp1065801"> </a><div class="pPreformatted"><pre>/* tpqattach() */<br />…<br />/* dequeue message */<br />/* tpdeqplus() */<br />…<br />/* check the message delivery status stored in TPQCTL */<br />if( ctl.status_block.del_psb_status == OTMQ__CONFIRMREQ)<br />{<br />&#160;&#160;&#160;&#160;&#160;/* This is a message need to be confirmed explicitly,</pre></div><a name="wp1065802"> </a><div class="pPreformatted"><pre>&#160;&#160;&#160;&#160;&#160;* use the dequeued message sequence to confirm */</pre></div><a name="wp1065803"> </a><div class="pPreformatted"><pre>&#160;&#160;&#160;&#160;&#160;if(tpqconfirmmsg(ctl.seq_number, 0) &lt; 0)</pre></div><a name="wp1065804"> </a><div class="pPreformatted"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;{</pre></div><a name="wp1065805"> </a><div class="pPreformatted"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* print out the error message string or diagnostic code */</pre></div><a name="wp1065806"> </a><div class="pPreformatted"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;…</pre></div><a name="wp1065807"> </a><div class="pPreformatted"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tpfree((char *) reqstr);</pre></div><a name="wp1065808"> </a><div class="pPreformatted"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(void) tpterm();</pre></div><a name="wp1065809"> </a><div class="pPreformatted"><pre>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(1);</pre></div><a name="wp1065810"> </a><div class="pPreformatted"><pre>&#160;&#160;&#160;&#160;&#160;}</pre></div><a name="wp1065811"> </a><div class="pPreformatted"><pre>}</pre></div></ul></div>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1058628"> </a>
Using Filters
</h2><p class="pBody"><a name="wp1058629"> </a>
OTMQ provides message filter which allows user to retrieve message that matching the selection criteria defined by the message filter. Application can designate message filter when calling standard dequeue API <code class="cCode">tpdeqplus(3c)</code>, or when calling subscription API <code class="cCode">tpqsubscribe(3c)</code>.
</p>
<h3 class="pHeading2"><a name="wp1058642"> </a>
Filter Type
</h3>
<p class="pBody"><a name="wp1058643"> </a>
OTMQ supports two types of message filter: simple filter and compound filter. Simple filter has lifecycle of only one-time operation (dequeue or subscription). While the compound filter can be pre-defined and re-used in the subsequent dequeue operations.
</p>
<h4 class="pHeading3"><a name="wp1058654"> </a>
Simple Filter
</h4>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1058655"> </a>Filter per operation</li>
<p class="pBodyRelative"><a name="wp1058656"> </a>
Message filter can be specified when calling <code class="cCode">tpdeqplus(3c)</code>. It only impacts the result of this operation itself.
</p>
<li><a name="wp1058657"> </a>Filter per subscription</li>
<p class="pBodyRelative"><a name="wp1058658"> </a>
Message filter can be specified when subscribing the user broadcast message. It only impacts the messages retrieved according to this subscription.
</p>
</ul></div>
<h4 class="pHeading3"><a name="wp1058659"> </a>
Compound Filter
</h4>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1058660"> </a>Filter per queue</li>
<p class="pBodyRelative"><a name="wp1058661"> </a>
Message filter can be defined or canceled via a pair of APIs: <code class="cCode">tpqsetselect</code> /<code class="cCode">tpqcancelselect</code>. Once a filter is defined, the user can use it in a serial of dequeue or subscription operations.
</p>
</ul></div>
<h3 class="pHeading2"><a name="wp1058700"> </a>
Filter Format
</h3>
<p class="pBody"><a name="wp1058701"> </a>
Different types of message filter have different kinds of format. Following sections describe the selection criteria that can be specified for the simple filter or the compound filter.
</p>
<h4 class="pHeading3"><a name="wp1058719"> </a>
Simple Filter
</h4>
<p class="pBody"><a name="wp1058720"> </a>
For simple filter, it consists of one of the following selection criteria:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1058721"> </a>Default Selection </li>
<p class="pBodyRelative"><a name="wp1058722"> </a>
Enables application to read messages from the queue based on the order in which they arrived. Applications using default selection will read the next pending message from the message queue. Messages are stored by pre-defined queue orders (FIFO, LIFO, priority, etc.).
</p>
<li><a name="wp1058723"> </a>Selection by Message Attribute</li>
<p class="pBodyRelative"><a name="wp1061320"> </a>
Enables the application to select messages based on the message type, message class or message priority, etc.
</p>
</ul></div>
<p class="pBody"><a name="wp1061324"> </a>
<a href="prog.html#wp1061328">Table&#160;1</a> shows how the selection criteria can be defined as select mode and value pairs. 
</p>
<p class="pGraphic"><a name="wp1061365"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1061328table1061325"><caption><a name="wp1061328"> </a>
Table&#160;1  <span style="font-style: normal; font-weight: bold; text-decoration: none; vertical-align: baseline">Select Mode</span>

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1061334"> </a>
Selection Mode
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1061336"> </a>
Selection Variable
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1061338"> </a>
Mode Description
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061340"> </a>
OTMQ_PQ_TYPE
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061342"> </a>
Message type value
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061344"> </a>
Selects the first pending message from the attached Primary Queue (PQ) that matches the message type value being specified in the selection variable.
</div>
<div class="pCellBody"><a name="wp1061345"> </a>
TPQCTL-&gt;flags must set OTMQ|TPQGETBYFILTER|TPQGETBYMSGTYPE
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061347"> </a>
OTMQ_PQ_CLASS
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061349"> </a>
Message class value
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061351"> </a>
Selects the first pending message from the attached Primary Queue (PQ) that matches the message class value being specified in the selection variable.
</div>
<div class="pCellBody"><a name="wp1061352"> </a>
TPQCTL-&gt;flags must set OTMQ|TPQGETBYFILTER|TPQGETBYMSGCLASS
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061354"> </a>
OTMQ_PQ_PRI
</div>
</td>
    <td class="table" scope="row"><div class="pSmartList1TableBullet"><ul class="SmartList1TableBullet">
<li><a name="wp1061356"> </a>Integer value between 0 and 99</li>
<li><a name="wp1061357"> </a>OTMQ_PRI_ANY</li>
<li><a name="wp1061358"> </a>OTMQ_PRI_P0</li>
<li><a name="wp1061359"> </a>OTMQ_PRI_P1</li>
</ul></div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061361"> </a>
Selects the first pending message with a priority equal to an integer between 0 and 99 inclusive (or equal to the selection variable value) from the attached Primary Queue (PQ). Specifying the direct integer value is the preferred method of selecting message by priority
</div>
<div class="pCellBody"><a name="wp1061362"> </a>
Using OTMQ_PRI_ANY enables the reading of any pending messages of all priorities.
</div>
<div class="pCellBody"><a name="wp1061363"> </a>
Using OTMQ_PRI_P0 enables the application to retrieve pending messages of priority 0 only.
</div>
<div class="pCellBody"><a name="wp1061364"> </a>
Using OTMQ_PRI_P1 enables the strict retrieval of pending messages with a priority of 1.
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<div class="pCodeTitle"><a name="wp1064022"> </a>
Listing&#160;6	   Dequeue Message with Simple Message Filter
</div> <a name="wp1065919"> </a><div class="pPreformatted"><pre>#define MSG_CLAS_EXAMPLES            2000<br />#define MSG_TYPE_CLIENT_REQ             1<br /><br />TPQCTL ctl;<br />….<br />/* join the application */<br />/* tpinit() */<br />…<br /><br />/* attach to the Qspace */<br />/* tpqattach() */<br />…<br /><br />/* select by message attributes */<br />ctl.flags |= TPQGETBYMSGCLASS;<br />ctl.msg_class = MSG_CLAS_EXAMPLES;<br />ctl.flags |= TMQGETBYMSGTYPE;<br />ctl.msg_type = MSG_TYPE_CLIENT_REQ;<br />ctl.flags |= TPQGETBYPRIORITY;<br />ctl.priority = 50;<br />…<br />/* call tpdeqplus to dequeue a message with <br />* message class is &quot;MSG_CLAS_EXAMPLES&quot;,<br />* message type is &quot;MSG_TYPE_CLIENT_REQ&quot; and<br />* message priority is 50 */<br />if (tpdeqplus(qspacename, qname, &amp;ctl, &amp;reqstr, &amp;len, 0) == -1)<br />{<br />&#160;&#160;&#160;&#160;&#160;/* deal with failed scenario */<br />&#160;&#160;&#160;&#160;&#160;……<br />}<br />…<br />/* detach from Qspace */<br />/* tpqdetach() */<br />…</pre></div><h4 class="pHeading3"><a name="wp1058976"> </a>
Compound Filter
</h4>
<p class="pBody"><a name="wp1058977"> </a>
The compound filter allows application to define complex selection criteria for message reception. The selection criteria array can specifies the queues to search, the priority order of message reception, two comparison keys for range checking, and an order key to determine the order in which messages are selected from the queue. 
</p>
<p class="pBody"><a name="wp1058978"> </a>
Application calls<code class="cCode"> tpqsetselect(3c</code>) function first to define a filter and gets an index handle as return, which can be used later in the standard dequeue API to retrieve messages. 
</p>
<p class="pBody"><a name="wp1058979"> </a>
Also the application can call <code class="cCode">tpqcancelselect(3c)</code> to cancel the compound filter defined before as shown in <a href="prog.html#wp1064142">Listing&#160;7</a>.
</p>
<div class="pCodeTitle"><a name="wp1064142"> </a>
Listing&#160;7	   Dequeue Message Using Compund Message Filter
</div> <a name="wp1066028"> </a><div class="pPreformatted"><pre>char qspacename[16] = &quot;QSPACE&quot;;<br />char qname[128] = &quot;myqueue1&quot;;<br />char src_qname[128] = &quot;from_que&quot;;<br />TPQctl ctl;<br />selection_array_component_tp  selection_array;<br />short num_masks = 1;<br />int index_handle = -1;<br /><br />/* join the application */<br />/* tpinit() */<br /><br />/* attach to the Qspace */<br />/* tpqattach() */<br /><br />/* set complex filter to dequeue message with specific message class,<br />&#160;&#160;* and from specific queue*/</pre></div><a name="wp1066029"> </a><div class="pPreformatted"><pre>memset(&amp;selection_array, 0x0, sizeof(selection_array));<br />selection_array.key_1_offset = OTMQ_CLASS;<br />selection_array.key_1_size = 4;<br />selection_array.key_1_value = MSG_CLAS_EXAMPLES;<br />selection_array.key_1_oper = OTMQ_OPER_EQ;<br />selection_array.key_2_offset = OTMQ_SOURCE;<br />selection_array.key_2_size = 4;<br />selection_array.key_value_qspace = qspacename;<br />selection_array.key_value_queue = src_qname;<br />selection_array.key_2_oper = OTMQ_OPER_EQ;<br /><br />if(tpqsetselect(&amp;selection_array, &amp;num_masks, &amp;index_handle ) == -1)<br />{<br />&#160;&#160;&#160;&#160;&#160;/* deal with failed scenario */<br />&#160;&#160;&#160;&#160;&#160;…<br />}<br /><br />ctl.filter_idx = index_handle; /* using the filter to dequeue */<br /><br />if(tpdeqplus(qspacename, qname, &amp;ctl, &amp;reqstr, &amp;len, 0) == -1)<br />{<br />&#160;&#160;&#160;&#160;&#160;/* deal with failed scenario */<br />&#160;&#160;&#160;&#160;&#160;…<br />}<br /><br />/* need to cancel the filter using the index */<br />if(tpqcancelselect(&amp;index_handle)== -1) <br />{<br />&#160;&#160;&#160;&#160;&#160;/* deal with failed scenario */<br />&#160;&#160;&#160;&#160;&#160;…<br />}<br /><br />/* detach from Qspace */<br />/* tpqdetach() */<br />…</pre></div><p class="pBody"><a name="wp1058980"> </a>
For more information, see<code class="cCode"> tpqsetselect(3c)</code> and <code class="cCode">tpqcancelselect(3c)</code> in the Oracle Tuxedo Message Queue Reference Guide.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1059001"> </a>
Using Publish/Subscribe
</h2><p class="pBody"><a name="wp1059003"> </a>
The publisher broadcast a message by sending the message to a special &quot;topic&quot;. Each topic represents a broadcast stream. A broadcast stream is the set of target queues registered to receive messages directed to a particular topic. The subscriber should register first for a topic to receive the specific broadcasting messages.
</p>
<p class="pBody"><a name="wp1059004"> </a>
The OTMQ Message Queue Manager Server is responsible for maintaining lists of user processes that are interested in the specific topic. In addition, the server is responsible for maintaining the various user definable rules (also known as pub/sub filter) that can be used to selectively extract messages from the broadcast stream that are set by the application using the <code class="cCode">tpqsubscribe(3c)</code>. 
</p>
<p class="pBody"><a name="wp1059005"> </a>
A publisher can send a broadcast message using<code class="cCode"> tpqpublish(3c)</code>, and a subscriber can retrieve the subscribed message from its attached queue.
</p>
<h3 class="pHeading2"><a name="wp1059017"> </a>
Sending Broadcast Messages
</h3>
<p class="pBody"><a name="wp1059018"> </a>
To broadcast a message, a publisher program directs the message to the topic that identifies the broadcast stream to use for message distribution. When the application issues the<code class="cCode"> tpqpublish(3c)</code> function, OTMQ Message Queue Manager Server deals with the <code class="cCode">tpqpublish(3c)</code> call and transparently redirects the message to all corresponding recipients.
</p>
<p class="pBody"><a name="wp1059019"> </a>
OTMQ Message Queue Manager Server delivers only one copy of each message on the broadcast stream to each target queue, regardless of how many selection matches are made by separate subscription rule entries.
</p>
<p class="pBody"><a name="wp1059020"> </a>
Broadcast messages cannot be stored for automatic message recovery.
</p>
<h3 class="pHeading2"><a name="wp1059035"> </a>
Receiving Broadcast Messages
</h3>
<p class="pBody"><a name="wp1059036"> </a>
To receive broadcast messages, applications use a standard API <code class="cCode">tpqsubscribe(3c)</code> to register for receipt with the local or remote OTMQ Message Queue Manager Server.
</p>
<p class="pBody"><a name="wp1059037"> </a>
The following topics describe:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1059038"> </a><a href="prog.html#wp1059059">Subscribing to Receive Broadcast Messages</a></li>
<li><a name="wp1059039"> </a><a href="prog.html#wp1059079">Subscribing to Receive Selected Broadcast Messages</a></li>
<li><a name="wp1059040"> </a><a href="prog.html#wp1059450">Subscription Acknowledgement</a></li>
<li><a name="wp1059041"> </a><a href="prog.html#wp1059459">Reading Broadcast Messages</a> </li>
<li><a name="wp1059042"> </a><a href="prog.html#wp1059468">Unsubscribing Receiving Broadcast Messages</a></li>
</ul></div>
<h4 class="pHeading3"><a name="wp1059059"> </a>
Subscribing to Receive Broadcast Messages
</h4>
<p class="pBody"><a name="wp1059060"> </a>
To receive broadcast messages, an application registers a queue with a broadcast stream (topic) that managed by the OTMQ Message Queue Manager Server.
</p>
<p class="pBody"><a name="wp1059061"> </a>
The receiver/subscribing applications register for broadcast messages using the function <code class="cCode">tpqsubscribe(3c)</code>. The registration contains the string formatted topic plus any selection criteria (filter) related to messages that the application wishes to receive.
</p>
<p class="pBody"><a name="wp1059062"> </a>
The application subscribe the broadcast messages using the function <code class="cCode">tpqsubscribe(3c)</code> supplied with the following information:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1059063"> </a>The topic: the broadcast stream that wants to subscribe</li>
<li><a name="wp1059064"> </a>The target: the target OTMQ Message Queue Manager Server, and the special flag which means Pub/Sub service.</li>
<li><a name="wp1059065"> </a>The source: the queue name which the requesting application is attaching.</li>
</ul></div>
<h4 class="pHeading3"><a name="wp1059079"> </a>
Subscribing to Receive Selected Broadcast Messages
</h4>
<p class="pBody"><a name="wp1059080"> </a>
Use the message filter of <code class="cCode">tpqsubscribe(3c)</code> to register for selective reception of broadcast messages. This subscription request registers a target queue to receive a copy of all messages on a broadcast stream that meet a single selection rule.
</p>
<p class="pBody"><a name="wp1059081"> </a>
Filter is a string containing a Boolean filter rule that must be evaluated successfully before the OTMQ Message Queue Server distributing the broadcast messages to the subscriber. Filter rules are specific to the types buffers to which they are applied. For messages of string type, the filter rule is a regular expression. For messages of FML buffers, the filter rule is a string that can be passed to the FML Boolean compiler (see Tuxedo ATMI FML function <code class="cCode">Fboolco</code>).
</p>
<p class="pBody"><a name="wp1059082"> </a>
<a href="prog.html#wp1059258">Table&#160;2</a> shows how the Filter Regular Expression Rules can be defined.
</p>
<p class="pGraphic"><a name="wp1059242"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1059258table1059133"><caption><a name="wp1059258"> </a>
Table&#160;2  Regular Expression Rules

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1059262"> </a>
Rule
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1059264"> </a>
Matching Text
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059266"> </a>
character 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059268"> </a>
Itself (character is any ASCII character except the special ones mentioned below). 
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059270"> </a>
\ character 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059272"> </a>
Itself except as follows:
</div>
<div class="pCellBody"><a name="wp1059273"> </a>
\\-newline 
</div>
<div class="pCellBody"><a name="wp1059372"> </a>
\\t-tab
</div>
<div class="pCellBody"><a name="wp1059379"> </a>
\\b-backspace
</div>
<div class="pCellBody"><a name="wp1059386"> </a>
\\r-carriage return
</div>
<div class="pCellBody"><a name="wp1059393"> </a>
\\f-formfeed
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059295"> </a>
\ special-character 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059297"> </a>
Its un-special self. The special characters are<code class="cCode"> . * + ? | ( ) [ {</code> and <code class="cCode">\\</code>. 
</div>
<div class="pCellBody"><a name="wp1059424"> </a>
-Any character except the end-of-line character (usually newline or NULL).
</div>
<div class="pCellBody"><a name="wp1059425"> </a>
^-Beginning of the line.
</div>
<div class="pCellBody"><a name="wp1059420"> </a>
$-End-of-line character.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059323"> </a>
[class] 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059325"> </a>
any character in the class denoted by a sequence of characters and/or ranges. A range is given by the construct character-character. For example, the character class, [a-zA-Z0-9_], will match any alphameric character or &quot;_&quot;. To be included in the class, a hyphen, &quot;-&quot;, must be escaped (preceded by a &quot;\\&quot;) or appear first or last in the class. A literal &quot;]&quot; must be escaped or appear first in the class. A literal &quot;^&quot; must be escaped if it appears first in the class. 
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059327"> </a>
[^ class ] 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059329"> </a>
Any character in the complement of the class with respect to the ASCII character set, excluding the end-of-line character. 
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059331"> </a>
RE RE 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059333"> </a>
The sequence. (catenation) 
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059335"> </a>
RE | RE 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059337"> </a>
Either the left RE or the right RE. (left to right alternation) 
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059339"> </a>
RE * 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059341"> </a>
Zero or more occurrences of RE. 
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059343"> </a>
RE + 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059345"> </a>
One or more occurrences of RE. 
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059347"> </a>
RE ? 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059349"> </a>
Zero or one occurrences of RE. 
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059351"> </a>
RE { n } 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059353"> </a>
n occurrences of RE. n must be between 0 and 255, inclusive. 
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059355"> </a>
RE { m, n } 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059357"> </a>
m through n occurrences of RE, inclusive. A missing m is taken to be zero. A missing n denotes m or more occurrences of RE. 
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059359"> </a>
( RE ) 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059361"> </a>
Explicit precedence/grouping. 
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059363"> </a>
( RE ) $ n 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059365"> </a>
The text matching RE is copied into the nth user buffer. n may be 0 through 9. User buffers are cleared before matching begins and loaded only if the entire pattern is matched. 
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<p class="pBody"><a name="wp1059122"> </a>
There are three levels of precedence. In order of decreasing binding strength they are: 
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1059436"> </a>catenation closure (*,+,?,{...})</li>
<li><a name="wp1059437"> </a>catenation</li>
<li><a name="wp1059438"> </a>alternation (|)</li>
</ul></div>
<p class="pBody"><a name="wp1059439"> </a>
As indicated above, parentheses are used to give explicit precedence. 
</p>
<h4 class="pHeading3"><a name="wp1059450"> </a>
Subscription Acknowledgement
</h4>
<p class="pBody"><a name="wp1059451"> </a>
The<code class="cCode"> tpqsubscribe(3c)</code> returns a subscription handle back to the subscriber. This handle should be used to unsubscribe the specific subscription.
</p>
<h4 class="pHeading3"><a name="wp1059459"> </a>
Reading Broadcast Messages
</h4>
<p class="pBody"><a name="wp1059460"> </a>
When a message is sent to a broadcast stream, the OTMQ Message Queue Manager Server will determine which applications have registered to receive that kind of message. Then it automatically sends these messages to the distribution of all matching applications. The receiving application reads the broadcast message from its target queue using the standard dequeue functions. The source queue address of the sender is also provided to the receiving application in the message.
</p>
<h4 class="pHeading3"><a name="wp1059468"> </a>
Unsubscribing Receiving Broadcast Messages
</h4>
<p class="pBody"><a name="wp1059469"> </a>
An application can withdraw subscribing messages from a broadcast stream by calling the <code class="cCode">tpqunsubscribe(3c)</code>. This action removes the subscription entry from the internal registration tables as shown in <a href="prog.html#wp1064430">Listing&#160;8</a>
</p>
<div class="pCodeTitle"><a name="wp1064430"> </a>
Listing&#160;8	   Subscribe and Unsubscribe Messages
</div> <a name="wp1066120"> </a><div class="pPreformatted"><pre>TPEVCTL evctl;<br />long evt_handle = 0L ;  /* Event Subscription handles */<br />…<br />/* join the application */<br />/* tpinit() */<br />…<br /><br />/* attach to the Qspace */<br />/* tpqattach() */<br />…<br />evctl.flags = TPEVQUEUE ;<br />(void)strcpy (evctl.name1, &quot;QSPACE&quot;) ;<br />(void)strcpy (evctl.name1, &quot;myqueue1&quot;) ;<br />evctl.qctl.flags |= OTMQ;<br /><br />/* Subscribe */<br />evt_handle = tpqsubscribe (&quot;TMQ:QNOT:QSPACE:mytopic&quot;,<br />&#160;&#160;&#160;NULL,&amp;evctl,TPSIGRSTRT) ;</pre></div><a name="wp1066121"> </a><div class="pPreformatted"><pre>if (evt_handle == -1L) {<br />&#160;&#160;&#160;&#160;&#160;/* deal with failed scenario */<br />&#160;&#160;&#160;&#160;&#160;…</pre></div><a name="wp1066122"> </a><div class="pPreformatted"><pre>}<br />…<br />/* dequeue subscribed message */<br />if(tpdeqplus(qspacename, qname, &amp;ctl, &amp;reqstr, &amp;len, 0) == -1) <br />{<br />&#160;&#160;&#160;&#160;&#160;/* deal with failed scenario */<br />&#160;&#160;&#160;&#160;&#160;…</pre></div><a name="wp1066123"> </a><div class="pPreformatted"><pre>}</pre></div><a name="wp1066124"> </a><div class="pPreformatted"><pre><br />/* Unsubscribe to the subscribed topic */<br />if (tpqunsubscribe (evt_handle, TPSIGRSTRT) == -1)<br />{<br />&#160;&#160;&#160;&#160;&#160;/* deal with failed scenario */<br />&#160;&#160;&#160;&#160;&#160;…<br />}</pre></div><p class="pBody"><a name="wp1064491"> </a>
For more information, see tpqsubscribe(3c) and tpqunsubscribe(3c) in the Oracle Tuxedo Message Queue Reference Guide
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1059518"> </a>
Using Recoverable Messaging
</h2><p class="pBody"><a name="wp1059519"> </a>
Applications send messages using the OTMQ standard enqueue function <code class="cCode">tpenqplus(3c)</code> and one of two types of delivery modes: recoverable or non-recoverable. If a message is sent as non-recoverable, the message is lost if it cannot be delivered to the target queue unless the application incorporates an error recovery procedure. If the message is sent as recoverable, OTMQ Message Queue Manager Server and Offline Trade Driver can automatically guarantee delivery to the target queue in spite of system, process, and network failures.
</p>
<p class="pBody"><a name="wp1059520"> </a>
To ensure guaranteed delivery, the OTMQ Message Queue Manager Server writes recoverable messages to nonvolatile storage on the sender or receiver system. Then, if a message cannot be delivered due to an error condition, the OTMQ Offline Trade Driver attempts redelivery of the message by reading it from the recovery journal and redelivering the message to the target queue until delivery is confirmed.
</p>
<p class="pBody"><a name="wp1059521"> </a>
Application developers determine which messages should be sent as recoverable depending upon the needs of the application. Because recoverable messaging requires the extra step of storing the messages on disk, it requires additional processing time and power. To maximize performance, recoverable messaging should only be used when it is critical to application processing.
</p>
<p class="pBody"><a name="wp1059541"> </a>
The OTMQ recoverable messaging feature offers the following benefits:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1059542"> </a>Reduces development time by eliminating the need for designing applications to recover messages that cannot be delivered. </li>
<li><a name="wp1059524"> </a>Prevents applications from losing data when applications, systems, or network links fail. </li>
<li><a name="wp1059525"> </a>Simplifies the implementation of an event-driven store and forward capability in networked applications. </li>
</ul></div>
<p class="pBody"><a name="wp1059526"> </a>
OTMQ also offers error recovery features for non-recoverable messages such as the dead letter queue (DLQ) and the ability to return a message to the sender if the message cannot be delivered. This topic describes all of the OTMQ delivery modes to enable you to understand the right choice for your application.
</p>
<p class="pBody"><a name="wp1059434"> </a>
This section contains the following topics
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1059549"> </a><a href="prog.html#wp1059558">Choosing a Message Delivery Mode</a></li>
<li><a name="wp1059550"> </a><a href="prog.html#wp1060153">How to Send a Recoverable Message</a> </li>
<li><a name="wp1059551"> </a><a href="prog.html#wp1060163">How to Receive a Recoverable Message</a> </li>
<li><a name="wp1059552"> </a><a href="prog.html#wp1060172">Using UMAs for Exception Processing</a></li>
</ul></div>
<h3 class="pHeading2"><a name="wp1059558"> </a>
Choosing a Message Delivery Mode
</h3>
<p class="pBody"><a name="wp1059590"> </a>
The choice between recoverable and non-recoverable delivery is based upon the needs of the application. To determine the appropriate method for sending a message, the application developer decides:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1059596"> </a>Does the application need to know if the message arrived at the target queue? </li>
<li><a name="wp1059597"> </a>If notification is required, how far must the message get before the sender program receives notification that the message has arrived? </li>
<li><a name="wp1059562"> </a>Should the application wait for notification or should it continue processing and receive notification through an asynchronous acknowledgment message? </li>
<li><a name="wp1059563"> </a>If the message is designated as recoverable, does the application need to know if the message has been stored by the recovery system? </li>
<li><a name="wp1059564"> </a>If the message is designated as recoverable, what should happen if it cannot be stored by the recovery system? </li>
</ul></div>
<p class="pBody"><a name="wp1059565"> </a>
The delivery mode specified in <code class="cCode">tpenqplus(3c) </code>function determines:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1059566"> </a>Whether the message is sent as recoverable or non-recoverable</li>
<li><a name="wp1059567"> </a>Whether a blocking or non-blocking mode is selected </li>
<li><a name="wp1059568"> </a>Whether the sender program receives notification and how it is received </li>
<li><a name="wp1059569"> </a>The point in the message flow at which the notification is sent </li>
</ul></div>
<p class="pBody"><a name="wp1059570"> </a>
OTMQ uses message recovery journals to store messages that are designated as recoverable. The message recovery journal on the local system is called the store and forward (SAF). The message recovery journal on the remote system is called the destination queue file (DQF). If a recoverable message cannot be delivered, it is stored in either the SAF or DQF queue and is automatically re-sent once communication with the target group is restored.
</p>
<p class="pBody"><a name="wp1059571"> </a>
OTMQ uses auxiliary journals to provide additional message recovery capabilities. The dead letter queue (DLQ) is a memory-based queue for storing undeliverable messages. The dead letter journal (DLJ) provides disk storage for messages that could not be stored for automatic recovery. Undelivered messages stored in the DLQ or DLJ can be retrieved under user or application control by using OTMQ&#39;s Journal API <code class="cCode">tpqreadjrn(3c)</code>.
</p>
<p class="pBody"><a name="wp1059572"> </a>
The post confirmation journal (PCJ) stores successfully confirmed recoverable messages. 
</p>
<p class="pBody"><a name="wp1059573"> </a>
If the OTMQ message recovery system is unable to store the message, the undeliverable message action (UMA) is taken. Some UMAs enable the message to be recovered at a later time under user or application control.
</p>
<h4 class="pHeading3"><a name="wp1059612"> </a>
Choosing Recoverable or Non-recoverable Delivery Mode
</h4>
<p class="pBody"><a name="wp1059613"> </a>
The delivery mode consists of two components, the block type (block) and the delivery interest point (DIP). Specify the block and DIP in the TPQCTL structure.
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1059614"> </a>block - indicates how the sender program wants to receive information about the delivery of the message. You can either wait for the operation to complete (WF), or receive notification in an asynchronous message (AK), or choose not to receive notification (NN) at all. </li>
<li><a name="wp1059615"> </a>DIP - determines whether the message is designated as recoverable. When the message reaches the delivery interest point, a notification message is sent (if requested) and the call returns control to the sender program or OTMQ Message Queue Manager Server delivers the asynchronous acknowledgment message. </li>
</ul></div>
<p class="pBody"><a name="wp1059616"> </a>
Non-recoverable delivery interest points enable the sender program to receive notification when the message is stored in the target queue (MEM), when the message is read from the target queue (DEQ), or when the message is read from the target queue and explicitly confirmed by the receiver program using the tpqconfirmmsg(3c) function (ACK).
</p>
<p class="pBody"><a name="wp1059617"> </a>
When a recoverable delivery interest point is selected, the message is stored on disk for automatic recovery. Recoverable delivery interest points enable the sender program to store the message in the local recovery journal (SAF), store the message in the remote recovery journal (DQF), or store the message in the remote recovery journal and receive notification when the message is confirmed by the target application (CONF).
</p>
<p class="pBody"><a name="wp1059618"> </a>
OTMQ does not support all possible combinations of block type and delivery interest points. <a href="prog.html#wp1059683">Table&#160;3</a> lists the valid delivery modes and their meanings.
</p>
<p class="pGraphic"><a name="wp1060031"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1059683table1059681"><caption><a name="wp1059683"> </a>
Table&#160;3  Delivery Modes

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1059687"> </a>
Delivery Mode 
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1059689"> </a>
Description
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="straddledcells" colspan="2" rowspan="1"><div class="pCellBody"><a name="wp1059691"> </a>
(Recoverable Delivery Modes)
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059695"> </a>
block = OTMQ_DEL_AK
</div>
<div class="pCellBody"><a name="wp1059822"> </a>
DIP = OTMQ_DIP_CONF
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059697"> </a>
Send acknowledgment message when the message recovery system confirms message delivery from the remote recovery journal.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059703"> </a>
block = OTMQ_DEL_AK
</div>
<div class="pCellBody"><a name="wp1059835"> </a>
DIP = OTMQ_DIP_DQF
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059705"> </a>
Send acknowledgment message when the message is stored in the remote recovery journal.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059711"> </a>
block = OTMQ_DEL_AK
</div>
<div class="pCellBody"><a name="wp1059848"> </a>
DIP = OTMQ_DIP_SAF
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059713"> </a>
Send acknowledgment message when the message is stored in the local recovery journal.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059719"> </a>
block = OTMQ_DEL_NN
</div>
<div class="pCellBody"><a name="wp1059861"> </a>
DIP = OTMQ_DIP_DQF
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059721"> </a>
Deliver message to the remote recovery journal but do not block and do not send notification.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059727"> </a>
block = OTMQ_DEL_NN
</div>
<div class="pCellBody"><a name="wp1059874"> </a>
DIP = OTMQ_DIP_SAF
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059729"> </a>
Deliver message to the local recovery journal but do not block and do not send notification.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059735"> </a>
block = OTMQ_DEL_WF
</div>
<div class="pCellBody"><a name="wp1059887"> </a>
DIP = OTMQ_DIP_CONF
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059737"> </a>
Block until the message is stored in the remote recovery journal and confirmed by the target application.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059743"> </a>
block = OTMQ_DEL_WF
</div>
<div class="pCellBody"><a name="wp1059900"> </a>
DIP = OTMQ_DIP_DQF
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059745"> </a>
Block until the message is stored in the remote recovery journal.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059751"> </a>
block = OTMQ_DEL_WF
</div>
<div class="pCellBody"><a name="wp1059913"> </a>
DIP = OTMQ_DIP_SAF
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059753"> </a>
Block until the message is stored in the local recovery journal.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="straddledcells" colspan="2" rowspan="1"><div class="pCellBody"><a name="wp1059759"> </a>
(Non-Recoverable Delivery Modes)
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059763"> </a>
block = OTMQ_DEL_AK
</div>
<div class="pCellBody"><a name="wp1059926"> </a>
DIP = OTMQ_DIP_ACK
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059765"> </a>
Send acknowledgment message when the receiver program explicitly confirms delivery using tpqconfirmmsg(3c).
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059771"> </a>
block = OTMQ_DEL_AK
</div>
<div class="pCellBody"><a name="wp1059939"> </a>
DIP = OTMQ_DIP_DEQ
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059773"> </a>
Send acknowledgment message when the message is removed from the target queue.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059779"> </a>
block = OTMQ_DEL_AK
</div>
<div class="pCellBody"><a name="wp1059952"> </a>
DIP = OTMQ_DIP_MEM
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059781"> </a>
Send acknowledgment message when the message is stored in the target queue.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059787"> </a>
block = OTMQ_DEL_NN
</div>
<div class="pCellBody"><a name="wp1059965"> </a>
DIP = OTMQ_DIP_MEM
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059789"> </a>
Deliver message to the target queue but do not block and do not send notification.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059795"> </a>
block = OTMQ_DEL_WF
</div>
<div class="pCellBody"><a name="wp1059978"> </a>
DIP = OTMQ_DIP_ACK
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059797"> </a>
Block until the receiver program explicitly confirms delivery using tpqconfirmmsg(3c)
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059803"> </a>
block = OTMQ_DEL_WF
</div>
<div class="pCellBody"><a name="wp1059991"> </a>
DIP = OTMQ_DIP_DEQ
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059805"> </a>
Block until the message is removed from the target queue.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059811"> </a>
block = OTMQ_DEL_WF
</div>
<div class="pCellBody"><a name="wp1060004"> </a>
DIP = OTMQ_DIP_MEM
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1059813"> </a>
Block until the message is stored in the target queue.
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<p class="pBody"><a name="wp1059670"> </a>
Non-recoverable message delivery is the fastest and most efficient way to send messages. Use non-recoverable delivery modes if:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1060061"> </a>	High messaging rates are required by the application (hundreds or thousands of messages per second). </li>
<li><a name="wp1060062"> </a>The message content has a finite lifetime; therefore, the value of the information is stale if not received and processed quickly. </li>
<li><a name="wp1060063"> </a>The message is sent locally between two applications in the same message queuing group that tightly cooperate in the processing of an event. </li>
<li><a name="wp1060064"> </a>The message is a control message that causes a component of an application to change state.</li>
</ul></div>
<p class="pBody"><a name="wp1060065"> </a>
Recoverable message delivery is the safest way to send a message; however, it adds significant processing overhead because each message must be stored before it is sent. Use recoverable delivery modes if:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1060066"> </a>It is useful to know that the message has arrived; however, the sender does not need to know the state of the receiver. </li>
<li><a name="wp1060067"> </a>The message content should not be lost by the application system. </li>
<li><a name="wp1060068"> </a>The application can tolerate the increased system load and slower messaging rate caused by sending the message </li>
</ul></div>
<h4 class="pHeading3"><a name="wp1060086"> </a>
Choosing an Undeliverable Message Action
</h4>
<p class="pBody"><a name="wp1060087"> </a>
Using the <code class="cCode">tpenqplus(3c)</code> function in conjunction with the delivery argument, you can use the UMA argument to specify what should happen to the message if it cannot be delivered to the delivery interest point.
</p>
<p class="pBody"><a name="wp1061856"> </a>
With non-recoverable messaging, the UMA indicates the action to be taken if the message cannot be stored in target queue. If a UMA is not specified, OTMQ will take the default action of discarding the message.
</p>
<p class="pBody"><a name="wp1060088"> </a>
With recoverable messaging, the UMA indicates the action to be taken if the message cannot be stored in either the SAF or DQF queues. You must specify a UMA with recoverable delivery modes because your application must perform the exception processing when the message cannot be guaranteed for delivery by OTMQ Message Queue Manager Server.
</p>
<p class="pBody"><a name="wp1060089"> </a>
With recoverable messaging, the UMA may be taken when:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1060090"> </a>OTMQ is unable to write to the local SAF queue where the message is designated to be recoverable. </li>
<li><a name="wp1060091"> </a>The cross-group connection to the remote target group is down and the message designated as recoverable on the remote node (DQF) cannot be stored. </li>
<li><a name="wp1061406"> </a>The system resources used by the message recovery system are exhausted. </li>
</ul></div>
<p class="pBody"><a name="wp1061407"> </a>
<a href="prog.html#wp1061411">Table&#160;4</a> lists the five valid UMAs.
</p>
<p class="pGraphic"><a name="wp1061438"> </a>
</p>
<div align="left">
<table class="table" cellpadding="3" cellspacing="0" id="wp1061411table1061408"><caption><a name="wp1061411"> </a>
Table&#160;4  UMAs

</caption>

  <tr bgcolor="#CCCCCC" align="center" valign="top">    <th scope="col"><div class="pCellHeading"><a name="wp1061415"> </a>
UMA
</div>
</th>
    <th scope="col"><div class="pCellHeading"><a name="wp1061417"> </a>
Description
</div>
</th>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061419"> </a>
OTMQ_UMA_DISC 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061421"> </a>
Discard - the message is deleted. 
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061423"> </a>
OTMQ_UMA_RTS 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061425"> </a>
Return to sender - the message is delivered to the sender&#39;s response queue. 
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061427"> </a>
OTMQ_UMA_SAF 
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061429"> </a>
Store and forward - the message is written to the message recovery journal on the sender system. 
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061431"> </a>
OTMQ_UMA_DLQ
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061433"> </a>
Dead letter queue - the message is written to the dead letter queue.
</div>
</td>
</tr>
  <tr align="left" valign="top">    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061435"> </a>
OTMQ_UMA_DLJ
</div>
</td>
    <td class="table" scope="row"><div class="pCellBody"><a name="wp1061437"> </a>
Dead letter journal - the message is written to the DLJ.
</div>
</td>
</tr>
</table>
</div>
<p class="pGraphic">

</p>
<h3 class="pHeading2"><a name="wp1060153"> </a>
How to Send a Recoverable Message
</h3>
<p class="pBody"><a name="wp1060154"> </a>
To send a recoverable message, use the <code class="cCode">tpenqplus(3c)</code> function supplying the appropriate block type, DIP and UMA in the TPQCTL structure.
</p>
<p class="pBody"><a name="wp1060155"> </a>
In addition, the application should:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1060156"> </a>specify a timeout value when sending recoverable messages with blocking delivery modes.</li>
<li><a name="wp1060157"> </a>verify the delivery outcome of a send operation from PSB in TPQCTL structure. If the message was failed to be stored by the OTMQ Message Queue Manager Server, the application must check to make sure that the UMA was successfully executed.</li>
</ul></div>
<p class="pBody"><a name="wp1060158"> </a>
The message flow for sending a recoverable message is:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1060159"> </a>The application sends a message using tpenqplus(3c) function and with the appropriate block, DIP and UMA arguments.</li>
<li><a name="wp1060160"> </a>The OTMQ Message Queue Manager Server first writes the message to the recovery journal queue on the local (SAF) or remote system (DQF) depending upon the delivery mode specified.</li>
<li><a name="wp1060161"> </a>If the sender is blocked, it continues processing once the message reaches the delivery interest point. If the sender requests notification, it received an acknowledgement message once the message reaches the delivery interest point.</li>
</ul></div>
<p class="pBody"><a name="wp1060162"> </a>
For more information, see t <code class="cCode">tpenqplus(3c)</code> in the Oracle Tuxedo Message Queue Reference Guide.
</p>
<h3 class="pHeading2"><a name="wp1060163"> </a>
How to Receive a Recoverable Message
</h3>
<p class="pBody"><a name="wp1060164"> </a>
To receive a recoverable message, use the <code class="cCode">tpdeqplus(3c)</code> function. When a recoverable message is delivered to the target queue, the application must perform the following:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1060165"> </a>Confirm message receipt, which allows the Offline Trade Driver (<code class="cCode">TuxMQFWD(5)</code>) to delete the message being stored in the recovery journal queue before delivery. </li>
<li><a name="wp1060166"> </a>Check for duplicate messages via return code. Duplicate messages may be sent by the Offline Trade Driver if the application didn&#39;t confirm message receipt in time. For more information, see<code class="cCode"> tpdeqplus(3c)</code> in the Oracle Tuxedo Message Queue Reference Guide.</li>
</ul></div>
<p class="pBody"><a name="wp1060167"> </a>
The message flow for receipt of a recoverable message is as follows:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1060168"> </a>A message is read from the message recovery journal queue by the Offline Trade Driver and sent to the target queue of the receiver.</li>
<li><a name="wp1060169"> </a>The receiver reads the message by calling tpdeqplus(3c) function.</li>
<li><a name="wp1060170"> </a>If the queue is configured for explicit confirmation, the receiver should calls the <code class="cCode">tpqconfirmmsg(3c)</code> function to acknowledge receipt of the recoverable message using the message sequence number assigned by the OTMQ Message Manager Server when the message was sent. If the queue is configured for implicit confirmation, the acknowledge message will be sent by <code class="cCode">tpdeqplus(3c)</code> automatically after the recoverable message is dequeued successfully. For more information, see <code class="cCode">tmqadmin(1)</code> in the Oracle Tuxedo Message Queue Reference Guide.</li>
<li><a name="wp1060171"> </a>The <code class="cCode">tpqconfirmmsg(3c)</code> function sends acknowledge notification to the Offline Trade Driver to notify the successful message delivery, which allows the Offline Trade Driver to remove the message from the message recovery journal queues.</li>
</ul></div>
<h3 class="pHeading2"><a name="wp1060172"> </a>
Using UMAs for Exception Processing 
</h3>
<h4 class="pHeading3"><a name="wp1060173"> </a>
Using Discard UMA
</h4>
<p class="pBody"><a name="wp1060174"> </a>
When the DISC UMA is used, the message is discarded if it cannot be delivered to the delivery interest point specified in the delivery mode argument. The DISC UMA is used when the sender program will handle each exception as it occurs. OTMQ can discard the undeliverable message because the message content is still available in the context of the sender program.
</p>
<h4 class="pHeading3"><a name="wp1060175"> </a>
Using the Return-to-Sender UMA
</h4>
<p class="pBody"><a name="wp1060176"> </a>
When the RTS UMA is used, the message is redirected to the response queue of the sender program if it cannot be delivered to the delivery interest point specified in the delivery mode argument. The RTS UMA is used when the sender program does not want to process each exception as it occurs. Instead, the sender program redirects undeliverable messages to its main input stream for error handling.
</p>
<p class="pBody"><a name="wp1060177"> </a>
The advantage of using the RTS UMA is that the sender program attaches to one queue and acts upon each message as it is read. The sender program must read the PSB status delivery value of each message to determine if the message is new or an undeliverable message. Messages that could not be stored by the message recovery system and require error handling have a return status of OTMQ__MSGUNDEL.
</p>
<h4 class="pHeading3"><a name="wp1060178"> </a>
Using the SAF UMA
</h4>
<p class="pBody"><a name="wp1060179"> </a>
When the SAF UMA is used, the message is stored in the local journal queue if the message recovery system is unable to store it in the remote journal queue. The SAF UMA can be used with recoverable delivery interest points of DQF and CONF; however, it does not work with the WF_SAF delivery mode.
</p>
<p class="pBody"><a name="wp1060180"> </a>
Use of the SAF UMA helps to manage the flow control between the sender and receiver systems. If the message cannot be written to the remote journal queue due to insufficient resources or a cross-group link failure, the message will be written to the local journal queue.
</p>
<p class="pBody"><a name="wp1060181"> </a>
Note: SAF here means nearly the same as &quot;SAF&quot; DIP. Once message cannot be delivered, store message into SAF queue.
</p>
<h4 class="pHeading3"><a name="wp1060182"> </a>
Using the Dead Letter Queue UMA
</h4>
<p class="pBody"><a name="wp1060183"> </a>
When the DLQ UMA is used, the message is redirected to the dead letter queue if it cannot be delivered to the delivery interest point specified in the delivery mode argument. The DLQ UMA is used when the sender program wants to centralize error handling for undeliverable messages in a designated queue while allowing each message to be handled separately.
</p>
<p class="pBody"><a name="wp1060184"> </a>
A dead letter queue is part of the standard group configuration for each OTMQ message queuing group. It provides memory-based storage of all undeliverable messages for the group that could not be stored for automatic recovery. The dead letter queue is defined as queue number 96 It is created automatically by <code class="cCode">tmqadmin(1)</code> <code class="cCode">qspacecreate</code> command.
</p>
<p class="pBody"><a name="wp1060185"> </a>
To use the dead letter queue, the sender program calls the <code class="cCode">tpenqplus(3c)</code> function specifying the appropriate delivery argument and using OTMQ_UMA_DLQ as the UMA argument. Any messages that cannot be delivered to the receiver program are written to the dead letter queue of the sender&#39;s group. An application program can use <code class="cCode">tpqreadjrn(3c)</code> function to retrieve undelivered messages and use the <code class="cCode">tpenqplus(3c)</code> function to attempt redelivery.
</p>
<p class="pBody"><a name="wp1064761"> </a>
An advantage of using the dead letter queue is the ability to recover undeliverable messages on a one-by-one basis. The sender program or another process within the application can attach to the DLQ and handle error recovery for each undeliverable message. A disadvantage of using the dead letter queue is the lack of disk storage for undelivered messages. A system failure on the sending node will cause all undelivered messages in the dead letter queue to be lost.
</p>
<h4 class="pHeading3"><a name="wp1064762"> </a>
Using the Dead Letter Journal
</h4>
<p class="pBody"><a name="wp1064763"> </a>
When the DLJ UMA is used, the message is written to an auxiliary journal, queue number is 196 (the dead letter journal) if it cannot be delivered to the delivery interest point specified in the delivery mode argument. This UMA can only be used for recoverable messages. The DLJ UMA is used when the sender program needs to centralize error handling procedures and the application can support the resending of many messages from DLJ queue at a delayed interval. Storing undeliverable messages in DLJ queue ensures that they will not be lost if the system goes down, and allows redelivery attempts under user or application control.
</p>
<p class="pBody"><a name="wp1060190"> </a>
The dead letter journal provides disk storage for messages that could not be stored for automatic recovery. It is created automatically by <code class="cCode">tmqadmin(1)</code> <code class="cCode">qspacecreate</code> command. 
</p>
<p class="pBody"><a name="wp1060191"> </a>
To use the dead letter journal, the sender program uses the <code class="cCode">tpenqplus(3c)</code> function specifying the appropriate delivery argument and OTMQ_UMA_DLJ as the UMA argument. Any messages that cannot be stored by the message recovery system are written to the dead letter journal of the sender&#39;s group. An application program can use <code class="cCode">tpqreadjrn(3c)</code> function to retrieve undelivered messages and use the <code class="cCode">tpenqplus(3c)</code> function to attempt redelivery as shown in <a href="prog.html#wp1066183">Listing&#160;9</a>.
</p>
<div class="pCodeTitle"><a name="wp1066183"> </a>
Listing&#160;9	   Using UMA with Undelivered Message Example
</div> <a name="wp1066184"> </a><div class="pPreformatted"><pre>TPQCTL ctl;<br />int type;<br />…<br /><br />/* join the application */<br />/* tpinit() */<br /><br />/* attach to the QSpace */<br />/* tpqattach() */<br /><br />/* get request buffer */<br />if ((reqstr = tpalloc(&quot;STRING&quot;, NULL, len)) == NULL)<br />{<br />&#160;&#160;&#160;&#160;&#160;(void) fprintf(stderr, &quot;unable to allocate STRING buffer: %s&quot;,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tpstrerror(tperrno));<br />&#160;&#160;&#160;&#160;&#160;exit(1);<br />}<br /><br />ctl.block = OTMQ_DEL_WF;              /* use synchronous way */<br />ctl.DIP = OTMQ_DIP_SAF;               /* interest point */<br />ctl.uma = OTMQ_UMA_DLJ;               /* undelivered message action - Dead Letter Journal*/<br /><br />/* enqueue the message into the destination queue */<br />if (tpenqplus(target_qspace, target_qname, &amp;ctl, reqstr, 0, 0) == -1)<br />{<br />&#160;&#160;&#160;&#160;&#160;/* deal with failed scenario */<br />&#160;&#160;&#160;&#160;&#160;…<br />}<br />…<br />…<br />/* done other works, handle failed message in DLJ before exit */<br />ctl.flags |=OTMQ;<br />ctl.flags |= TPQREADJRN;<br />type = DLJ_HANDLE;<br />if (tpqreadjrn(myqspace, myqueue, &amp;ctl, &amp;rcv_buf, &amp;len, 0) == -1)<br />{<br />&#160;&#160;&#160;&#160;&#160;/* deal with failed scenario */<br />&#160;&#160;&#160;&#160;&#160;…<br />}<br /><br />/* enqueue the failed message again */<br />if (tpenqplus(target_qspace, target_qname, &amp;ctl, rcv_buf, 0, 0) == -1)<br />{<br />&#160;&#160;&#160;&#160;&#160;/* deal with failed scenario */<br />&#160;&#160;&#160;&#160;&#160;…<br />}<br />…<br />/* detach from the Qspace */<br />/* tpqdetach() */<br />…</pre></div><h4 class="pHeading3"><a name="wp1060273"> </a>
The DIP and UMA Support List
</h4>
<p class="pBody"><a name="wp1060274"> </a>
<a href="prog.html#wp1060326">Table&#160;5</a> lists the valid delivery modes and UMA combinations. 
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1061002"> </a>
Using Naming
</h2><p class="pBody"><a name="wp1061003"> </a>
In OTMQ configuration, each message queue gets a name when created, and also can get an alias at runtime. Naming is a powerful feature that enables OTMQ applications to identify message queues by name/alias whether they reside on the local system or on another system.
</p>
<p class="pBody"><a name="wp1061004"> </a>
Application developers use the OTMQ naming feature to separate their applications from the underlying OTMQ environment configuration. By referring to message queues by name/alias in the applications, developers do not have to modify their applications code when the OTMQ environment configuration changes.
</p>
<p class="pBody"><a name="wp1061005"> </a>
The user must configure <code class="cCode">TMQ_NA(5)</code> server in UBB to take advantage of the naming service.
</p>
<h3 class="pHeading2"><a name="wp1061015"> </a>
Naming Service
</h3>
<p class="pBody"><a name="wp1061016"> </a>
Naming service is provided by the OTMQ Naming Server. It can access and manage both the local namespace and global namespace for the runtime queue lookup when an application refers to a queue by alias, or dynamic binding a queue alias to a specified queue name. OTMQ Naming Server provides two services: one for the local scope alias lookup (Local Naming Service), another for the global&#39;s (Global Naming Service). 
</p>
<h3 class="pHeading2"><a name="wp1061017"> </a>
Name Scope
</h3>
<p class="pBody"><a name="wp1061018"> </a>
When a name or alias is defined for message queue, it is assigned a name scope. Queue name or alias can have a local (intra-qspace) or global (inter-qspace) scope. A local alias can be used by applications running in the same queue space in which the alias was defined. A global alias can be used by any applications.
</p>
<h3 class="pHeading2"><a name="wp1061029"> </a>
Name Space
</h3>
<p class="pBody"><a name="wp1061030"> </a>
A name space is the repository where message queue alias and their associated message queue address (queue space and queue name) are stored. OTMQ Naming Server must look up the alias in the name space to find its associated actual queue address in order to send a message to the named queue.
</p>
<p class="pBody"><a name="wp1061031"> </a>
OTMQ Naming Server uses three levels of name spaces: process, local (qspace-wide) and global (cross qspace wide). When OTMQ Naming Server start up, the local scope alias will be stored in local name space. The global scope alias will be stored in global name space. The process name space is an application cache used to improve performance. The alias can be cached at different level name space, user can bypass caching when using <code class="cCode">tpqlocate(3c)</code> if they prefer accuracy over performance.
</p>
<h4 class="pHeading3"><a name="wp1061032"> </a>
Process Level Name Space
</h4>
<p class="pBody"><a name="wp1061033"> </a>
When application attaches to the OTMQ, application automatically creates the empty process name space. When this process locates/binds an alias for the first time, it is cached in the process name space.
</p>
<h4 class="pHeading3"><a name="wp1061034"> </a>
Local Name Space
</h4>
<p class="pBody"><a name="wp1061035"> </a>
When OTMQ Naming Server starts up, it automatically creates the local name space. Also local scope queue alias defined by applications will be cached in the local name space.
</p>
<h4 class="pHeading3"><a name="wp1061036"> </a>
Global Name Space
</h4>
<p class="pBody"><a name="wp1061037"> </a>
To create the global name space, use a flat file system by creating the directory in which the OTMQ naming service will maintain the name space.
</p>
<p class="pBody"><a name="wp1061038"> </a>
To use global naming, you must create a global namespace on the nodes on which the Naming Server runs. OTMQ allows user to configure at most two global naming services (primary and backup). To enable the backup naming service to take responsibility when the primary one is down, all the global naming services must be configured to use the same global name space. Therefore, when configured naming services run on different systems, they must use a shared file system.
</p>
<p class="pBody"><a name="wp1061039"> </a>
After creating the name space, you must set the <code class="cCode">DMQNS_DEVICE</code> environment variable to specify a device name for the name space because access to the name space for global naming is system dependent. Therefore, when a global naming service is configured, it must be told what device name to be used when it accesses this name space. This is done by setting the environment variable <code class="cCode">DMQNS_DEVICE</code> as follows:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1061040"> </a>For Windows NT, it should be set to a drive letter followed by a colon (for example, c:&gt; o a full qualified share name (e.g. <code class="cCode">\\machine\share)</code> </li>
<li><a name="wp1061041"> </a>For UNIX, it should be set to a file system specification (for example, / or <code class="cCode">/usr</code> or <code class="cCode">/mnt/dmqns</code>) </li>
</ul></div>
<a name="wp1061042"> </a><table class="Note">
<tr>
<td valign="top"><strong>Note:</strong></td>
<td>this environment variable need only be set for the OTMQ Naming Server which provides the naming services. To use the global naming service, at least some portion of the global namespace file path must be specified. For example on UNIX, you can define it as &quot;<code class="cCode">/u/mydir</code>&quot;. </td>
</tr>
</table>

<p class="pBody"><a name="wp1061043"> </a>
When an application refers to a queue by alias using the <code class="cCode">tpqlocate(3c)</code> or the <code class="cCode">tpqbind(3c)</code> functions, it can specify the alias as one of the following:
</p>
<div class="pSmartList1Bullet"><ul>
<li><a name="wp1061044"> </a>unqualified name: The application uses only the queue alias such as &quot;widgets&quot; and does not specify the path. The naming service automatically prefixes the name with the value of the environment variable <code class="cCode">DMQNS_DEVICE</code>. Furthermore, it prefix the value of the environment variable DMQNS_DEFAULTPATH begins with a &quot;/&quot;. For example, if the <code class="cCode">DMQNS_DEVICE</code> environment variable is set to &quot;dev&quot; and the DMQNS_DEFAULTPATH is set to &quot;<code class="cCode">/inventory</code>&quot;, the naming service would search for the name &quot;widgets&quot; in: <code class="cCode">/dev/inventory/widgets</code></li>
<li><a name="wp1061045"> </a>partially qualified name: The application specifies the queue alias and a portion of the path name. The naming service automatically prefixes the pathname and queue alias with the device specified as the <code class="cCode">DMQNS_DEVICE</code> environment variable and the setting of the DMQNS_DEFAULTPATH environment variable. For example, if the <code class="cCode">DMQNS_DEVICE</code> environment variable is set to &quot;/dev&quot; and the DMQNS_DEFAULTPATH is set to &quot;<code class="cCode">/inventory</code>&quot;, the naming service would search for the name &quot;<code class="cCode">test/widgets</code>&quot; in: <code class="cCode">/dev/inventory/test/widgets</code>.</li>
<li><a name="wp1061046"> </a>fully qualified name: The application specifies that the alias is a fully qualified name using &quot;/&quot; as the first character of the name. When the first character of a name begins with &quot;/&quot;, the naming service does not prefix any information to the name other than the device name specified by the <code class="cCode">DMQNS_DEVICE</code> environment variable. This means that a fully qualified name includes the full path name and queue name. For example, if the <code class="cCode">DMQNS_DEVICE</code> environment variable is set to &quot;dev&quot; and the DMQNS_DEFAULTPATH is set to &quot;/inventory&quot;, the naming service will search for the name &quot;/production/test/widgets&quot; in: /dev/production/test/widgets. <a href="prog.html#wp1066249">Listing&#160;10</a> shows a global namespace file example.</li>
<div class="pCodeTitle"><a name="wp1066249"> </a>
Listing&#160;10	   Global Namespace File Example
</div> <a name="wp1066250"> </a><div class="pPreformatted"><pre>PrimaryQ_1       0.0       L<br />myqueue1        0.0       G<br />MRQ13_1        1.13       L<br />SQ14_2          0.0       G</pre></div></ul></div>
<h3 class="pHeading2"><a name="wp1061091"> </a>
Attaching and Locating Queues
</h3>
<p class="pBody"><a name="wp1061092"> </a>
An application must attach to a queue using the <code class="cCode">tpqattach(3c)</code> function before reading message from or sending message to a queue. It can identify the queue by its alias or its name. When sending a message, the target queue is always identified by its name. An application can directly use the queue name or it can use the <code class="cCode">tpqlocate(3c)</code> function to derive the queue name from its alias.<a href="prog.html#wp1066233">Listing&#160;11</a> shows locating queue example.
</p>
<div class="pCodeTitle"><a name="wp1066233"> </a>
Listing&#160;11	   Locating Queue Example
</div> <a name="wp1064954"> </a><div class="pPreformatted"><pre>static char q_space[16] = &quot;QSPACE&quot;;<br />static char q_name[128] = &quot;myqueue1&quot;;<br />…<br />Q_NAME_CTL  name_ctl;<br />long scope = NAME_SCOPE_P;<br /><br />/* join the application */<br />/* tpinit() */<br /><br />/* attach to the QSpace */<br />/* tpqattach() */<br /><br />/* locate queue named &quot;Primary_queue&quot; */<br />name_ctl.pName = &quot;Primary_queue&quot;;<br />wait_mode = OTMQ_WF_RESP;  /* use synchronous way to get response */<br /><br />if(tpqlocate(q_space, &amp;name_ctl, 0, NULL, &amp;scope, wait_mode, 0) == -1)<br />{<br />&#160;&#160;&#160;&#160;&#160;/* deal with failed scenario */<br />&#160;&#160;&#160;&#160;&#160;…<br />}</pre></div><h3 class="pHeading2"><a name="wp1064937"> </a>
Static and Dynamic Binding of Queue Aliases
</h3>
<p class="pBody"><a name="wp1061094"> </a>
OTMQ offers two approaches to associating a queue alias with a queue address: static and dynamic.
</p>
<p class="pBody"><a name="wp1061095"> </a>
Static binding refers to associating a queue name with a queue alias using the name space file. To enable such association, you can specify the name space file when creating the queue space; or you can stop the Naming Server, then update the queue space to specify a name space file, then restart the Naming Server again. For more information, see <code class="cCode">tmqadmin(1)</code> in the Oracle Tuxedo Message Queue Reference Guide.
</p>
<p class="pBody"><a name="wp1061096"> </a>
Dynamic binding refers to the use of <code class="cCode">tpqbind(3c)</code> to associate a queue alias to a queue name at application runtime. The queue alias will not be bound to a specific queue name until the <code class="cCode">tpqbind(3c)</code> successfully return. To modify such association, the application must first unbind the queue alias from the specific queue name using <code class="cCode">tpqbind(3c)</code>, and use the same API to associate another queue alias to the queue name again. When the application detach from the queue or exit the queue space, the Naming Server will unbind the association for this application automatically. shows a dynamic binding queue example.
</p>
<div class="pCodeTitle"><a name="wp1065065"> </a>
Listing&#160;12	   Dynamic Binding Queue Example
</div> <a name="wp1066268"> </a><div class="pPreformatted"><pre>static char q_space[16] = &quot;QSPACE&quot;;<br />static char q_name[128] = &quot;myqueue1&quot;;<br /><br />…<br />Q_NAME_CTL  name_ctl;<br />long scope = NAME_SCOPE_G;<br /><br />name_ctl.pName = &quot;Primary_queue&quot;;<br />name_ctl.pGroup = q_space;<br />name_ctl.pQueue = q_name;<br /><br />bind_time_out = 30;<br /><br />if(tpqbind(q_space, &amp;name_ctl, &amp;scope, bind_time_out) == -1)<br />{<br />&#160;&#160;&#160;&#160;&#160;/* deal with failed scenario */<br />&#160;&#160;&#160;&#160;&#160;…<br />}</pre></div><p class="pBody"><a name="wp1065112"> </a>
For more information, see tpqlocate(3c) and tpqbind(3c) in the Oracle Tuxedo Message Queue Reference Guide.
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1061146"> </a>
Using WS SAF
</h2><p class="pBody"><a name="wp1061147"> </a>
In WS mode, OTMQ messages that are sent using a recoverable delivery mode are written to the local store-and-forward (SAF) journal (<code class="cCode">tmqsaf.jrn</code>) when the connection to the server system is not available.
</p>
<p class="pBody"><a name="wp1061148"> </a>
When the feature is enabled, messages sent using the following reliable delivery modes are saved to the journal:
</p>
<p class="pBodyRelative"><a name="wp1061149"> </a>
<code class="cCode">OTMQ_DIP_MEM &amp; OTMQ_DEL_WF (using OTMQ_UMA_SAF)</code>
</p>
<p class="pBodyRelative"><a name="wp1061150"> </a>
<code class="cCode">OTMQ_DIP_DQF &amp; OTMQ_DEL_WF</code>
</p>
<p class="pBodyRelative"><a name="wp1061151"> </a>
<code class="cCode">OTMQ_DIP_DQF &amp; OTMQ_DEL_AK</code>
</p>
<p class="pBodyRelative"><a name="wp1061152"> </a>
<code class="cCode">OTMQ_DIP_SAF &amp; OTMQ_DEL_WF</code>
</p>
<p class="pBodyRelative"><a name="wp1061153"> </a>
<code class="cCode">OTMQ_DIP_SAF &amp; OTMQ_DEL_AK</code>
</p>
<p class="pBody"><a name="wp1061154"> </a>
OTMQ WS configuration options allow the SAF journal to be configured as follows:
</p>
<p class="pBodyRelative"><a name="wp1061155"> </a>
A fixed-size file that does not reuse disk blocks
</p>
<p class="pBodyRelative"><a name="wp1061156"> </a>
A fixed-size file that reuses (cycles) disk blocks
</p>
<p class="pBodyRelative"><a name="wp1061157"> </a>
A dynamic file that grows indefinitely until no more disk blocks are available
</p>
<p class="pBody"><a name="wp1061158"> </a>
These options allow you to determine how disk resources are used for message journals. Journal files that grow indefinitely periodically allocate an extent of disk blocks as needed to store messages. When all messages are sent from the SAF and the journal is empty, the disk blocks used by the journal are freed and the journal file is removed. Journal file size is in units of disk block size (4096 bytes).
</p>
<p>&nbsp;</p>
<hr noshade="noshade"/>
<h2 class="pHeading1"><a name="wp1061160"> </a>
Building Applications
</h2><p class="pBody"><a name="wp1061161"> </a>
As counterparts of Tuxedo buildclient(1) and buildserver(1) commands, OTMQ provides <code class="cCode">buildqclient(1)</code> and<code class="cCode"> buildqserver(1)</code>.
</p>
<p class="pBody"><a name="wp1061162"> </a>
<code class="cCode">buildqclient(1)</code> is used to construct an OTMQ client module. The command combines the supplied files with the standard Oracle Tuxedo ATMI libraries and OTMQ libraries to form a load module.
</p>
<p class="pBody"><a name="wp1061163"> </a>
<code class="cCode">buildqserver(1)</code> is used to construct an OTMQ server load module. The command combines the supplied files with the standard server main routine, the standard Oracle Tuxedo ATMI libraries and OTMQ libraries to form a load module.
</p>
<p class="pBody"><a name="wp1065153"> </a>
For more information, see buildqclient(1) and buildqserver(1) in the Oracle Tuxedo Message Queue Reference Guide.
</p>
 
<br/>
    <table id="SummaryNotReq2" width="100%" border="0" cellpadding="0" cellspacing="0">
      <tr> 
        <td>
&nbsp;
<a href="prog.html"><img id="LongDescNotReq7" src="/global_resources/images/backtop.gif" width="90" height="25" alt="Back to Top" title="Back to Top" border="0" /></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a accesskey="4" href="index.html"><img id="LongDescNotReq8" src="/global_resources/images/prevtop.gif" border="0" alt="Previous" /></a>&nbsp;
<img id="LongDescNotReq9" src="/global_resources/images/nexttop_disabled.gif" border="0" alt="Next" />
<script language="Javascript1.1" type="text/javascript">
Copyright();
</script>
<noscript><a href="http://edocs.bea.com/copyright.html">&copy; BEA Systems</a></noscript>
        </td>
      </tr>
    </table>

<!-- WebAnalytics BEGIN -->

<!--#include virtual="/global_resources/edocs_wt.html"-->
      
<!-- WebAnalytics END -->

  </body>
</html>
